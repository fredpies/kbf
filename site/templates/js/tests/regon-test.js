import require$$0$6 from 'assert';
import url_1 from 'url';
import EventEmitter from 'events';
import util_1 from 'util';
import require$$0$4 from 'stream';
import fs from 'fs';
import http from 'http';
import https from 'https';
import require$$0$3 from 'dns';
import os from 'os';
import require$$0$5 from 'buffer';
import zlib from 'zlib';
import http2 from 'http2';
import tls from 'tls';
import net from 'net';
import require$$1$2 from 'path';
import require$$1$3 from 'string_decoder';
import require$$4 from 'timers';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

function commonjsRequire (target) {
	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var runtime_1 = createCommonjsModule(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

var regenerator = runtime_1;

function _arrayLikeToArray$i(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$i(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$i(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$i(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$i(arr) || _nonIterableSpread();
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _asyncIterator(iterable) {
  var method;

  if (typeof Symbol !== "undefined") {
    if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator];
    if (method == null && Symbol.iterator) method = iterable[Symbol.iterator];
  }

  if (method == null) method = iterable["@@asyncIterator"];
  if (method == null) method = iterable["@@iterator"];
  if (method == null) throw new TypeError("Object is not async iterable");
  return method.call(iterable);
}

function _AwaitValue(value) {
  this.wrapped = value;
}

function _awaitAsyncGenerator(value) {
  return new _AwaitValue(value);
}

function AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen["return"] !== "function") {
    this["return"] = undefined;
  }
}

AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
};

AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

AsyncGenerator.prototype["throw"] = function (arg) {
  return this._invoke("throw", arg);
};

AsyncGenerator.prototype["return"] = function (arg) {
  return this._invoke("return", arg);
};

function _wrapAsyncGenerator(fn) {
  return function () {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}

var dist$1 = createCommonjsModule(function (module, exports) {
  /// <reference lib="dom"/>
  /// <reference types="node"/>

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var typedArrayTypeNames = ['Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array', 'BigInt64Array', 'BigUint64Array'];

  function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
  }

  var objectTypeNames = ['Function', 'Generator', 'AsyncGenerator', 'GeneratorFunction', 'AsyncGeneratorFunction', 'AsyncFunction', 'Observable', 'Array', 'Buffer', 'Object', 'RegExp', 'Date', 'Error', 'Map', 'Set', 'WeakMap', 'WeakSet', 'ArrayBuffer', 'SharedArrayBuffer', 'DataView', 'Promise', 'URL', 'HTMLElement'].concat(typedArrayTypeNames);

  function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
  }

  var primitiveTypeNames = ['null', 'undefined', 'string', 'number', 'bigint', 'boolean', 'symbol'];

  function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
  } // eslint-disable-next-line @typescript-eslint/ban-types


  function isOfType(type) {
    return function (value) {
      return _typeof(value) === type;
    };
  }

  var toString = Object.prototype.toString;

  var getObjectType = function getObjectType(value) {
    var objectTypeName = toString.call(value).slice(8, -1);

    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
      return 'HTMLElement';
    }

    if (isObjectTypeName(objectTypeName)) {
      return objectTypeName;
    }

    return undefined;
  };

  var isObjectOfType = function isObjectOfType(type) {
    return function (value) {
      return getObjectType(value) === type;
    };
  };

  function is(value) {
    if (value === null) {
      return 'null';
    }

    switch (_typeof(value)) {
      case 'undefined':
        return 'undefined';

      case 'string':
        return 'string';

      case 'number':
        return 'number';

      case 'boolean':
        return 'boolean';

      case 'function':
        return 'Function';

      case 'bigint':
        return 'bigint';

      case 'symbol':
        return 'symbol';
    }

    if (is.observable(value)) {
      return 'Observable';
    }

    if (is.array(value)) {
      return 'Array';
    }

    if (is.buffer(value)) {
      return 'Buffer';
    }

    var tagType = getObjectType(value);

    if (tagType) {
      return tagType;
    }

    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
      throw new TypeError('Please don\'t use object wrappers for primitive types');
    }

    return 'Object';
  }

  is.undefined = isOfType('undefined');
  is.string = isOfType('string');
  var isNumberType = isOfType('number');

  is.number = function (value) {
    return isNumberType(value) && !is.nan(value);
  };

  is.bigint = isOfType('bigint'); // eslint-disable-next-line @typescript-eslint/ban-types

  is.function_ = isOfType('function');

  is.null_ = function (value) {
    return value === null;
  };

  is.class_ = function (value) {
    return is.function_(value) && value.toString().startsWith('class ');
  };

  is.boolean = function (value) {
    return value === true || value === false;
  };

  is.symbol = isOfType('symbol');

  is.numericString = function (value) {
    return is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
  };

  is.array = function (value, assertion) {
    if (!Array.isArray(value)) {
      return false;
    }

    if (!is.function_(assertion)) {
      return true;
    }

    return value.every(assertion);
  };

  is.buffer = function (value) {
    var _a, _b, _c, _d;

    return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false;
  };

  is.nullOrUndefined = function (value) {
    return is.null_(value) || is.undefined(value);
  };

  is.object = function (value) {
    return !is.null_(value) && (_typeof(value) === 'object' || is.function_(value));
  };

  is.iterable = function (value) {
    var _a;

    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]);
  };

  is.asyncIterable = function (value) {
    var _a;

    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]);
  };

  is.generator = function (value) {
    return is.iterable(value) && is.function_(value.next) && is.function_(value.throw);
  };

  is.asyncGenerator = function (value) {
    return is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
  };

  is.nativePromise = function (value) {
    return isObjectOfType('Promise')(value);
  };

  var hasPromiseAPI = function hasPromiseAPI(value) {
    var _a, _b;

    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
  };

  is.promise = function (value) {
    return is.nativePromise(value) || hasPromiseAPI(value);
  };

  is.generatorFunction = isObjectOfType('GeneratorFunction');

  is.asyncGeneratorFunction = function (value) {
    return getObjectType(value) === 'AsyncGeneratorFunction';
  };

  is.asyncFunction = function (value) {
    return getObjectType(value) === 'AsyncFunction';
  }; // eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types


  is.boundFunction = function (value) {
    return is.function_(value) && !value.hasOwnProperty('prototype');
  };

  is.regExp = isObjectOfType('RegExp');
  is.date = isObjectOfType('Date');
  is.error = isObjectOfType('Error');

  is.map = function (value) {
    return isObjectOfType('Map')(value);
  };

  is.set = function (value) {
    return isObjectOfType('Set')(value);
  };

  is.weakMap = function (value) {
    return isObjectOfType('WeakMap')(value);
  };

  is.weakSet = function (value) {
    return isObjectOfType('WeakSet')(value);
  };

  is.int8Array = isObjectOfType('Int8Array');
  is.uint8Array = isObjectOfType('Uint8Array');
  is.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');
  is.int16Array = isObjectOfType('Int16Array');
  is.uint16Array = isObjectOfType('Uint16Array');
  is.int32Array = isObjectOfType('Int32Array');
  is.uint32Array = isObjectOfType('Uint32Array');
  is.float32Array = isObjectOfType('Float32Array');
  is.float64Array = isObjectOfType('Float64Array');
  is.bigInt64Array = isObjectOfType('BigInt64Array');
  is.bigUint64Array = isObjectOfType('BigUint64Array');
  is.arrayBuffer = isObjectOfType('ArrayBuffer');
  is.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');
  is.dataView = isObjectOfType('DataView');

  is.directInstanceOf = function (instance, class_) {
    return Object.getPrototypeOf(instance) === class_.prototype;
  };

  is.urlInstance = function (value) {
    return isObjectOfType('URL')(value);
  };

  is.urlString = function (value) {
    if (!is.string(value)) {
      return false;
    }

    try {
      new URL(value); // eslint-disable-line no-new

      return true;
    } catch (_a) {
      return false;
    }
  }; // TODO: Use the `not` operator with a type guard here when it's available.
  // Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`


  is.truthy = function (value) {
    return Boolean(value);
  }; // Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`


  is.falsy = function (value) {
    return !value;
  };

  is.nan = function (value) {
    return Number.isNaN(value);
  };

  is.primitive = function (value) {
    return is.null_(value) || isPrimitiveTypeName(_typeof(value));
  };

  is.integer = function (value) {
    return Number.isInteger(value);
  };

  is.safeInteger = function (value) {
    return Number.isSafeInteger(value);
  };

  is.plainObject = function (value) {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (toString.call(value) !== '[object Object]') {
      return false;
    }

    var prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
  };

  is.typedArray = function (value) {
    return isTypedArrayName(getObjectType(value));
  };

  var isValidLength = function isValidLength(value) {
    return is.safeInteger(value) && value >= 0;
  };

  is.arrayLike = function (value) {
    return !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
  };

  is.inRange = function (value, range) {
    if (is.number(range)) {
      return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }

    if (is.array(range) && range.length === 2) {
      return value >= Math.min.apply(Math, _toConsumableArray(range)) && value <= Math.max.apply(Math, _toConsumableArray(range));
    }

    throw new TypeError("Invalid range: ".concat(JSON.stringify(range)));
  };

  var NODE_TYPE_ELEMENT = 1;
  var DOM_PROPERTIES_TO_CHECK = ['innerHTML', 'ownerDocument', 'style', 'attributes', 'nodeValue'];

  is.domElement = function (value) {
    return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every(function (property) {
      return property in value;
    });
  };

  is.observable = function (value) {
    var _a, _b, _c, _d;

    if (!value) {
      return false;
    } // eslint-disable-next-line no-use-extend-native/no-use-extend-native


    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
      return true;
    }

    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {
      return true;
    }

    return false;
  };

  is.nodeStream = function (value) {
    return is.object(value) && is.function_(value.pipe) && !is.observable(value);
  };

  is.infinite = function (value) {
    return value === Infinity || value === -Infinity;
  };

  var isAbsoluteMod2 = function isAbsoluteMod2(remainder) {
    return function (value) {
      return is.integer(value) && Math.abs(value % 2) === remainder;
    };
  };

  is.evenInteger = isAbsoluteMod2(0);
  is.oddInteger = isAbsoluteMod2(1);

  is.emptyArray = function (value) {
    return is.array(value) && value.length === 0;
  };

  is.nonEmptyArray = function (value) {
    return is.array(value) && value.length > 0;
  };

  is.emptyString = function (value) {
    return is.string(value) && value.length === 0;
  }; // TODO: Use `not ''` when the `not` operator is available.


  is.nonEmptyString = function (value) {
    return is.string(value) && value.length > 0;
  };

  var isWhiteSpaceString = function isWhiteSpaceString(value) {
    return is.string(value) && !/\S/.test(value);
  };

  is.emptyStringOrWhitespace = function (value) {
    return is.emptyString(value) || isWhiteSpaceString(value);
  };

  is.emptyObject = function (value) {
    return is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
  }; // TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
  // - https://github.com/Microsoft/TypeScript/pull/29317


  is.nonEmptyObject = function (value) {
    return is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
  };

  is.emptySet = function (value) {
    return is.set(value) && value.size === 0;
  };

  is.nonEmptySet = function (value) {
    return is.set(value) && value.size > 0;
  };

  is.emptyMap = function (value) {
    return is.map(value) && value.size === 0;
  };

  is.nonEmptyMap = function (value) {
    return is.map(value) && value.size > 0;
  };

  var predicateOnArray = function predicateOnArray(method, predicate, values) {
    if (!is.function_(predicate)) {
      throw new TypeError("Invalid predicate: ".concat(JSON.stringify(predicate)));
    }

    if (values.length === 0) {
      throw new TypeError('Invalid number of values');
    }

    return method.call(values, predicate);
  };

  is.any = function (predicate) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    var predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some(function (singlePredicate) {
      return predicateOnArray(Array.prototype.some, singlePredicate, values);
    });
  };

  is.all = function (predicate) {
    for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      values[_key2 - 1] = arguments[_key2];
    }

    return predicateOnArray(Array.prototype.every, predicate, values);
  };

  var assertType = function assertType(condition, description, value) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    if (!condition) {
      var multipleValues = options.multipleValues;
      var valuesMessage = multipleValues ? "received values of types ".concat(_toConsumableArray(new Set(value.map(function (singleValue) {
        return "`".concat(is(singleValue), "`");
      }))).join(', ')) : "received value of type `".concat(is(value), "`");
      throw new TypeError("Expected value which is `".concat(description, "`, ").concat(valuesMessage, "."));
    }
  };

  exports.assert = {
    // Unknowns.
    undefined: function undefined$1(value) {
      return assertType(is.undefined(value), 'undefined', value);
    },
    string: function string(value) {
      return assertType(is.string(value), 'string', value);
    },
    number: function number(value) {
      return assertType(is.number(value), 'number', value);
    },
    bigint: function bigint(value) {
      return assertType(is.bigint(value), 'bigint', value);
    },
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: function function_(value) {
      return assertType(is.function_(value), 'Function', value);
    },
    null_: function null_(value) {
      return assertType(is.null_(value), 'null', value);
    },
    class_: function class_(value) {
      return assertType(is.class_(value), "Class"
      /* class_ */
      , value);
    },
    boolean: function boolean(value) {
      return assertType(is.boolean(value), 'boolean', value);
    },
    symbol: function symbol(value) {
      return assertType(is.symbol(value), 'symbol', value);
    },
    numericString: function numericString(value) {
      return assertType(is.numericString(value), "string with a number"
      /* numericString */
      , value);
    },
    array: function array(value, assertion) {
      var assert = assertType;
      assert(is.array(value), 'Array', value);

      if (assertion) {
        value.forEach(assertion);
      }
    },
    buffer: function buffer(value) {
      return assertType(is.buffer(value), 'Buffer', value);
    },
    nullOrUndefined: function nullOrUndefined(value) {
      return assertType(is.nullOrUndefined(value), "null or undefined"
      /* nullOrUndefined */
      , value);
    },
    object: function object(value) {
      return assertType(is.object(value), 'Object', value);
    },
    iterable: function iterable(value) {
      return assertType(is.iterable(value), "Iterable"
      /* iterable */
      , value);
    },
    asyncIterable: function asyncIterable(value) {
      return assertType(is.asyncIterable(value), "AsyncIterable"
      /* asyncIterable */
      , value);
    },
    generator: function generator(value) {
      return assertType(is.generator(value), 'Generator', value);
    },
    asyncGenerator: function asyncGenerator(value) {
      return assertType(is.asyncGenerator(value), 'AsyncGenerator', value);
    },
    nativePromise: function nativePromise(value) {
      return assertType(is.nativePromise(value), "native Promise"
      /* nativePromise */
      , value);
    },
    promise: function promise(value) {
      return assertType(is.promise(value), 'Promise', value);
    },
    generatorFunction: function generatorFunction(value) {
      return assertType(is.generatorFunction(value), 'GeneratorFunction', value);
    },
    asyncGeneratorFunction: function asyncGeneratorFunction(value) {
      return assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value);
    },
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: function asyncFunction(value) {
      return assertType(is.asyncFunction(value), 'AsyncFunction', value);
    },
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: function boundFunction(value) {
      return assertType(is.boundFunction(value), 'Function', value);
    },
    regExp: function regExp(value) {
      return assertType(is.regExp(value), 'RegExp', value);
    },
    date: function date(value) {
      return assertType(is.date(value), 'Date', value);
    },
    error: function error(value) {
      return assertType(is.error(value), 'Error', value);
    },
    map: function map(value) {
      return assertType(is.map(value), 'Map', value);
    },
    set: function set(value) {
      return assertType(is.set(value), 'Set', value);
    },
    weakMap: function weakMap(value) {
      return assertType(is.weakMap(value), 'WeakMap', value);
    },
    weakSet: function weakSet(value) {
      return assertType(is.weakSet(value), 'WeakSet', value);
    },
    int8Array: function int8Array(value) {
      return assertType(is.int8Array(value), 'Int8Array', value);
    },
    uint8Array: function uint8Array(value) {
      return assertType(is.uint8Array(value), 'Uint8Array', value);
    },
    uint8ClampedArray: function uint8ClampedArray(value) {
      return assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value);
    },
    int16Array: function int16Array(value) {
      return assertType(is.int16Array(value), 'Int16Array', value);
    },
    uint16Array: function uint16Array(value) {
      return assertType(is.uint16Array(value), 'Uint16Array', value);
    },
    int32Array: function int32Array(value) {
      return assertType(is.int32Array(value), 'Int32Array', value);
    },
    uint32Array: function uint32Array(value) {
      return assertType(is.uint32Array(value), 'Uint32Array', value);
    },
    float32Array: function float32Array(value) {
      return assertType(is.float32Array(value), 'Float32Array', value);
    },
    float64Array: function float64Array(value) {
      return assertType(is.float64Array(value), 'Float64Array', value);
    },
    bigInt64Array: function bigInt64Array(value) {
      return assertType(is.bigInt64Array(value), 'BigInt64Array', value);
    },
    bigUint64Array: function bigUint64Array(value) {
      return assertType(is.bigUint64Array(value), 'BigUint64Array', value);
    },
    arrayBuffer: function arrayBuffer(value) {
      return assertType(is.arrayBuffer(value), 'ArrayBuffer', value);
    },
    sharedArrayBuffer: function sharedArrayBuffer(value) {
      return assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value);
    },
    dataView: function dataView(value) {
      return assertType(is.dataView(value), 'DataView', value);
    },
    urlInstance: function urlInstance(value) {
      return assertType(is.urlInstance(value), 'URL', value);
    },
    urlString: function urlString(value) {
      return assertType(is.urlString(value), "string with a URL"
      /* urlString */
      , value);
    },
    truthy: function truthy(value) {
      return assertType(is.truthy(value), "truthy"
      /* truthy */
      , value);
    },
    falsy: function falsy(value) {
      return assertType(is.falsy(value), "falsy"
      /* falsy */
      , value);
    },
    nan: function nan(value) {
      return assertType(is.nan(value), "NaN"
      /* nan */
      , value);
    },
    primitive: function primitive(value) {
      return assertType(is.primitive(value), "primitive"
      /* primitive */
      , value);
    },
    integer: function integer(value) {
      return assertType(is.integer(value), "integer"
      /* integer */
      , value);
    },
    safeInteger: function safeInteger(value) {
      return assertType(is.safeInteger(value), "integer"
      /* safeInteger */
      , value);
    },
    plainObject: function plainObject(value) {
      return assertType(is.plainObject(value), "plain object"
      /* plainObject */
      , value);
    },
    typedArray: function typedArray(value) {
      return assertType(is.typedArray(value), "TypedArray"
      /* typedArray */
      , value);
    },
    arrayLike: function arrayLike(value) {
      return assertType(is.arrayLike(value), "array-like"
      /* arrayLike */
      , value);
    },
    domElement: function domElement(value) {
      return assertType(is.domElement(value), "HTMLElement"
      /* domElement */
      , value);
    },
    observable: function observable(value) {
      return assertType(is.observable(value), 'Observable', value);
    },
    nodeStream: function nodeStream(value) {
      return assertType(is.nodeStream(value), "Node.js Stream"
      /* nodeStream */
      , value);
    },
    infinite: function infinite(value) {
      return assertType(is.infinite(value), "infinite number"
      /* infinite */
      , value);
    },
    emptyArray: function emptyArray(value) {
      return assertType(is.emptyArray(value), "empty array"
      /* emptyArray */
      , value);
    },
    nonEmptyArray: function nonEmptyArray(value) {
      return assertType(is.nonEmptyArray(value), "non-empty array"
      /* nonEmptyArray */
      , value);
    },
    emptyString: function emptyString(value) {
      return assertType(is.emptyString(value), "empty string"
      /* emptyString */
      , value);
    },
    nonEmptyString: function nonEmptyString(value) {
      return assertType(is.nonEmptyString(value), "non-empty string"
      /* nonEmptyString */
      , value);
    },
    emptyStringOrWhitespace: function emptyStringOrWhitespace(value) {
      return assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace"
      /* emptyStringOrWhitespace */
      , value);
    },
    emptyObject: function emptyObject(value) {
      return assertType(is.emptyObject(value), "empty object"
      /* emptyObject */
      , value);
    },
    nonEmptyObject: function nonEmptyObject(value) {
      return assertType(is.nonEmptyObject(value), "non-empty object"
      /* nonEmptyObject */
      , value);
    },
    emptySet: function emptySet(value) {
      return assertType(is.emptySet(value), "empty set"
      /* emptySet */
      , value);
    },
    nonEmptySet: function nonEmptySet(value) {
      return assertType(is.nonEmptySet(value), "non-empty set"
      /* nonEmptySet */
      , value);
    },
    emptyMap: function emptyMap(value) {
      return assertType(is.emptyMap(value), "empty map"
      /* emptyMap */
      , value);
    },
    nonEmptyMap: function nonEmptyMap(value) {
      return assertType(is.nonEmptyMap(value), "non-empty map"
      /* nonEmptyMap */
      , value);
    },
    // Numbers.
    evenInteger: function evenInteger(value) {
      return assertType(is.evenInteger(value), "even integer"
      /* evenInteger */
      , value);
    },
    oddInteger: function oddInteger(value) {
      return assertType(is.oddInteger(value), "odd integer"
      /* oddInteger */
      , value);
    },
    // Two arguments.
    directInstanceOf: function directInstanceOf(instance, class_) {
      return assertType(is.directInstanceOf(instance, class_), "T"
      /* directInstanceOf */
      , instance);
    },
    inRange: function inRange(value, range) {
      return assertType(is.inRange(value, range), "in range"
      /* inRange */
      , value);
    },
    // Variadic functions.
    any: function any(predicate) {
      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        values[_key3 - 1] = arguments[_key3];
      }

      return assertType(is.any.apply(is, [predicate].concat(values)), "predicate returns truthy for any value"
      /* any */
      , values, {
        multipleValues: true
      });
    },
    all: function all(predicate) {
      for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        values[_key4 - 1] = arguments[_key4];
      }

      return assertType(is.all.apply(is, [predicate].concat(values)), "predicate returns truthy for all values"
      /* all */
      , values, {
        multipleValues: true
      });
    }
  }; // Some few keywords are reserved, but we'll populate them for Node.js users
  // See https://github.com/Microsoft/TypeScript/issues/2536

  Object.defineProperties(is, {
    class: {
      value: is.class_
    },
    function: {
      value: is.function_
    },
    null: {
      value: is.null_
    }
  });
  Object.defineProperties(exports.assert, {
    class: {
      value: exports.assert.class_
    },
    function: {
      value: exports.assert.function_
    },
    null: {
      value: exports.assert.null_
    }
  });
  exports.default = is; // For CommonJS default export support

  module.exports = is;
  module.exports.default = is;
  module.exports.assert = exports.assert;
});

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$i(arr, i) || _nonIterableRest();
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$d()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _createForOfIteratorHelper$h(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$h(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$h(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$h(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen); }

function _arrayLikeToArray$h(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var CancelError = /*#__PURE__*/function (_Error) {
  _inherits(CancelError, _Error);

  var _super = _createSuper$c(CancelError);

  function CancelError(reason) {
    var _this;

    _classCallCheck(this, CancelError);

    _this = _super.call(this, reason || 'Promise was canceled');
    _this.name = 'CancelError';
    return _this;
  }

  _createClass(CancelError, [{
    key: "isCanceled",
    get: function get() {
      return true;
    }
  }]);

  return CancelError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var PCancelable = /*#__PURE__*/function () {
  function PCancelable(executor) {
    var _this2 = this;

    _classCallCheck(this, PCancelable);

    this._cancelHandlers = [];
    this._isPending = true;
    this._isCanceled = false;
    this._rejectOnCancel = true;
    this._promise = new Promise(function (resolve, reject) {
      _this2._reject = reject;

      var onResolve = function onResolve(value) {
        if (!_this2._isCanceled || !onCancel.shouldReject) {
          _this2._isPending = false;
          resolve(value);
        }
      };

      var onReject = function onReject(error) {
        _this2._isPending = false;
        reject(error);
      };

      var onCancel = function onCancel(handler) {
        if (!_this2._isPending) {
          throw new Error('The `onCancel` handler was attached after the promise settled.');
        }

        _this2._cancelHandlers.push(handler);
      };

      Object.defineProperties(onCancel, {
        shouldReject: {
          get: function get() {
            return _this2._rejectOnCancel;
          },
          set: function set(boolean) {
            _this2._rejectOnCancel = boolean;
          }
        }
      });
      return executor(onResolve, onReject, onCancel);
    });
  }

  _createClass(PCancelable, [{
    key: "then",
    value: function then(onFulfilled, onRejected) {
      // eslint-disable-next-line promise/prefer-await-to-then
      return this._promise.then(onFulfilled, onRejected);
    }
  }, {
    key: "catch",
    value: function _catch(onRejected) {
      return this._promise.catch(onRejected);
    }
  }, {
    key: "finally",
    value: function _finally(onFinally) {
      return this._promise.finally(onFinally);
    }
  }, {
    key: "cancel",
    value: function cancel(reason) {
      if (!this._isPending || this._isCanceled) {
        return;
      }

      this._isCanceled = true;

      if (this._cancelHandlers.length > 0) {
        try {
          var _iterator = _createForOfIteratorHelper$h(this._cancelHandlers),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var handler = _step.value;
              handler();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } catch (error) {
          this._reject(error);

          return;
        }
      }

      if (this._rejectOnCancel) {
        this._reject(new CancelError(reason));
      }
    }
  }, {
    key: "isCanceled",
    get: function get() {
      return this._isCanceled;
    }
  }], [{
    key: "fn",
    value: function fn(userFn) {
      return function () {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }

        return new PCancelable(function (resolve, reject, onCancel) {
          arguments_.push(onCancel); // eslint-disable-next-line promise/prefer-await-to-then

          userFn.apply(void 0, arguments_).then(resolve, reject);
        });
      };
    }
  }]);

  return PCancelable;
}();

Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
var pCancelable = PCancelable;
var CancelError_1 = CancelError;
pCancelable.CancelError = CancelError_1;

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

var source$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function isTLSSocket(socket) {
    return socket.encrypted;
  }

  var deferToConnect = function deferToConnect(socket, fn) {
    var listeners;

    if (typeof fn === 'function') {
      var connect = fn;
      listeners = {
        connect: connect
      };
    } else {
      listeners = fn;
    }

    var hasConnectListener = typeof listeners.connect === 'function';
    var hasSecureConnectListener = typeof listeners.secureConnect === 'function';
    var hasCloseListener = typeof listeners.close === 'function';

    var onConnect = function onConnect() {
      if (hasConnectListener) {
        listeners.connect();
      }

      if (isTLSSocket(socket) && hasSecureConnectListener) {
        if (socket.authorized) {
          listeners.secureConnect();
        } else if (!socket.authorizationError) {
          socket.once('secureConnect', listeners.secureConnect);
        }
      }

      if (hasCloseListener) {
        socket.once('close', listeners.close);
      }
    };

    if (socket.writable && !socket.connecting) {
      onConnect();
    } else if (socket.connecting) {
      socket.once('connect', onConnect);
    } else if (socket.destroyed && hasCloseListener) {
      listeners.close(socket._hadError);
    }
  };

  exports.default = deferToConnect; // For CommonJS default export support

  module.exports = deferToConnect;
  module.exports.default = deferToConnect;
});

var source$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var nodejsMajorVersion = Number(process.versions.node.split('.')[0]);

  var timer = function timer(request) {
    var timings = {
      start: Date.now(),
      socket: undefined,
      lookup: undefined,
      connect: undefined,
      secureConnect: undefined,
      upload: undefined,
      response: undefined,
      end: undefined,
      error: undefined,
      abort: undefined,
      phases: {
        wait: undefined,
        dns: undefined,
        tcp: undefined,
        tls: undefined,
        request: undefined,
        firstByte: undefined,
        download: undefined,
        total: undefined
      }
    };
    request.timings = timings;

    var handleError = function handleError(origin) {
      var emit = origin.emit.bind(origin);

      origin.emit = function (event) {
        // Catches the `error` event
        if (event === 'error') {
          timings.error = Date.now();
          timings.phases.total = timings.error - timings.start;
          origin.emit = emit;
        } // Saves the original behavior


        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return emit.apply(void 0, [event].concat(args));
      };
    };

    handleError(request);
    request.prependOnceListener('abort', function () {
      timings.abort = Date.now(); // Let the `end` response event be responsible for setting the total phase,
      // unless the Node.js major version is >= 13.

      if (!timings.response || nodejsMajorVersion >= 13) {
        timings.phases.total = Date.now() - timings.start;
      }
    });

    var onSocket = function onSocket(socket) {
      timings.socket = Date.now();
      timings.phases.wait = timings.socket - timings.start;

      var lookupListener = function lookupListener() {
        timings.lookup = Date.now();
        timings.phases.dns = timings.lookup - timings.socket;
      };

      socket.prependOnceListener('lookup', lookupListener);
      source$4.default(socket, {
        connect: function connect() {
          timings.connect = Date.now();

          if (timings.lookup === undefined) {
            socket.removeListener('lookup', lookupListener);
            timings.lookup = timings.connect;
            timings.phases.dns = timings.lookup - timings.socket;
          }

          timings.phases.tcp = timings.connect - timings.lookup; // This callback is called before flushing any data,
          // so we don't need to set `timings.phases.request` here.
        },
        secureConnect: function secureConnect() {
          timings.secureConnect = Date.now();
          timings.phases.tls = timings.secureConnect - timings.connect;
        }
      });
    };

    if (request.socket) {
      onSocket(request.socket);
    } else {
      request.prependOnceListener('socket', onSocket);
    }

    var onUpload = function onUpload() {
      var _a;

      timings.upload = Date.now();
      timings.phases.request = timings.upload - (_a = timings.secureConnect, _a !== null && _a !== void 0 ? _a : timings.connect);
    };

    var writableFinished = function writableFinished() {
      if (typeof request.writableFinished === 'boolean') {
        return request.writableFinished;
      } // Node.js doesn't have `request.writableFinished` property


      return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);
    };

    if (writableFinished()) {
      onUpload();
    } else {
      request.prependOnceListener('finish', onUpload);
    }

    request.prependOnceListener('response', function (response) {
      timings.response = Date.now();
      timings.phases.firstByte = timings.response - timings.upload;
      response.timings = timings;
      handleError(response);
      response.prependOnceListener('end', function () {
        timings.end = Date.now();
        timings.phases.download = timings.end - timings.response;
        timings.phases.total = timings.end - timings.start;
      });
    });
    return timings;
  };

  exports.default = timer; // For CommonJS default export support

  module.exports = timer;
  module.exports.default = timer;
});

function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper$g(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$g(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$g(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$g(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen); }

function _arrayLikeToArray$g(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var V4MAPPED = require$$0$3.V4MAPPED,
    ADDRCONFIG = require$$0$3.ADDRCONFIG,
    ALL = require$$0$3.ALL,
    AsyncResolver = require$$0$3.promises.Resolver,
    dnsLookup = require$$0$3.lookup;
var promisify = util_1.promisify;
var kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');
var kCacheableLookupInstance = Symbol('cacheableLookupInstance');
var kExpires = Symbol('expires');
var supportsALL = typeof ALL === 'number';

var verifyAgent = function verifyAgent(agent) {
  if (!(agent && typeof agent.createConnection === 'function')) {
    throw new Error('Expected an Agent instance as the first argument');
  }
};

var map4to6 = function map4to6(entries) {
  var _iterator = _createForOfIteratorHelper$g(entries),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var entry = _step.value;

      if (entry.family === 6) {
        continue;
      }

      entry.address = "::ffff:".concat(entry.address);
      entry.family = 6;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};

var getIfaceInfo = function getIfaceInfo() {
  var has4 = false;
  var has6 = false;

  for (var _i = 0, _Object$values = Object.values(os.networkInterfaces()); _i < _Object$values.length; _i++) {
    var device = _Object$values[_i];

    var _iterator2 = _createForOfIteratorHelper$g(device),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var iface = _step2.value;

        if (iface.internal) {
          continue;
        }

        if (iface.family === 'IPv6') {
          has6 = true;
        } else {
          has4 = true;
        }

        if (has4 && has6) {
          return {
            has4: has4,
            has6: has6
          };
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return {
    has4: has4,
    has6: has6
  };
};

var isIterable = function isIterable(map) {
  return Symbol.iterator in map;
};

var ttl = {
  ttl: true
};
var all = {
  all: true
};

var CacheableLookup = /*#__PURE__*/function () {
  function CacheableLookup() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cache = _ref.cache,
        cache = _ref$cache === void 0 ? new Map() : _ref$cache,
        _ref$maxTtl = _ref.maxTtl,
        maxTtl = _ref$maxTtl === void 0 ? Infinity : _ref$maxTtl,
        _ref$fallbackDuration = _ref.fallbackDuration,
        fallbackDuration = _ref$fallbackDuration === void 0 ? 3600 : _ref$fallbackDuration,
        _ref$errorTtl = _ref.errorTtl,
        errorTtl = _ref$errorTtl === void 0 ? 0.15 : _ref$errorTtl,
        _ref$resolver = _ref.resolver,
        resolver = _ref$resolver === void 0 ? new AsyncResolver() : _ref$resolver,
        _ref$lookup = _ref.lookup,
        lookup = _ref$lookup === void 0 ? dnsLookup : _ref$lookup;

    _classCallCheck(this, CacheableLookup);

    this.maxTtl = maxTtl;
    this.errorTtl = errorTtl;
    this._cache = cache;
    this._resolver = resolver;
    this._dnsLookup = promisify(lookup);

    if (this._resolver instanceof AsyncResolver) {
      this._resolve4 = this._resolver.resolve4.bind(this._resolver);
      this._resolve6 = this._resolver.resolve6.bind(this._resolver);
    } else {
      this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
      this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
    }

    this._iface = getIfaceInfo();
    this._pending = {};
    this._nextRemovalTime = false;
    this._hostnamesToFallback = new Set();

    if (fallbackDuration < 1) {
      this._fallback = false;
    } else {
      this._fallback = true;
      var interval = setInterval(function () {
        _this._hostnamesToFallback.clear();
      }, fallbackDuration * 1000);
      /* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */

      if (interval.unref) {
        interval.unref();
      }
    }

    this.lookup = this.lookup.bind(this);
    this.lookupAsync = this.lookupAsync.bind(this);
  }

  _createClass(CacheableLookup, [{
    key: "servers",
    get: function get() {
      return this._resolver.getServers();
    },
    set: function set(servers) {
      this.clear();

      this._resolver.setServers(servers);
    }
  }, {
    key: "lookup",
    value: function lookup(hostname, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      } else if (typeof options === 'number') {
        options = {
          family: options
        };
      }

      if (!callback) {
        throw new Error('Callback must be a function.');
      } // eslint-disable-next-line promise/prefer-await-to-then


      this.lookupAsync(hostname, options).then(function (result) {
        if (options.all) {
          callback(null, result);
        } else {
          callback(null, result.address, result.family, result.expires, result.ttl);
        }
      }, callback);
    }
  }, {
    key: "lookupAsync",
    value: function () {
      var _lookupAsync = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(hostname) {
        var options,
            cached,
            filtered,
            _iface,
            error,
            _args = arguments;

        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};

                if (typeof options === 'number') {
                  options = {
                    family: options
                  };
                }

                _context.next = 4;
                return this.query(hostname);

              case 4:
                cached = _context.sent;

                if (options.family === 6) {
                  filtered = cached.filter(function (entry) {
                    return entry.family === 6;
                  });

                  if (options.hints & V4MAPPED) {
                    if (supportsALL && options.hints & ALL || filtered.length === 0) {
                      map4to6(cached);
                    } else {
                      cached = filtered;
                    }
                  } else {
                    cached = filtered;
                  }
                } else if (options.family === 4) {
                  cached = cached.filter(function (entry) {
                    return entry.family === 4;
                  });
                }

                if (options.hints & ADDRCONFIG) {
                  _iface = this._iface;
                  cached = cached.filter(function (entry) {
                    return entry.family === 6 ? _iface.has6 : _iface.has4;
                  });
                }

                if (!(cached.length === 0)) {
                  _context.next = 12;
                  break;
                }

                error = new Error("cacheableLookup ENOTFOUND ".concat(hostname));
                error.code = 'ENOTFOUND';
                error.hostname = hostname;
                throw error;

              case 12:
                if (!options.all) {
                  _context.next = 14;
                  break;
                }

                return _context.abrupt("return", cached);

              case 14:
                return _context.abrupt("return", cached[0]);

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lookupAsync(_x) {
        return _lookupAsync.apply(this, arguments);
      }

      return lookupAsync;
    }()
  }, {
    key: "query",
    value: function () {
      var _query = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(hostname) {
        var cached, pending, newPromise;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._cache.get(hostname);

              case 2:
                cached = _context2.sent;

                if (cached) {
                  _context2.next = 20;
                  break;
                }

                pending = this._pending[hostname];

                if (!pending) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 8;
                return pending;

              case 8:
                cached = _context2.sent;
                _context2.next = 20;
                break;

              case 11:
                newPromise = this.queryAndCache(hostname);
                this._pending[hostname] = newPromise;
                _context2.prev = 13;
                _context2.next = 16;
                return newPromise;

              case 16:
                cached = _context2.sent;

              case 17:
                _context2.prev = 17;
                delete this._pending[hostname];
                return _context2.finish(17);

              case 20:
                cached = cached.map(function (entry) {
                  return _objectSpread$c({}, entry);
                });
                return _context2.abrupt("return", cached);

              case 22:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[13,, 17, 20]]);
      }));

      function query(_x2) {
        return _query.apply(this, arguments);
      }

      return query;
    }()
  }, {
    key: "_resolve",
    value: function () {
      var _resolve2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(hostname) {
        var wrap, _yield$Promise$all, _yield$Promise$all2, A, AAAA, aTtl, aaaaTtl, cacheTtl, now, _iterator3, _step3, entry, _iterator4, _step4, _entry;

        return regenerator.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                wrap = /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(promise) {
                    return regenerator.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.prev = 0;
                            _context3.next = 3;
                            return promise;

                          case 3:
                            return _context3.abrupt("return", _context3.sent);

                          case 6:
                            _context3.prev = 6;
                            _context3.t0 = _context3["catch"](0);

                            if (!(_context3.t0.code === 'ENODATA' || _context3.t0.code === 'ENOTFOUND')) {
                              _context3.next = 10;
                              break;
                            }

                            return _context3.abrupt("return", []);

                          case 10:
                            throw _context3.t0;

                          case 11:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, null, [[0, 6]]);
                  }));

                  return function wrap(_x4) {
                    return _ref2.apply(this, arguments);
                  };
                }(); // ANY is unsafe as it doesn't trigger new queries in the underlying server.


                _context4.next = 3;
                return Promise.all([this._resolve4(hostname, ttl), this._resolve6(hostname, ttl)].map(function (promise) {
                  return wrap(promise);
                }));

              case 3:
                _yield$Promise$all = _context4.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                A = _yield$Promise$all2[0];
                AAAA = _yield$Promise$all2[1];
                aTtl = 0;
                aaaaTtl = 0;
                cacheTtl = 0;
                now = Date.now();
                _iterator3 = _createForOfIteratorHelper$g(A);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    entry = _step3.value;
                    entry.family = 4;
                    entry.expires = now + entry.ttl * 1000;
                    aTtl = Math.max(aTtl, entry.ttl);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                _iterator4 = _createForOfIteratorHelper$g(AAAA);

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    _entry = _step4.value;
                    _entry.family = 6;
                    _entry.expires = now + _entry.ttl * 1000;
                    aaaaTtl = Math.max(aaaaTtl, _entry.ttl);
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }

                if (A.length > 0) {
                  if (AAAA.length > 0) {
                    cacheTtl = Math.min(aTtl, aaaaTtl);
                  } else {
                    cacheTtl = aTtl;
                  }
                } else {
                  cacheTtl = aaaaTtl;
                }

                return _context4.abrupt("return", {
                  entries: [].concat(_toConsumableArray(A), _toConsumableArray(AAAA)),
                  cacheTtl: cacheTtl
                });

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _resolve(_x3) {
        return _resolve2.apply(this, arguments);
      }

      return _resolve;
    }()
  }, {
    key: "_lookup",
    value: function () {
      var _lookup2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(hostname) {
        var entries;
        return regenerator.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;
                _context5.next = 3;
                return this._dnsLookup(hostname, {
                  all: true
                });

              case 3:
                entries = _context5.sent;
                return _context5.abrupt("return", {
                  entries: entries,
                  cacheTtl: 0
                });

              case 7:
                _context5.prev = 7;
                _context5.t0 = _context5["catch"](0);
                return _context5.abrupt("return", {
                  entries: [],
                  cacheTtl: 0
                });

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[0, 7]]);
      }));

      function _lookup(_x5) {
        return _lookup2.apply(this, arguments);
      }

      return _lookup;
    }()
  }, {
    key: "_set",
    value: function () {
      var _set2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(hostname, data, cacheTtl) {
        return regenerator.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this.maxTtl > 0 && cacheTtl > 0)) {
                  _context7.next = 12;
                  break;
                }

                cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
                data[kExpires] = Date.now() + cacheTtl;
                _context7.prev = 3;
                _context7.next = 6;
                return this._cache.set(hostname, data, cacheTtl);

              case 6:
                _context7.next = 11;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);
                this.lookupAsync = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
                  var cacheError;
                  return regenerator.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');
                          cacheError.cause = _context7.t0;
                          throw cacheError;

                        case 3:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                }));

              case 11:
                if (isIterable(this._cache)) {
                  this._tick(cacheTtl);
                }

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8]]);
      }));

      function _set(_x6, _x7, _x8) {
        return _set2.apply(this, arguments);
      }

      return _set;
    }()
  }, {
    key: "queryAndCache",
    value: function () {
      var _queryAndCache = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(hostname) {
        var query, cacheTtl;
        return regenerator.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!this._hostnamesToFallback.has(hostname)) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", this._dnsLookup(hostname, all));

              case 2:
                _context8.next = 4;
                return this._resolve(hostname);

              case 4:
                query = _context8.sent;

                if (!(query.entries.length === 0 && this._fallback)) {
                  _context8.next = 10;
                  break;
                }

                _context8.next = 8;
                return this._lookup(hostname);

              case 8:
                query = _context8.sent;

                if (query.entries.length !== 0) {
                  // Use `dns.lookup(...)` for that particular hostname
                  this._hostnamesToFallback.add(hostname);
                }

              case 10:
                cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
                _context8.next = 13;
                return this._set(hostname, query.entries, cacheTtl);

              case 13:
                return _context8.abrupt("return", query.entries);

              case 14:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function queryAndCache(_x9) {
        return _queryAndCache.apply(this, arguments);
      }

      return queryAndCache;
    }()
  }, {
    key: "_tick",
    value: function _tick(ms) {
      var _this2 = this;

      var nextRemovalTime = this._nextRemovalTime;

      if (!nextRemovalTime || ms < nextRemovalTime) {
        clearTimeout(this._removalTimeout);
        this._nextRemovalTime = ms;
        this._removalTimeout = setTimeout(function () {
          _this2._nextRemovalTime = false;
          var nextExpiry = Infinity;
          var now = Date.now();

          var _iterator5 = _createForOfIteratorHelper$g(_this2._cache),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  hostname = _step5$value[0],
                  entries = _step5$value[1];

              var expires = entries[kExpires];

              if (now >= expires) {
                _this2._cache.delete(hostname);
              } else if (expires < nextExpiry) {
                nextExpiry = expires;
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          if (nextExpiry !== Infinity) {
            _this2._tick(nextExpiry - now);
          }
        }, ms);
        /* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */

        if (this._removalTimeout.unref) {
          this._removalTimeout.unref();
        }
      }
    }
  }, {
    key: "install",
    value: function install(agent) {
      var _this3 = this;

      verifyAgent(agent);

      if (kCacheableLookupCreateConnection in agent) {
        throw new Error('CacheableLookup has been already installed');
      }

      agent[kCacheableLookupCreateConnection] = agent.createConnection;
      agent[kCacheableLookupInstance] = this;

      agent.createConnection = function (options, callback) {
        if (!('lookup' in options)) {
          options.lookup = _this3.lookup;
        }

        return agent[kCacheableLookupCreateConnection](options, callback);
      };
    }
  }, {
    key: "uninstall",
    value: function uninstall(agent) {
      verifyAgent(agent);

      if (agent[kCacheableLookupCreateConnection]) {
        if (agent[kCacheableLookupInstance] !== this) {
          throw new Error('The agent is not owned by this CacheableLookup instance');
        }

        agent.createConnection = agent[kCacheableLookupCreateConnection];
        delete agent[kCacheableLookupCreateConnection];
        delete agent[kCacheableLookupInstance];
      }
    }
  }, {
    key: "updateInterfaceInfo",
    value: function updateInterfaceInfo() {
      var _iface = this._iface;
      this._iface = getIfaceInfo();

      if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
        this._cache.clear();
      }
    }
  }, {
    key: "clear",
    value: function clear(hostname) {
      if (hostname) {
        this._cache.delete(hostname);

        return;
      }

      this._cache.clear();
    }
  }]);

  return CacheableLookup;
}();

var source$2 = CacheableLookup;
var _default$h = CacheableLookup;
source$2.default = _default$h;

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$i(arr) || _nonIterableRest();
}

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _wrapRegExp$1() { _wrapRegExp$1 = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); _groups.set(_this, groups || _groups.get(re)); return _setPrototypeOf(_this, BabelRegExp.prototype); } _inherits(BabelRegExp, RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; if (_typeof(args[args.length - 1]) !== "object") { args = [].slice.call(args); args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp$1.apply(this, arguments); }

var DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
var DATA_URL_DEFAULT_CHARSET = 'us-ascii';

var testParameter = function testParameter(name, filters) {
  return filters.some(function (filter) {
    return filter instanceof RegExp ? filter.test(name) : filter === name;
  });
};

var normalizeDataURL = function normalizeDataURL(urlString, _ref) {
  var stripHash = _ref.stripHash;

  var match = /*#__PURE__*/_wrapRegExp$1(/^data:((?:(?!,)[\s\S])*?),((?:(?!#)[\s\S])*?)(?:#(.*))?$/, {
    type: 1,
    data: 2,
    hash: 3
  }).exec(urlString);

  if (!match) {
    throw new Error("Invalid URL: ".concat(urlString));
  }

  var _match$groups = match.groups,
      type = _match$groups.type,
      data = _match$groups.data,
      hash = _match$groups.hash;
  var mediaType = type.split(';');
  hash = stripHash ? '' : hash;
  var isBase64 = false;

  if (mediaType[mediaType.length - 1] === 'base64') {
    mediaType.pop();
    isBase64 = true;
  } // Lowercase MIME type


  var mimeType = (mediaType.shift() || '').toLowerCase();
  var attributes = mediaType.map(function (attribute) {
    var _attribute$split$map = attribute.split('=').map(function (string) {
      return string.trim();
    }),
        _attribute$split$map2 = _slicedToArray(_attribute$split$map, 2),
        key = _attribute$split$map2[0],
        _attribute$split$map3 = _attribute$split$map2[1],
        value = _attribute$split$map3 === void 0 ? '' : _attribute$split$map3; // Lowercase `charset`


    if (key === 'charset') {
      value = value.toLowerCase();

      if (value === DATA_URL_DEFAULT_CHARSET) {
        return '';
      }
    }

    return "".concat(key).concat(value ? "=".concat(value) : '');
  }).filter(Boolean);

  var normalizedMediaType = _toConsumableArray(attributes);

  if (isBase64) {
    normalizedMediaType.push('base64');
  }

  if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }

  return "data:".concat(normalizedMediaType.join(';'), ",").concat(isBase64 ? data.trim() : data).concat(hash ? "#".concat(hash) : '');
};

var normalizeUrl = function normalizeUrl(urlString, options) {
  options = _objectSpread$b({
    defaultProtocol: 'http:',
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    sortQueryParameters: true
  }, options);
  urlString = urlString.trim(); // Data URL

  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }

  if (/^view-source:/i.test(urlString)) {
    throw new Error('`view-source:` is not supported as it is a non-standard protocol');
  }

  var hasRelativeProtocol = urlString.startsWith('//');
  var isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString); // Prepend protocol

  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }

  var urlObj = new URL(urlString);

  if (options.forceHttp && options.forceHttps) {
    throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
  }

  if (options.forceHttp && urlObj.protocol === 'https:') {
    urlObj.protocol = 'http:';
  }

  if (options.forceHttps && urlObj.protocol === 'http:') {
    urlObj.protocol = 'https:';
  } // Remove auth


  if (options.stripAuthentication) {
    urlObj.username = '';
    urlObj.password = '';
  } // Remove hash


  if (options.stripHash) {
    urlObj.hash = '';
  } else if (options.stripTextFragment) {
    urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, '');
  } // Remove duplicate slashes if not preceded by a protocol


  if (urlObj.pathname) {
    urlObj.pathname = urlObj.pathname.replace(/(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g, '/');
  } // Decode URI octets


  if (urlObj.pathname) {
    try {
      urlObj.pathname = decodeURI(urlObj.pathname);
    } catch (_) {}
  } // Remove directory index


  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }

  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    var pathComponents = urlObj.pathname.split('/');
    var lastComponent = pathComponents[pathComponents.length - 1];

    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, pathComponents.length - 1);
      urlObj.pathname = pathComponents.slice(1).join('/') + '/';
    }
  }

  if (urlObj.hostname) {
    // Remove trailing dot
    urlObj.hostname = urlObj.hostname.replace(/\.$/, ''); // Remove `www.`

    if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
      // Each label should be max 63 at length (min: 1).
      // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
      // Each TLD should be up to 63 characters long (min: 2).
      // It is technically possible to have a single character TLD, but none currently exist.
      urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
    }
  } // Remove query unwanted parameters


  if (Array.isArray(options.removeQueryParameters)) {
    for (var _i = 0, _arr = _toConsumableArray(urlObj.searchParams.keys()); _i < _arr.length; _i++) {
      var key = _arr[_i];

      if (testParameter(key, options.removeQueryParameters)) {
        urlObj.searchParams.delete(key);
      }
    }
  } // Sort query parameters


  if (options.sortQueryParameters) {
    urlObj.searchParams.sort();
  }

  if (options.removeTrailingSlash) {
    urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
  }

  var oldUrlString = urlString; // Take advantage of many of the Node `url` normalizations

  urlString = urlObj.toString();

  if (!options.removeSingleSlash && urlObj.pathname === '/' && !oldUrlString.endsWith('/') && urlObj.hash === '') {
    urlString = urlString.replace(/\/$/, '');
  } // Remove ending `/` unless removeSingleSlash is false


  if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '' && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, '');
  } // Restore relative protocol, if applicable


  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, '//');
  } // Remove http/https


  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, '');
  }

  return urlString;
};

var normalizeUrl_1 = normalizeUrl;

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy;

function wrappy(fn, cb) {
  if (fn && cb) return wrappy(fn)(cb);
  if (typeof fn !== 'function') throw new TypeError('need wrapper function');
  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });
  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];

    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }

    return ret;
  }
}

var once_1 = wrappy_1(once);
var strict = wrappy_1(onceStrict);
once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function value() {
      return once(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function value() {
      return onceStrict(this);
    },
    configurable: true
  });
});

function once(fn) {
  var f = function f() {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  f.called = false;
  return f;
}

function onceStrict(fn) {
  var f = function f() {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
once_1.strict = strict;

var noop$2 = function noop() {};

var isRequest$1 = function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function isChildProcess(stream) {
  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};

var eos = function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once_1(callback || noop$2);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var cancelled = false;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var onfinish = function onfinish() {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function onend() {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onexit = function onexit(exitCode) {
    callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    process.nextTick(onclosenexttick);
  };

  var onclosenexttick = function onclosenexttick() {
    if (cancelled) return;
    if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
    if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest$1(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  if (isChildProcess(stream)) stream.on('exit', onexit);
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    cancelled = true;
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
};

var endOfStream = eos;

var noop$1 = function noop() {};

var ancient = /^v?\.0/.test(process.version);

var isFn = function isFn(fn) {
  return typeof fn === 'function';
};

var isFS = function isFS(stream) {
  if (!ancient) return false; // newer node version do not need to care about fs is a special way

  if (!fs) return false; // browser

  return (stream instanceof (fs.ReadStream || noop$1) || stream instanceof (fs.WriteStream || noop$1)) && isFn(stream.close);
};

var isRequest = function isRequest(stream) {
  return stream.setHeader && isFn(stream.abort);
};

var destroyer = function destroyer(stream, reading, writing, callback) {
  callback = once_1(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  endOfStream(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isFS(stream)) return stream.close(noop$1); // use close for fs streams to avoid fd leaks

    if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy();
    callback(err || new Error('stream was destroyed'));
  };
};

var call = function call(fn) {
  fn();
};

var pipe = function pipe(from, to) {
  return from.pipe(to);
};

var pump = function pump() {
  var streams = Array.prototype.slice.call(arguments);
  var callback = isFn(streams[streams.length - 1] || noop$1) && streams.pop() || noop$1;
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) throw new Error('pump requires two streams per minimum');
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
};

var pump_1 = pump;

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var PassThroughStream = require$$0$4.PassThrough;

var bufferStream = function bufferStream(options) {
  options = _objectSpread$a({}, options);
  var _options = options,
      array = _options.array;
  var _options2 = options,
      encoding = _options2.encoding;
  var isBuffer = encoding === 'buffer';
  var objectMode = false;

  if (array) {
    objectMode = !(encoding || isBuffer);
  } else {
    encoding = encoding || 'utf8';
  }

  if (isBuffer) {
    encoding = null;
  }

  var stream = new PassThroughStream({
    objectMode: objectMode
  });

  if (encoding) {
    stream.setEncoding(encoding);
  }

  var length = 0;
  var chunks = [];
  stream.on('data', function (chunk) {
    chunks.push(chunk);

    if (objectMode) {
      length = chunks.length;
    } else {
      length += chunk.length;
    }
  });

  stream.getBufferedValue = function () {
    if (array) {
      return chunks;
    }

    return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
  };

  stream.getBufferedLength = function () {
    return length;
  };

  return stream;
};

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BufferConstants = require$$0$5.constants;

var MaxBufferError = /*#__PURE__*/function (_Error) {
  _inherits(MaxBufferError, _Error);

  var _super = _createSuper$b(MaxBufferError);

  function MaxBufferError() {
    var _this;

    _classCallCheck(this, MaxBufferError);

    _this = _super.call(this, 'maxBuffer exceeded');
    _this.name = 'MaxBufferError';
    return _this;
  }

  return MaxBufferError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function getStream(_x, _x2) {
  return _getStream.apply(this, arguments);
}

function _getStream() {
  _getStream = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(inputStream, options) {
    var _options, maxBuffer, stream;

    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (inputStream) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", Promise.reject(new Error('Expected a stream')));

          case 2:
            options = _objectSpread$9({
              maxBuffer: Infinity
            }, options);
            _options = options, maxBuffer = _options.maxBuffer;
            _context.next = 6;
            return new Promise(function (resolve, reject) {
              var rejectPromise = function rejectPromise(error) {
                // Don't retrieve an oversized buffer.
                if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
                  error.bufferedData = stream.getBufferedValue();
                }

                reject(error);
              };

              stream = pump_1(inputStream, bufferStream(options), function (error) {
                if (error) {
                  rejectPromise(error);
                  return;
                }

                resolve();
              });
              stream.on('data', function () {
                if (stream.getBufferedLength() > maxBuffer) {
                  rejectPromise(new MaxBufferError());
                }
              });
            });

          case 6:
            return _context.abrupt("return", stream.getBufferedValue());

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getStream.apply(this, arguments);
}

var getStream_1 = getStream; // TODO: Remove this for the next major release

var _default$g = getStream;

var buffer = function buffer(stream, options) {
  return getStream(stream, _objectSpread$9(_objectSpread$9({}, options), {}, {
    encoding: 'buffer'
  }));
};

var array = function array(stream, options) {
  return getStream(stream, _objectSpread$9(_objectSpread$9({}, options), {}, {
    array: true
  }));
};

var MaxBufferError_1 = MaxBufferError;
getStream_1.default = _default$g;
getStream_1.buffer = buffer;
getStream_1.array = array;
getStream_1.MaxBufferError = MaxBufferError_1;

function _createForOfIteratorHelper$f(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$f(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$f(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$f(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen); }

function _arrayLikeToArray$f(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var statusCodeCacheableByDefault = new Set([200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501]); // This implementation does not understand partial responses (206)

var understoodStatuses = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]);
var errorStatusCodes = new Set([500, 502, 503, 504]);
var hopByHopHeaders = {
  date: true,
  // included, because we add Age update Date
  connection: true,
  'keep-alive': true,
  'proxy-authenticate': true,
  'proxy-authorization': true,
  te: true,
  trailer: true,
  'transfer-encoding': true,
  upgrade: true
};
var excludedFromRevalidationUpdate = {
  // Since the old body is reused, it doesn't make sense to change properties of the body
  'content-length': true,
  'content-encoding': true,
  'transfer-encoding': true,
  'content-range': true
};

function toNumberOrZero(s) {
  var n = parseInt(s, 10);
  return isFinite(n) ? n : 0;
} // RFC 5861


function isErrorResponse(response) {
  // consider undefined response as faulty
  if (!response) {
    return true;
  }

  return errorStatusCodes.has(response.status);
}

function parseCacheControl(header) {
  var cc = {};
  if (!header) return cc; // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
  // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale

  var parts = header.trim().split(/\s*,\s*/); // TODO: lame parsing

  var _iterator = _createForOfIteratorHelper$f(parts),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var part = _step.value;

      var _part$split = part.split(/\s*=\s*/, 2),
          _part$split2 = _slicedToArray(_part$split, 2),
          k = _part$split2[0],
          v = _part$split2[1];

      cc[k] = v === undefined ? true : v.replace(/^"|"$/g, ''); // TODO: lame unquoting
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return cc;
}

function formatCacheControl(cc) {
  var parts = [];

  for (var k in cc) {
    var v = cc[k];
    parts.push(v === true ? k : k + '=' + v);
  }

  if (!parts.length) {
    return undefined;
  }

  return parts.join(', ');
}

var httpCacheSemantics = /*#__PURE__*/function () {
  function CachePolicy(req, res) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        shared = _ref.shared,
        cacheHeuristic = _ref.cacheHeuristic,
        immutableMinTimeToLive = _ref.immutableMinTimeToLive,
        ignoreCargoCult = _ref.ignoreCargoCult,
        _fromObject = _ref._fromObject;

    _classCallCheck(this, CachePolicy);

    if (_fromObject) {
      this._fromObject(_fromObject);

      return;
    }

    if (!res || !res.headers) {
      throw Error('Response headers missing');
    }

    this._assertRequestHasHeaders(req);

    this._responseTime = this.now();
    this._isShared = shared !== false;
    this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE

    this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;
    this._status = 'status' in res ? res.status : 200;
    this._resHeaders = res.headers;
    this._rescc = parseCacheControl(res.headers['cache-control']);
    this._method = 'method' in req ? req.method : 'GET';
    this._url = req.url;
    this._host = req.headers.host;
    this._noAuthorization = !req.headers.authorization;
    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used

    this._reqcc = parseCacheControl(req.headers['cache-control']); // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
    // so there's no point stricly adhering to the blindly copy&pasted directives.

    if (ignoreCargoCult && 'pre-check' in this._rescc && 'post-check' in this._rescc) {
      delete this._rescc['pre-check'];
      delete this._rescc['post-check'];
      delete this._rescc['no-cache'];
      delete this._rescc['no-store'];
      delete this._rescc['must-revalidate'];
      this._resHeaders = Object.assign({}, this._resHeaders, {
        'cache-control': formatCacheControl(this._rescc)
      });
      delete this._resHeaders.expires;
      delete this._resHeaders.pragma;
    } // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
    // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).


    if (res.headers['cache-control'] == null && /no-cache/.test(res.headers.pragma)) {
      this._rescc['no-cache'] = true;
    }
  }

  _createClass(CachePolicy, [{
    key: "now",
    value: function now() {
      return Date.now();
    }
  }, {
    key: "storable",
    value: function storable() {
      // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
      return !!(!this._reqcc['no-store'] && ( // A cache MUST NOT store a response to any request, unless:
      // The request method is understood by the cache and defined as being cacheable, and
      'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
      understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
      !this._rescc['no-store'] && ( // the "private" response directive does not appear in the response, if the cache is shared, and
      !this._isShared || !this._rescc.private) && ( // the Authorization header field does not appear in the request, if the cache is shared,
      !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && ( // the response either:
      // contains an Expires header field, or
      this._resHeaders.expires || // contains a max-age response directive, or
      // contains a s-maxage response directive and the cache is shared, or
      // contains a public response directive.
      this._rescc['max-age'] || this._isShared && this._rescc['s-maxage'] || this._rescc.public || // has a status code that is defined as cacheable by default
      statusCodeCacheableByDefault.has(this._status)));
    }
  }, {
    key: "_hasExplicitExpiration",
    value: function _hasExplicitExpiration() {
      // 4.2.1 Calculating Freshness Lifetime
      return this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires;
    }
  }, {
    key: "_assertRequestHasHeaders",
    value: function _assertRequestHasHeaders(req) {
      if (!req || !req.headers) {
        throw Error('Request headers missing');
      }
    }
  }, {
    key: "satisfiesWithoutRevalidation",
    value: function satisfiesWithoutRevalidation(req) {
      this._assertRequestHasHeaders(req); // When presented with a request, a cache MUST NOT reuse a stored response, unless:
      // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
      // unless the stored response is successfully validated (Section 4.3), and


      var requestCC = parseCacheControl(req.headers['cache-control']);

      if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {
        return false;
      }

      if (requestCC['max-age'] && this.age() > requestCC['max-age']) {
        return false;
      }

      if (requestCC['min-fresh'] && this.timeToLive() < 1000 * requestCC['min-fresh']) {
        return false;
      } // the stored response is either:
      // fresh, or allowed to be served stale


      if (this.stale()) {
        var allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());

        if (!allowsStale) {
          return false;
        }
      }

      return this._requestMatches(req, false);
    }
  }, {
    key: "_requestMatches",
    value: function _requestMatches(req, allowHeadMethod) {
      // The presented effective request URI and that of the stored response match, and
      return (!this._url || this._url === req.url) && this._host === req.headers.host && ( // the request method associated with the stored response allows it to be used for the presented request, and
      !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
      this._varyMatches(req);
    }
  }, {
    key: "_allowsStoringAuthenticated",
    value: function _allowsStoringAuthenticated() {
      //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
      return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];
    }
  }, {
    key: "_varyMatches",
    value: function _varyMatches(req) {
      if (!this._resHeaders.vary) {
        return true;
      } // A Vary header field-value of "*" always fails to match


      if (this._resHeaders.vary === '*') {
        return false;
      }

      var fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);

      var _iterator2 = _createForOfIteratorHelper$f(fields),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var name = _step2.value;
          if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return true;
    }
  }, {
    key: "_copyWithoutHopByHopHeaders",
    value: function _copyWithoutHopByHopHeaders(inHeaders) {
      var headers = {};

      for (var name in inHeaders) {
        if (hopByHopHeaders[name]) continue;
        headers[name] = inHeaders[name];
      } // 9.1.  Connection


      if (inHeaders.connection) {
        var tokens = inHeaders.connection.trim().split(/\s*,\s*/);

        var _iterator3 = _createForOfIteratorHelper$f(tokens),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _name = _step3.value;
            delete headers[_name];
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      if (headers.warning) {
        var warnings = headers.warning.split(/,/).filter(function (warning) {
          return !/^\s*1[0-9][0-9]/.test(warning);
        });

        if (!warnings.length) {
          delete headers.warning;
        } else {
          headers.warning = warnings.join(',').trim();
        }
      }

      return headers;
    }
  }, {
    key: "responseHeaders",
    value: function responseHeaders() {
      var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);

      var age = this.age(); // A cache SHOULD generate 113 warning if it heuristically chose a freshness
      // lifetime greater than 24 hours and the response's age is greater than 24 hours.

      if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
        headers.warning = (headers.warning ? "".concat(headers.warning, ", ") : '') + '113 - "rfc7234 5.5.4"';
      }

      headers.age = "".concat(Math.round(age));
      headers.date = new Date(this.now()).toUTCString();
      return headers;
    }
    /**
     * Value of the Date response header or current time if Date was invalid
     * @return timestamp
     */

  }, {
    key: "date",
    value: function date() {
      var serverDate = Date.parse(this._resHeaders.date);

      if (isFinite(serverDate)) {
        return serverDate;
      }

      return this._responseTime;
    }
    /**
     * Value of the Age header, in seconds, updated for the current time.
     * May be fractional.
     *
     * @return Number
     */

  }, {
    key: "age",
    value: function age() {
      var age = this._ageValue();

      var residentTime = (this.now() - this._responseTime) / 1000;
      return age + residentTime;
    }
  }, {
    key: "_ageValue",
    value: function _ageValue() {
      return toNumberOrZero(this._resHeaders.age);
    }
    /**
     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
     *
     * For an up-to-date value, see `timeToLive()`.
     *
     * @return Number
     */

  }, {
    key: "maxAge",
    value: function maxAge() {
      if (!this.storable() || this._rescc['no-cache']) {
        return 0;
      } // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
      // so this implementation requires explicit opt-in via public header


      if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {
        return 0;
      }

      if (this._resHeaders.vary === '*') {
        return 0;
      }

      if (this._isShared) {
        if (this._rescc['proxy-revalidate']) {
          return 0;
        } // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.


        if (this._rescc['s-maxage']) {
          return toNumberOrZero(this._rescc['s-maxage']);
        }
      } // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.


      if (this._rescc['max-age']) {
        return toNumberOrZero(this._rescc['max-age']);
      }

      var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
      var serverDate = this.date();

      if (this._resHeaders.expires) {
        var expires = Date.parse(this._resHeaders.expires); // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").

        if (Number.isNaN(expires) || expires < serverDate) {
          return 0;
        }

        return Math.max(defaultMinTtl, (expires - serverDate) / 1000);
      }

      if (this._resHeaders['last-modified']) {
        var lastModified = Date.parse(this._resHeaders['last-modified']);

        if (isFinite(lastModified) && serverDate > lastModified) {
          return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);
        }
      }

      return defaultMinTtl;
    }
  }, {
    key: "timeToLive",
    value: function timeToLive() {
      var age = this.maxAge() - this.age();
      var staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);
      var staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);
      return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;
    }
  }, {
    key: "stale",
    value: function stale() {
      return this.maxAge() <= this.age();
    }
  }, {
    key: "_useStaleIfError",
    value: function _useStaleIfError() {
      return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();
    }
  }, {
    key: "useStaleWhileRevalidate",
    value: function useStaleWhileRevalidate() {
      return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();
    }
  }, {
    key: "_fromObject",
    value: function _fromObject(obj) {
      if (this._responseTime) throw Error('Reinitialized');
      if (!obj || obj.v !== 1) throw Error('Invalid serialization');
      this._responseTime = obj.t;
      this._isShared = obj.sh;
      this._cacheHeuristic = obj.ch;
      this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
      this._status = obj.st;
      this._resHeaders = obj.resh;
      this._rescc = obj.rescc;
      this._method = obj.m;
      this._url = obj.u;
      this._host = obj.h;
      this._noAuthorization = obj.a;
      this._reqHeaders = obj.reqh;
      this._reqcc = obj.reqcc;
    }
  }, {
    key: "toObject",
    value: function toObject() {
      return {
        v: 1,
        t: this._responseTime,
        sh: this._isShared,
        ch: this._cacheHeuristic,
        imm: this._immutableMinTtl,
        st: this._status,
        resh: this._resHeaders,
        rescc: this._rescc,
        m: this._method,
        u: this._url,
        h: this._host,
        a: this._noAuthorization,
        reqh: this._reqHeaders,
        reqcc: this._reqcc
      };
    }
    /**
     * Headers for sending to the origin server to revalidate stale response.
     * Allows server to return 304 to allow reuse of the previous response.
     *
     * Hop by hop headers are always stripped.
     * Revalidation headers may be added or removed, depending on request.
     */

  }, {
    key: "revalidationHeaders",
    value: function revalidationHeaders(incomingReq) {
      this._assertRequestHasHeaders(incomingReq);

      var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers); // This implementation does not understand range requests


      delete headers['if-range'];

      if (!this._requestMatches(incomingReq, true) || !this.storable()) {
        // revalidation allowed via HEAD
        // not for the same resource, or wasn't allowed to be cached anyway
        delete headers['if-none-match'];
        delete headers['if-modified-since'];
        return headers;
      }
      /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */


      if (this._resHeaders.etag) {
        headers['if-none-match'] = headers['if-none-match'] ? "".concat(headers['if-none-match'], ", ").concat(this._resHeaders.etag) : this._resHeaders.etag;
      } // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.


      var forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';
      /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
      Note: This implementation does not understand partial responses (206) */

      if (forbidsWeakValidators) {
        delete headers['if-modified-since'];

        if (headers['if-none-match']) {
          var etags = headers['if-none-match'].split(/,/).filter(function (etag) {
            return !/^\s*W\//.test(etag);
          });

          if (!etags.length) {
            delete headers['if-none-match'];
          } else {
            headers['if-none-match'] = etags.join(',').trim();
          }
        }
      } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {
        headers['if-modified-since'] = this._resHeaders['last-modified'];
      }

      return headers;
    }
    /**
     * Creates new CachePolicy with information combined from the previews response,
     * and the new revalidation response.
     *
     * Returns {policy, modified} where modified is a boolean indicating
     * whether the response body has been modified, and old cached body can't be used.
     *
     * @return {Object} {policy: CachePolicy, modified: Boolean}
     */

  }, {
    key: "revalidatedPolicy",
    value: function revalidatedPolicy(request, response) {
      this._assertRequestHasHeaders(request);

      if (this._useStaleIfError() && isErrorResponse(response)) {
        // I consider the revalidation request unsuccessful
        return {
          modified: false,
          matches: false,
          policy: this
        };
      }

      if (!response || !response.headers) {
        throw Error('Response headers missing');
      } // These aren't going to be supported exactly, since one CachePolicy object
      // doesn't know about all the other cached objects.


      var matches = false;

      if (response.status !== undefined && response.status != 304) {
        matches = false;
      } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
        // "All of the stored responses with the same strong validator are selected.
        // If none of the stored responses contain the same strong validator,
        // then the cache MUST NOT use the new response to update any stored responses."
        matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, '') === response.headers.etag;
      } else if (this._resHeaders.etag && response.headers.etag) {
        // "If the new response contains a weak validator and that validator corresponds
        // to one of the cache's stored responses,
        // then the most recent of those matching stored responses is selected for update."
        matches = this._resHeaders.etag.replace(/^\s*W\//, '') === response.headers.etag.replace(/^\s*W\//, '');
      } else if (this._resHeaders['last-modified']) {
        matches = this._resHeaders['last-modified'] === response.headers['last-modified'];
      } else {
        // If the new response does not include any form of validator (such as in the case where
        // a client generates an If-Modified-Since request from a source other than the Last-Modified
        // response header field), and there is only one stored response, and that stored response also
        // lacks a validator, then that stored response is selected for update.
        if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {
          matches = true;
        }
      }

      if (!matches) {
        return {
          policy: new this.constructor(request, response),
          // Client receiving 304 without body, even if it's invalid/mismatched has no option
          // but to reuse a cached body. We don't have a good way to tell clients to do
          // error recovery in such case.
          modified: response.status != 304,
          matches: false
        };
      } // use other header fields provided in the 304 (Not Modified) response to replace all instances
      // of the corresponding header fields in the stored response.


      var headers = {};

      for (var k in this._resHeaders) {
        headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
      }

      var newResponse = Object.assign({}, response, {
        status: this._status,
        method: this._method,
        headers: headers
      });
      return {
        policy: new this.constructor(request, newResponse, {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl
        }),
        modified: false,
        matches: true
      };
    }
  }], [{
    key: "fromObject",
    value: function fromObject(obj) {
      return new this(undefined, undefined, {
        _fromObject: obj
      });
    }
  }]);

  return CachePolicy;
}();

var lowercaseKeys = function lowercaseKeys(object) {
  var result = {};

  for (var _i = 0, _Object$entries = Object.entries(object); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    result[key.toLowerCase()] = value;
  }

  return result;
};

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Readable$1 = require$$0$4.Readable;

var Response = /*#__PURE__*/function (_Readable) {
  _inherits(Response, _Readable);

  var _super = _createSuper$a(Response);

  function Response(statusCode, headers, body, url) {
    var _this;

    _classCallCheck(this, Response);

    if (typeof statusCode !== 'number') {
      throw new TypeError('Argument `statusCode` should be a number');
    }

    if (_typeof(headers) !== 'object') {
      throw new TypeError('Argument `headers` should be an object');
    }

    if (!(body instanceof Buffer)) {
      throw new TypeError('Argument `body` should be a buffer');
    }

    if (typeof url !== 'string') {
      throw new TypeError('Argument `url` should be a string');
    }

    _this = _super.call(this);
    _this.statusCode = statusCode;
    _this.headers = lowercaseKeys(headers);
    _this.body = body;
    _this.url = url;
    return _this;
  }

  _createClass(Response, [{
    key: "_read",
    value: function _read() {
      this.push(this.body);
      this.push(null);
    }
  }]);

  return Response;
}(Readable$1);

var src$3 = Response;

// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage

function _createForOfIteratorHelper$e(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$e(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$e(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen); }

function _arrayLikeToArray$e(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var knownProps = ['destroy', 'setTimeout', 'socket', 'headers', 'trailers', 'rawHeaders', 'statusCode', 'httpVersion', 'httpVersionMinor', 'httpVersionMajor', 'rawTrailers', 'statusMessage'];

var mimicResponse$1 = function mimicResponse(fromStream, toStream) {
  var fromProps = new Set(Object.keys(fromStream).concat(knownProps));

  var _iterator = _createForOfIteratorHelper$e(fromProps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var prop = _step.value;

      // Don't overwrite existing properties
      if (prop in toStream) {
        continue;
      }

      toStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};

var PassThrough$1 = require$$0$4.PassThrough;

var cloneResponse = function cloneResponse(response) {
  if (!(response && response.pipe)) {
    throw new TypeError('Parameter `response` must be a response stream.');
  }

  var clone = new PassThrough$1();
  mimicResponse$1(response, clone);
  return response.pipe(clone);
};

var src$2 = cloneResponse;

//TODO: handle reviver/dehydrate function like normal
//and handle indentation, like normal.
//if anyone needs this... please send pull request.
var stringify = function stringify(o) {
  if ('undefined' == typeof o) return o;
  if (o && Buffer.isBuffer(o)) return JSON.stringify(':base64:' + o.toString('base64'));
  if (o && o.toJSON) o = o.toJSON();

  if (o && 'object' === _typeof(o)) {
    var s = '';
    var array = Array.isArray(o);
    s = array ? '[' : '{';
    var first = true;

    for (var k in o) {
      var ignore = 'function' == typeof o[k] || !array && 'undefined' === typeof o[k];

      if (Object.hasOwnProperty.call(o, k) && !ignore) {
        if (!first) s += ',';
        first = false;

        if (array) {
          if (o[k] == undefined) s += 'null';else s += stringify(o[k]);
        } else if (o[k] !== void 0) {
          s += stringify(k) + ':' + stringify(o[k]);
        }
      }
    }

    s += array ? ']' : '}';
    return s;
  } else if ('string' === typeof o) {
    return JSON.stringify(/^:/.test(o) ? ':' + o : o);
  } else if ('undefined' === typeof o) {
    return 'null';
  } else return JSON.stringify(o);
};

var parse$1 = function parse(s) {
  return JSON.parse(s, function (key, value) {
    if ('string' === typeof value) {
      if (/^:base64:/.test(value)) return Buffer.from(value.substring(8), 'base64');else return /^:/.test(value) ? value.substring(1) : value;
    }

    return value;
  });
};

var jsonBuffer = {
  stringify: stringify,
  parse: parse$1
};

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var loadStore = function loadStore(opts) {
  var adapters = {
    redis: '@keyv/redis',
    mongodb: '@keyv/mongo',
    mongo: '@keyv/mongo',
    sqlite: '@keyv/sqlite',
    postgresql: '@keyv/postgres',
    postgres: '@keyv/postgres',
    mysql: '@keyv/mysql'
  };

  if (opts.adapter || opts.uri) {
    var adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
    return new (commonjsRequire(adapters[adapter]))(opts);
  }

  return new Map();
};

var Keyv = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Keyv, _EventEmitter);

  var _super = _createSuper$9(Keyv);

  function Keyv(uri, opts) {
    var _this;

    _classCallCheck(this, Keyv);

    _this = _super.call(this);
    _this.opts = Object.assign({
      namespace: 'keyv',
      serialize: jsonBuffer.stringify,
      deserialize: jsonBuffer.parse
    }, typeof uri === 'string' ? {
      uri: uri
    } : uri, opts);

    if (!_this.opts.store) {
      var adapterOpts = Object.assign({}, _this.opts);
      _this.opts.store = loadStore(adapterOpts);
    }

    if (typeof _this.opts.store.on === 'function') {
      _this.opts.store.on('error', function (err) {
        return _this.emit('error', err);
      });
    }

    _this.opts.store.namespace = _this.opts.namespace;
    return _this;
  }

  _createClass(Keyv, [{
    key: "_getKeyPrefix",
    value: function _getKeyPrefix(key) {
      return "".concat(this.opts.namespace, ":").concat(key);
    }
  }, {
    key: "get",
    value: function get(key, opts) {
      var _this2 = this;

      var keyPrefixed = this._getKeyPrefix(key);

      var store = this.opts.store;
      return Promise.resolve().then(function () {
        return store.get(keyPrefixed);
      }).then(function (data) {
        return typeof data === 'string' ? _this2.opts.deserialize(data) : data;
      }).then(function (data) {
        if (data === undefined) {
          return undefined;
        }

        if (typeof data.expires === 'number' && Date.now() > data.expires) {
          _this2.delete(key);

          return undefined;
        }

        return opts && opts.raw ? data : data.value;
      });
    }
  }, {
    key: "set",
    value: function set(key, value, ttl) {
      var _this3 = this;

      var keyPrefixed = this._getKeyPrefix(key);

      if (typeof ttl === 'undefined') {
        ttl = this.opts.ttl;
      }

      if (ttl === 0) {
        ttl = undefined;
      }

      var store = this.opts.store;
      return Promise.resolve().then(function () {
        var expires = typeof ttl === 'number' ? Date.now() + ttl : null;
        value = {
          value: value,
          expires: expires
        };
        return _this3.opts.serialize(value);
      }).then(function (value) {
        return store.set(keyPrefixed, value, ttl);
      }).then(function () {
        return true;
      });
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var keyPrefixed = this._getKeyPrefix(key);

      var store = this.opts.store;
      return Promise.resolve().then(function () {
        return store.delete(keyPrefixed);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      var store = this.opts.store;
      return Promise.resolve().then(function () {
        return store.clear();
      });
    }
  }]);

  return Keyv;
}(EventEmitter);

var src$1 = Keyv;

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var CacheableRequest = /*#__PURE__*/function () {
  function CacheableRequest(request, cacheAdapter) {
    _classCallCheck(this, CacheableRequest);

    if (typeof request !== 'function') {
      throw new TypeError('Parameter `request` must be a function');
    }

    this.cache = new src$1({
      uri: typeof cacheAdapter === 'string' && cacheAdapter,
      store: typeof cacheAdapter !== 'string' && cacheAdapter,
      namespace: 'cacheable-request'
    });
    return this.createCacheableRequest(request);
  }

  _createClass(CacheableRequest, [{
    key: "createCacheableRequest",
    value: function createCacheableRequest(request) {
      var _this = this;

      return function (opts, cb) {
        var url;

        if (typeof opts === 'string') {
          url = normalizeUrlObject(url_1.parse(opts));
          opts = {};
        } else if (opts instanceof url_1.URL) {
          url = normalizeUrlObject(url_1.parse(opts.toString()));
          opts = {};
        } else {
          var _split = (opts.path || '').split('?'),
              _split2 = _toArray(_split),
              pathname = _split2[0],
              searchParts = _split2.slice(1);

          var search = searchParts.length > 0 ? "?".concat(searchParts.join('?')) : '';
          url = normalizeUrlObject(_objectSpread$8(_objectSpread$8({}, opts), {}, {
            pathname: pathname,
            search: search
          }));
        }

        opts = _objectSpread$8(_objectSpread$8({
          headers: {},
          method: 'GET',
          cache: true,
          strictTtl: false,
          automaticFailover: false
        }, opts), urlObjectToRequestOptions(url));
        opts.headers = lowercaseKeys(opts.headers);
        var ee = new EventEmitter();
        var normalizedUrlString = normalizeUrl_1(url_1.format(url), {
          stripWWW: false,
          removeTrailingSlash: false,
          stripAuthentication: false
        });
        var key = "".concat(opts.method, ":").concat(normalizedUrlString);
        var revalidate = false;
        var madeRequest = false;

        var makeRequest = function makeRequest(opts) {
          madeRequest = true;
          var requestErrored = false;
          var requestErrorCallback;
          var requestErrorPromise = new Promise(function (resolve) {
            requestErrorCallback = function requestErrorCallback() {
              if (!requestErrored) {
                requestErrored = true;
                resolve();
              }
            };
          });

          var handler = function handler(response) {
            if (revalidate && !opts.forceRefresh) {
              response.status = response.statusCode;
              var revalidatedPolicy = httpCacheSemantics.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);

              if (!revalidatedPolicy.modified) {
                var headers = revalidatedPolicy.policy.responseHeaders();
                response = new src$3(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                response.cachePolicy = revalidatedPolicy.policy;
                response.fromCache = true;
              }
            }

            if (!response.fromCache) {
              response.cachePolicy = new httpCacheSemantics(opts, response, opts);
              response.fromCache = false;
            }

            var clonedResponse;

            if (opts.cache && response.cachePolicy.storable()) {
              clonedResponse = src$2(response);

              _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
                var bodyPromise, body, value, ttl;
                return regenerator.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        bodyPromise = getStream_1.buffer(response);
                        _context.next = 4;
                        return Promise.race([requestErrorPromise, new Promise(function (resolve) {
                          return response.once('end', resolve);
                        })]);

                      case 4:
                        if (!requestErrored) {
                          _context.next = 6;
                          break;
                        }

                        return _context.abrupt("return");

                      case 6:
                        _context.next = 8;
                        return bodyPromise;

                      case 8:
                        body = _context.sent;
                        value = {
                          cachePolicy: response.cachePolicy.toObject(),
                          url: response.url,
                          statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                          body: body
                        };
                        ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;

                        if (opts.maxTtl) {
                          ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
                        }

                        _context.next = 14;
                        return _this.cache.set(key, value, ttl);

                      case 14:
                        _context.next = 19;
                        break;

                      case 16:
                        _context.prev = 16;
                        _context.t0 = _context["catch"](0);
                        ee.emit('error', new CacheableRequest.CacheError(_context.t0));

                      case 19:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, null, [[0, 16]]);
              }))();
            } else if (opts.cache && revalidate) {
              _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
                return regenerator.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.prev = 0;
                        _context2.next = 3;
                        return _this.cache.delete(key);

                      case 3:
                        _context2.next = 8;
                        break;

                      case 5:
                        _context2.prev = 5;
                        _context2.t0 = _context2["catch"](0);
                        ee.emit('error', new CacheableRequest.CacheError(_context2.t0));

                      case 8:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, null, [[0, 5]]);
              }))();
            }

            ee.emit('response', clonedResponse || response);

            if (typeof cb === 'function') {
              cb(clonedResponse || response);
            }
          };

          try {
            var req = request(opts, handler);
            req.once('error', requestErrorCallback);
            req.once('abort', requestErrorCallback);
            ee.emit('request', req);
          } catch (error) {
            ee.emit('error', new CacheableRequest.RequestError(error));
          }
        };

        _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var get, errorHandler;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  get = /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(opts) {
                      var cacheEntry, policy, headers, response;
                      return regenerator.wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              _context3.next = 2;
                              return Promise.resolve();

                            case 2:
                              if (!opts.cache) {
                                _context3.next = 8;
                                break;
                              }

                              _context3.next = 5;
                              return _this.cache.get(key);

                            case 5:
                              _context3.t0 = _context3.sent;
                              _context3.next = 9;
                              break;

                            case 8:
                              _context3.t0 = undefined;

                            case 9:
                              cacheEntry = _context3.t0;

                              if (!(typeof cacheEntry === 'undefined')) {
                                _context3.next = 12;
                                break;
                              }

                              return _context3.abrupt("return", makeRequest(opts));

                            case 12:
                              policy = httpCacheSemantics.fromObject(cacheEntry.cachePolicy);

                              if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {
                                headers = policy.responseHeaders();
                                response = new src$3(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                                response.cachePolicy = policy;
                                response.fromCache = true;
                                ee.emit('response', response);

                                if (typeof cb === 'function') {
                                  cb(response);
                                }
                              } else {
                                revalidate = cacheEntry;
                                opts.headers = policy.revalidationHeaders(opts);
                                makeRequest(opts);
                              }

                            case 14:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3);
                    }));

                    return function get(_x) {
                      return _ref4.apply(this, arguments);
                    };
                  }();

                  errorHandler = function errorHandler(error) {
                    return ee.emit('error', new CacheableRequest.CacheError(error));
                  };

                  _this.cache.once('error', errorHandler);

                  ee.on('response', function () {
                    return _this.cache.removeListener('error', errorHandler);
                  });
                  _context4.prev = 4;
                  _context4.next = 7;
                  return get(opts);

                case 7:
                  _context4.next = 13;
                  break;

                case 9:
                  _context4.prev = 9;
                  _context4.t0 = _context4["catch"](4);

                  if (opts.automaticFailover && !madeRequest) {
                    makeRequest(opts);
                  }

                  ee.emit('error', new CacheableRequest.CacheError(_context4.t0));

                case 13:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, null, [[4, 9]]);
        }))();

        return ee;
      };
    }
  }]);

  return CacheableRequest;
}();

function urlObjectToRequestOptions(url) {
  var options = _objectSpread$8({}, url);

  options.path = "".concat(url.pathname || '/').concat(url.search || '');
  delete options.pathname;
  delete options.search;
  return options;
}

function normalizeUrlObject(url) {
  // If url was parsed by url.parse or new URL:
  // - hostname will be set
  // - host will be hostname[:port]
  // - port will be set if it was explicit in the parsed string
  // Otherwise, url was from request options:
  // - hostname or host may be set
  // - host shall not have port encoded
  return {
    protocol: url.protocol,
    auth: url.auth,
    hostname: url.hostname || url.host || 'localhost',
    port: url.port,
    pathname: url.pathname,
    search: url.search
  };
}

CacheableRequest.RequestError = /*#__PURE__*/function (_Error) {
  _inherits(_class, _Error);

  var _super = _createSuper$8(_class);

  function _class(error) {
    var _this2;

    _classCallCheck(this, _class);

    _this2 = _super.call(this, error.message);
    _this2.name = 'RequestError';
    Object.assign(_assertThisInitialized(_this2), error);
    return _this2;
  }

  return _class;
}( /*#__PURE__*/_wrapNativeSuper(Error));

CacheableRequest.CacheError = /*#__PURE__*/function (_Error2) {
  _inherits(_class2, _Error2);

  var _super2 = _createSuper$8(_class2);

  function _class2(error) {
    var _this3;

    _classCallCheck(this, _class2);

    _this3 = _super2.call(this, error.message);
    _this3.name = 'CacheError';
    Object.assign(_assertThisInitialized(_this3), error);
    return _this3;
  }

  return _class2;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var src = CacheableRequest;

// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage

function _createForOfIteratorHelper$d(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$d(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$d(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$d(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen); }

function _arrayLikeToArray$d(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var knownProperties = ['aborted', 'complete', 'headers', 'httpVersion', 'httpVersionMinor', 'httpVersionMajor', 'method', 'rawHeaders', 'rawTrailers', 'setTimeout', 'socket', 'statusCode', 'statusMessage', 'trailers', 'url'];

var mimicResponse = function mimicResponse(fromStream, toStream) {
  if (toStream._readableState.autoDestroy) {
    throw new Error('The second stream must have the `autoDestroy` option set to `false`');
  }

  var fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
  var properties = {};

  var _iterator = _createForOfIteratorHelper$d(fromProperties),
      _step;

  try {
    var _loop = function _loop() {
      var property = _step.value;

      // Don't overwrite existing properties.
      if (property in toStream) {
        return "continue";
      }

      properties[property] = {
        get: function get() {
          var value = fromStream[property];
          var isFunction = typeof value === 'function';
          return isFunction ? value.bind(fromStream) : value;
        },
        set: function set(value) {
          fromStream[property] = value;
        },
        enumerable: true,
        configurable: false
      };
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  Object.defineProperties(toStream, properties);
  fromStream.once('aborted', function () {
    toStream.destroy();
    toStream.emit('aborted');
  });
  fromStream.once('close', function () {
    if (fromStream.complete) {
      if (toStream.readable) {
        toStream.once('end', function () {
          toStream.emit('close');
        });
      } else {
        toStream.emit('close');
      }
    } else {
      toStream.emit('close');
    }
  });
  return toStream;
};

var Transform = require$$0$4.Transform,
    PassThrough = require$$0$4.PassThrough;

var decompressResponse = function decompressResponse(response) {
  var contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();

  if (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {
    return response;
  } // TODO: Remove this when targeting Node.js 12.


  var isBrotli = contentEncoding === 'br';

  if (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {
    response.destroy(new Error('Brotli is not supported on Node.js < 12'));
    return response;
  }

  var isEmpty = true;
  var checker = new Transform({
    transform: function transform(data, _encoding, callback) {
      isEmpty = false;
      callback(null, data);
    },
    flush: function flush(callback) {
      callback();
    }
  });
  var finalStream = new PassThrough({
    autoDestroy: false,
    destroy: function destroy(error, callback) {
      response.destroy();
      callback(error);
    }
  });
  var decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
  decompressStream.once('error', function (error) {
    if (isEmpty && !response.readable) {
      finalStream.end();
      return;
    }

    finalStream.destroy(error);
  });
  mimicResponse(response, finalStream);
  response.pipe(checker).pipe(decompressStream).pipe(finalStream);
  return finalStream;
};

function _createForOfIteratorHelper$c(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$c(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$c(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$c(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen); }

function _arrayLikeToArray$c(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var QuickLRU = /*#__PURE__*/function () {
  function QuickLRU() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, QuickLRU);

    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError('`maxSize` must be a number greater than 0');
    }

    this.maxSize = options.maxSize;
    this.onEviction = options.onEviction;
    this.cache = new Map();
    this.oldCache = new Map();
    this._size = 0;
  }

  _createClass(QuickLRU, [{
    key: "_set",
    value: function _set(key, value) {
      this.cache.set(key, value);
      this._size++;

      if (this._size >= this.maxSize) {
        this._size = 0;

        if (typeof this.onEviction === 'function') {
          var _iterator = _createForOfIteratorHelper$c(this.oldCache.entries()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  _key = _step$value[0],
                  _value = _step$value[1];

              this.onEviction(_key, _value);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        this.oldCache = this.cache;
        this.cache = new Map();
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      if (this.cache.has(key)) {
        return this.cache.get(key);
      }

      if (this.oldCache.has(key)) {
        var value = this.oldCache.get(key);
        this.oldCache.delete(key);

        this._set(key, value);

        return value;
      }
    }
  }, {
    key: "set",
    value: function set(key, value) {
      if (this.cache.has(key)) {
        this.cache.set(key, value);
      } else {
        this._set(key, value);
      }

      return this;
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.cache.has(key) || this.oldCache.has(key);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      if (this.cache.has(key)) {
        return this.cache.get(key);
      }

      if (this.oldCache.has(key)) {
        return this.oldCache.get(key);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var deleted = this.cache.delete(key);

      if (deleted) {
        this._size--;
      }

      return this.oldCache.delete(key) || deleted;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cache.clear();
      this.oldCache.clear();
      this._size = 0;
    }
  }, {
    key: "keys",
    value: /*#__PURE__*/regenerator.mark(function keys() {
      var _iterator2, _step2, _step2$value, key;

      return regenerator.wrap(function keys$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper$c(this);
              _context.prev = 1;

              _iterator2.s();

            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context.next = 9;
                break;
              }

              _step2$value = _slicedToArray(_step2.value, 1), key = _step2$value[0];
              _context.next = 7;
              return key;

            case 7:
              _context.next = 3;
              break;

            case 9:
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _iterator2.e(_context.t0);

            case 14:
              _context.prev = 14;

              _iterator2.f();

              return _context.finish(14);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, keys, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: "values",
    value: /*#__PURE__*/regenerator.mark(function values() {
      var _iterator3, _step3, _step3$value, value;

      return regenerator.wrap(function values$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper$c(this);
              _context2.prev = 1;

              _iterator3.s();

            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context2.next = 9;
                break;
              }

              _step3$value = _slicedToArray(_step3.value, 2), value = _step3$value[1];
              _context2.next = 7;
              return value;

            case 7:
              _context2.next = 3;
              break;

            case 9:
              _context2.next = 14;
              break;

            case 11:
              _context2.prev = 11;
              _context2.t0 = _context2["catch"](1);

              _iterator3.e(_context2.t0);

            case 14:
              _context2.prev = 14;

              _iterator3.f();

              return _context2.finish(14);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, values, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/regenerator.mark(function value() {
      var _iterator4, _step4, item, _iterator5, _step5, _item, _item2, key;

      return regenerator.wrap(function value$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelper$c(this.cache);
              _context3.prev = 1;

              _iterator4.s();

            case 3:
              if ((_step4 = _iterator4.n()).done) {
                _context3.next = 9;
                break;
              }

              item = _step4.value;
              _context3.next = 7;
              return item;

            case 7:
              _context3.next = 3;
              break;

            case 9:
              _context3.next = 14;
              break;

            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](1);

              _iterator4.e(_context3.t0);

            case 14:
              _context3.prev = 14;

              _iterator4.f();

              return _context3.finish(14);

            case 17:
              _iterator5 = _createForOfIteratorHelper$c(this.oldCache);
              _context3.prev = 18;

              _iterator5.s();

            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context3.next = 28;
                break;
              }

              _item = _step5.value;
              _item2 = _slicedToArray(_item, 1), key = _item2[0];

              if (this.cache.has(key)) {
                _context3.next = 26;
                break;
              }

              _context3.next = 26;
              return _item;

            case 26:
              _context3.next = 20;
              break;

            case 28:
              _context3.next = 33;
              break;

            case 30:
              _context3.prev = 30;
              _context3.t1 = _context3["catch"](18);

              _iterator5.e(_context3.t1);

            case 33:
              _context3.prev = 33;

              _iterator5.f();

              return _context3.finish(33);

            case 36:
            case "end":
              return _context3.stop();
          }
        }
      }, value, this, [[1, 11, 14, 17], [18, 30, 33, 36]]);
    })
  }, {
    key: "size",
    get: function get() {
      var oldCacheSize = 0;

      var _iterator6 = _createForOfIteratorHelper$c(this.oldCache.keys()),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var key = _step6.value;

          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return Math.min(this._size + oldCacheSize, this.maxSize);
    }
  }]);

  return QuickLRU;
}();

var quickLru = QuickLRU;

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper$b(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }

function _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var kCurrentStreamsCount = Symbol('currentStreamsCount');
var kRequest = Symbol('request');
var kOriginSet = Symbol('cachedOriginSet');
var kGracefullyClosing = Symbol('gracefullyClosing');
var nameKeys = [// `http2.connect()` options
'maxDeflateDynamicTableSize', 'maxSessionMemory', 'maxHeaderListPairs', 'maxOutstandingPings', 'maxReservedRemoteStreams', 'maxSendHeaderBlockLength', 'paddingStrategy', // `tls.connect()` options
'localAddress', 'path', 'rejectUnauthorized', 'minDHSize', // `tls.createSecureContext()` options
'ca', 'cert', 'clientCertEngine', 'ciphers', 'key', 'pfx', 'servername', 'minVersion', 'maxVersion', 'secureProtocol', 'crl', 'honorCipherOrder', 'ecdhCurve', 'dhparam', 'secureOptions', 'sessionIdContext'];

var getSortedIndex = function getSortedIndex(array, value, compare) {
  var low = 0;
  var high = array.length;

  while (low < high) {
    var mid = low + high >>> 1;
    /* istanbul ignore next */

    if (compare(array[mid], value)) {
      // This never gets called because we use descending sort. Better to have this anyway.
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low;
};

var compareSessions = function compareSessions(a, b) {
  return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
}; // See https://tools.ietf.org/html/rfc8336


var closeCoveredSessions = function closeCoveredSessions(where, session) {
  // Clients SHOULD NOT emit new requests on any connection whose Origin
  // Set is a proper subset of another connection's Origin Set, and they
  // SHOULD close it once all outstanding requests are satisfied.
  var _iterator = _createForOfIteratorHelper$b(where),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var coveredSession = _step.value;

      if ( // The set is a proper subset when its length is less than the other set.
      coveredSession[kOriginSet].length < session[kOriginSet].length && // And the other set includes all elements of the subset.
      coveredSession[kOriginSet].every(function (origin) {
        return session[kOriginSet].includes(origin);
      }) && // Makes sure that the session can handle all requests from the covered session.
      coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
        // This allows pending requests to finish and prevents making new requests.
        gracefullyClose(coveredSession);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}; // This is basically inverted `closeCoveredSessions(...)`.


var closeSessionIfCovered = function closeSessionIfCovered(where, coveredSession) {
  var _iterator2 = _createForOfIteratorHelper$b(where),
      _step2;

  try {
    var _loop = function _loop() {
      var session = _step2.value;

      if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every(function (origin) {
        return session[kOriginSet].includes(origin);
      }) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
        gracefullyClose(coveredSession);
      }
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
};

var getSessions = function getSessions(_ref) {
  var agent = _ref.agent,
      isFree = _ref.isFree;
  var result = {}; // eslint-disable-next-line guard-for-in

  for (var normalizedOptions in agent.sessions) {
    var sessions = agent.sessions[normalizedOptions];
    var filtered = sessions.filter(function (session) {
      var result = session[Agent$1.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
      return isFree ? result : !result;
    });

    if (filtered.length !== 0) {
      result[normalizedOptions] = filtered;
    }
  }

  return result;
};

var gracefullyClose = function gracefullyClose(session) {
  session[kGracefullyClosing] = true;

  if (session[kCurrentStreamsCount] === 0) {
    session.close();
  }
};

var Agent$1 = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Agent, _EventEmitter);

  var _super = _createSuper$7(Agent);

  function Agent() {
    var _this;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timeout = _ref2.timeout,
        timeout = _ref2$timeout === void 0 ? 60000 : _ref2$timeout,
        _ref2$maxSessions = _ref2.maxSessions,
        maxSessions = _ref2$maxSessions === void 0 ? Infinity : _ref2$maxSessions,
        _ref2$maxFreeSessions = _ref2.maxFreeSessions,
        maxFreeSessions = _ref2$maxFreeSessions === void 0 ? 10 : _ref2$maxFreeSessions,
        _ref2$maxCachedTlsSes = _ref2.maxCachedTlsSessions,
        maxCachedTlsSessions = _ref2$maxCachedTlsSes === void 0 ? 100 : _ref2$maxCachedTlsSes;

    _classCallCheck(this, Agent);

    _this = _super.call(this); // A session is considered busy when its current streams count
    // is equal to or greater than the `maxConcurrentStreams` value.
    // A session is considered free when its current streams count
    // is less than the `maxConcurrentStreams` value.
    // SESSIONS[NORMALIZED_OPTIONS] = [];

    _this.sessions = {}; // The queue for creating new sessions. It looks like this:
    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
    //
    // The entry function has `listeners`, `completed` and `destroyed` properties.
    // `listeners` is an array of objects containing `resolve` and `reject` functions.
    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.

    _this.queue = {}; // Each session will use this timeout value.

    _this.timeout = timeout; // Max sessions in total

    _this.maxSessions = maxSessions; // Max free sessions in total
    // TODO: decreasing `maxFreeSessions` should close some sessions

    _this.maxFreeSessions = maxFreeSessions;
    _this._freeSessionsCount = 0;
    _this._sessionsCount = 0; // We don't support push streams by default.

    _this.settings = {
      enablePush: false
    }; // Reusing TLS sessions increases performance.

    _this.tlsSessionCache = new quickLru({
      maxSize: maxCachedTlsSessions
    });
    return _this;
  }

  _createClass(Agent, [{
    key: "normalizeOptions",
    value: function normalizeOptions(options) {
      var normalized = '';

      if (options) {
        var _iterator3 = _createForOfIteratorHelper$b(nameKeys),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var key = _step3.value;

            if (options[key]) {
              normalized += ":".concat(options[key]);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      return normalized;
    }
  }, {
    key: "_tryToCreateNewSession",
    value: function _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
      if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
        return;
      }

      var item = this.queue[normalizedOptions][normalizedOrigin]; // The entry function can be run only once.
      // BUG: The session may be never created when:
      // - the first condition is false AND
      // - this function is never called with the same arguments in the future.

      if (this._sessionsCount < this.maxSessions && !item.completed) {
        item.completed = true;
        item();
      }
    }
  }, {
    key: "getSession",
    value: function getSession(origin, options, listeners) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (Array.isArray(listeners)) {
          listeners = _toConsumableArray(listeners); // Resolve the current promise ASAP, we're just moving the listeners.
          // They will be executed at a different time.

          resolve();
        } else {
          listeners = [{
            resolve: resolve,
            reject: reject
          }];
        }

        var normalizedOptions = _this2.normalizeOptions(options);

        var normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);

        if (normalizedOrigin === undefined) {
          var _iterator4 = _createForOfIteratorHelper$b(listeners),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _reject = _step4.value.reject;

              _reject(new TypeError('The `origin` argument needs to be a string or an URL object'));
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          return;
        }

        if (normalizedOptions in _this2.sessions) {
          var sessions = _this2.sessions[normalizedOptions];
          var maxConcurrentStreams = -1;
          var currentStreamsCount = -1;
          var optimalSession; // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.
          // Additionally, we are looking for session which has biggest current pending streams count.

          var _iterator5 = _createForOfIteratorHelper$b(sessions),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var session = _step5.value;
              var sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;

              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }

              if (session[kOriginSet].includes(normalizedOrigin)) {
                var sessionCurrentStreamsCount = session[kCurrentStreamsCount];

                if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || // Unfortunately the `close` event isn't called immediately,
                // so `session.destroyed` is `true`, but `session.closed` is `false`.
                session.destroyed) {
                  continue;
                } // We only need set this once.


                if (!optimalSession) {
                  maxConcurrentStreams = sessionMaxConcurrentStreams;
                } // We're looking for the session which has biggest current pending stream count,
                // in order to minimalize the amount of active sessions.


                if (sessionCurrentStreamsCount > currentStreamsCount) {
                  optimalSession = session;
                  currentStreamsCount = sessionCurrentStreamsCount;
                }
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          if (optimalSession) {
            /* istanbul ignore next: safety check */
            if (listeners.length !== 1) {
              var _iterator6 = _createForOfIteratorHelper$b(listeners),
                  _step6;

              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var _reject2 = _step6.value.reject;
                  var error = new Error("Expected the length of listeners to be 1, got ".concat(listeners.length, ".\n") + 'Please report this to https://github.com/szmarczak/http2-wrapper/');

                  _reject2(error);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }

              return;
            }

            listeners[0].resolve(optimalSession);
            return;
          }
        }

        if (normalizedOptions in _this2.queue) {
          if (normalizedOrigin in _this2.queue[normalizedOptions]) {
            var _this2$queue$normaliz;

            // There's already an item in the queue, just attach ourselves to it.
            (_this2$queue$normaliz = _this2.queue[normalizedOptions][normalizedOrigin].listeners).push.apply(_this2$queue$normaliz, _toConsumableArray(listeners)); // This shouldn't be executed here.
            // See the comment inside _tryToCreateNewSession.


            _this2._tryToCreateNewSession(normalizedOptions, normalizedOrigin);

            return;
          }
        } else {
          _this2.queue[normalizedOptions] = {};
        } // The entry must be removed from the queue IMMEDIATELY when:
        // 1. the session connects successfully,
        // 2. an error occurs.


        var removeFromQueue = function removeFromQueue() {
          // Our entry can be replaced. We cannot remove the new one.
          if (normalizedOptions in _this2.queue && _this2.queue[normalizedOptions][normalizedOrigin] === entry) {
            delete _this2.queue[normalizedOptions][normalizedOrigin];

            if (Object.keys(_this2.queue[normalizedOptions]).length === 0) {
              delete _this2.queue[normalizedOptions];
            }
          }
        }; // The main logic is here


        var entry = function entry() {
          var name = "".concat(normalizedOrigin, ":").concat(normalizedOptions);
          var receivedSettings = false;

          try {
            var _session = http2.connect(origin, _objectSpread$7({
              createConnection: _this2.createConnection,
              settings: _this2.settings,
              session: _this2.tlsSessionCache.get(name)
            }, options));

            _session[kCurrentStreamsCount] = 0;
            _session[kGracefullyClosing] = false;

            var isFree = function isFree() {
              return _session[kCurrentStreamsCount] < _session.remoteSettings.maxConcurrentStreams;
            };

            var wasFree = true;

            _session.socket.once('session', function (tlsSession) {
              _this2.tlsSessionCache.set(name, tlsSession);
            });

            _session.once('error', function (error) {
              // Listeners are empty when the session successfully connected.
              var _iterator7 = _createForOfIteratorHelper$b(listeners),
                  _step7;

              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var _reject3 = _step7.value.reject;

                  _reject3(error);
                } // The connection got broken, purge the cache.

              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }

              _this2.tlsSessionCache.delete(name);
            });

            _session.setTimeout(_this2.timeout, function () {
              // Terminates all streams owned by this session.
              // TODO: Maybe the streams should have a "Session timed out" error?
              _session.destroy();
            });

            _session.once('close', function () {
              if (receivedSettings) {
                // 1. If it wasn't free then no need to decrease because
                //    it has been decreased already in session.request().
                // 2. `stream.once('close')` won't increment the count
                //    because the session is already closed.
                if (wasFree) {
                  _this2._freeSessionsCount--;
                }

                _this2._sessionsCount--; // This cannot be moved to the stream logic,
                // because there may be a session that hadn't made a single request.

                var where = _this2.sessions[normalizedOptions];
                where.splice(where.indexOf(_session), 1);

                if (where.length === 0) {
                  delete _this2.sessions[normalizedOptions];
                }
              } else {
                // Broken connection
                var _error = new Error('Session closed without receiving a SETTINGS frame');

                _error.code = 'HTTP2WRAPPER_NOSETTINGS';

                var _iterator8 = _createForOfIteratorHelper$b(listeners),
                    _step8;

                try {
                  for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                    var _reject4 = _step8.value.reject;

                    _reject4(_error);
                  }
                } catch (err) {
                  _iterator8.e(err);
                } finally {
                  _iterator8.f();
                }

                removeFromQueue();
              } // There may be another session awaiting.


              _this2._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
            }); // Iterates over the queue and processes listeners.


            var processListeners = function processListeners() {
              if (!(normalizedOptions in _this2.queue) || !isFree()) {
                return;
              }

              var _iterator9 = _createForOfIteratorHelper$b(_session[kOriginSet]),
                  _step9;

              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var _origin = _step9.value;

                  if (_origin in _this2.queue[normalizedOptions]) {
                    var _listeners = _this2.queue[normalizedOptions][_origin].listeners; // Prevents session overloading.

                    while (_listeners.length !== 0 && isFree()) {
                      // We assume `resolve(...)` calls `request(...)` *directly*,
                      // otherwise the session will get overloaded.
                      _listeners.shift().resolve(_session);
                    }

                    var where = _this2.queue[normalizedOptions];

                    if (where[_origin].listeners.length === 0) {
                      delete where[_origin];

                      if (Object.keys(where).length === 0) {
                        delete _this2.queue[normalizedOptions];
                        break;
                      }
                    } // We're no longer free, no point in continuing.


                    if (!isFree()) {
                      break;
                    }
                  }
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
            }; // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.


            _session.on('origin', function () {
              _session[kOriginSet] = _session.originSet;

              if (!isFree()) {
                // The session is full.
                return;
              }

              processListeners(); // Close covered sessions (if possible).

              closeCoveredSessions(_this2.sessions[normalizedOptions], _session);
            });

            _session.once('remoteSettings', function () {
              // Fix Node.js bug preventing the process from exiting
              _session.ref();

              _session.unref();

              _this2._sessionsCount++; // The Agent could have been destroyed already.

              if (entry.destroyed) {
                var _error2 = new Error('Agent has been destroyed');

                var _iterator10 = _createForOfIteratorHelper$b(listeners),
                    _step10;

                try {
                  for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                    var listener = _step10.value;
                    listener.reject(_error2);
                  }
                } catch (err) {
                  _iterator10.e(err);
                } finally {
                  _iterator10.f();
                }

                _session.destroy();

                return;
              }

              _session[kOriginSet] = _session.originSet;
              {
                var where = _this2.sessions;

                if (normalizedOptions in where) {
                  var _sessions = where[normalizedOptions];

                  _sessions.splice(getSortedIndex(_sessions, _session, compareSessions), 0, _session);
                } else {
                  where[normalizedOptions] = [_session];
                }
              }
              _this2._freeSessionsCount += 1;
              receivedSettings = true;

              _this2.emit('session', _session);

              processListeners();
              removeFromQueue(); // TODO: Close last recently used (or least used?) session

              if (_session[kCurrentStreamsCount] === 0 && _this2._freeSessionsCount > _this2.maxFreeSessions) {
                _session.close();
              } // Check if we haven't managed to execute all listeners.


              if (listeners.length !== 0) {
                // Request for a new session with predefined listeners.
                _this2.getSession(normalizedOrigin, options, listeners);

                listeners.length = 0;
              } // `session.remoteSettings.maxConcurrentStreams` might get increased


              _session.on('remoteSettings', function () {
                processListeners(); // In case the Origin Set changes

                closeCoveredSessions(_this2.sessions[normalizedOptions], _session);
              });
            }); // Shim `session.request()` in order to catch all streams


            _session[kRequest] = _session.request;

            _session.request = function (headers, streamOptions) {
              if (_session[kGracefullyClosing]) {
                throw new Error('The session is gracefully closing. No new streams are allowed.');
              }

              var stream = _session[kRequest](headers, streamOptions); // The process won't exit until the session is closed or all requests are gone.


              _session.ref();

              ++_session[kCurrentStreamsCount];

              if (_session[kCurrentStreamsCount] === _session.remoteSettings.maxConcurrentStreams) {
                _this2._freeSessionsCount--;
              }

              stream.once('close', function () {
                wasFree = isFree();
                --_session[kCurrentStreamsCount];

                if (!_session.destroyed && !_session.closed) {
                  closeSessionIfCovered(_this2.sessions[normalizedOptions], _session);

                  if (isFree() && !_session.closed) {
                    if (!wasFree) {
                      _this2._freeSessionsCount++;
                      wasFree = true;
                    }

                    var isEmpty = _session[kCurrentStreamsCount] === 0;

                    if (isEmpty) {
                      _session.unref();
                    }

                    if (isEmpty && (_this2._freeSessionsCount > _this2.maxFreeSessions || _session[kGracefullyClosing])) {
                      _session.close();
                    } else {
                      closeCoveredSessions(_this2.sessions[normalizedOptions], _session);
                      processListeners();
                    }
                  }
                }
              });
              return stream;
            };
          } catch (error) {
            var _iterator11 = _createForOfIteratorHelper$b(listeners),
                _step11;

            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                var listener = _step11.value;
                listener.reject(error);
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }

            removeFromQueue();
          }
        };

        entry.listeners = listeners;
        entry.completed = false;
        entry.destroyed = false;
        _this2.queue[normalizedOptions][normalizedOrigin] = entry;

        _this2._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
      });
    }
  }, {
    key: "request",
    value: function request(origin, options, headers, streamOptions) {
      var _this3 = this;

      return new Promise(function (_resolve, reject) {
        _this3.getSession(origin, options, [{
          reject: reject,
          resolve: function resolve(session) {
            try {
              _resolve(session.request(headers, streamOptions));
            } catch (error) {
              reject(error);
            }
          }
        }]);
      });
    }
  }, {
    key: "createConnection",
    value: function createConnection(origin, options) {
      return Agent.connect(origin, options);
    }
  }, {
    key: "closeFreeSessions",
    value: function closeFreeSessions() {
      for (var _i = 0, _Object$values = Object.values(this.sessions); _i < _Object$values.length; _i++) {
        var sessions = _Object$values[_i];

        var _iterator12 = _createForOfIteratorHelper$b(sessions),
            _step12;

        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var session = _step12.value;

            if (session[kCurrentStreamsCount] === 0) {
              session.close();
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy(reason) {
      for (var _i2 = 0, _Object$values2 = Object.values(this.sessions); _i2 < _Object$values2.length; _i2++) {
        var sessions = _Object$values2[_i2];

        var _iterator13 = _createForOfIteratorHelper$b(sessions),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var session = _step13.value;
            session.destroy(reason);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }

      for (var _i3 = 0, _Object$values3 = Object.values(this.queue); _i3 < _Object$values3.length; _i3++) {
        var entriesOfAuthority = _Object$values3[_i3];

        for (var _i4 = 0, _Object$values4 = Object.values(entriesOfAuthority); _i4 < _Object$values4.length; _i4++) {
          var entry = _Object$values4[_i4];
          entry.destroyed = true;
        }
      } // New requests should NOT attach to destroyed sessions


      this.queue = {};
    }
  }, {
    key: "freeSessions",
    get: function get() {
      return getSessions({
        agent: this,
        isFree: true
      });
    }
  }, {
    key: "busySessions",
    get: function get() {
      return getSessions({
        agent: this,
        isFree: false
      });
    }
  }], [{
    key: "normalizeOrigin",
    value: function normalizeOrigin(url, servername) {
      if (typeof url === 'string') {
        url = new URL(url);
      }

      if (servername && url.hostname !== servername) {
        url.hostname = servername;
      }

      return url.origin;
    }
  }, {
    key: "connect",
    value: function connect(origin, options) {
      options.ALPNProtocols = ['h2'];
      var port = origin.port || 443;
      var host = origin.hostname || origin.host;

      if (typeof options.servername === 'undefined') {
        options.servername = host;
      }

      return tls.connect(port, host, options);
    }
  }]);

  return Agent;
}(EventEmitter);

Agent$1.kCurrentStreamsCount = kCurrentStreamsCount;
Agent$1.kGracefullyClosing = kGracefullyClosing;
var agent = {
  Agent: Agent$1,
  globalAgent: new Agent$1()
};

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Readable = require$$0$4.Readable;

var IncomingMessage = /*#__PURE__*/function (_Readable) {
  _inherits(IncomingMessage, _Readable);

  var _super = _createSuper$6(IncomingMessage);

  function IncomingMessage(socket, highWaterMark) {
    var _this;

    _classCallCheck(this, IncomingMessage);

    _this = _super.call(this, {
      highWaterMark: highWaterMark,
      autoDestroy: false
    });
    _this.statusCode = null;
    _this.statusMessage = '';
    _this.httpVersion = '2.0';
    _this.httpVersionMajor = 2;
    _this.httpVersionMinor = 0;
    _this.headers = {};
    _this.trailers = {};
    _this.req = null;
    _this.aborted = false;
    _this.complete = false;
    _this.upgrade = null;
    _this.rawHeaders = [];
    _this.rawTrailers = [];
    _this.socket = socket;
    _this.connection = socket;
    _this._dumped = false;
    return _this;
  }

  _createClass(IncomingMessage, [{
    key: "_destroy",
    value: function _destroy(error) {
      this.req._request.destroy(error);
    }
  }, {
    key: "setTimeout",
    value: function setTimeout(ms, callback) {
      this.req.setTimeout(ms, callback);
      return this;
    }
  }, {
    key: "_dump",
    value: function _dump() {
      if (!this._dumped) {
        this._dumped = true;
        this.removeAllListeners('data');
        this.resume();
      }
    }
  }, {
    key: "_read",
    value: function _read() {
      if (this.req) {
        this.req._request.resume();
      }
    }
  }]);

  return IncomingMessage;
}(Readable);

var incomingMessage = IncomingMessage;

/* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */

var urlToOptions$1 = function urlToOptions(url) {
  var options = {
    protocol: url.protocol,
    hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
    host: url.host,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    href: url.href,
    path: "".concat(url.pathname || '').concat(url.search || '')
  };

  if (typeof url.port === 'string' && url.port.length !== 0) {
    options.port = Number(url.port);
  }

  if (url.username || url.password) {
    options.auth = "".concat(url.username || '', ":").concat(url.password || '');
  }

  return options;
};

function _createForOfIteratorHelper$a(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }

function _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var proxyEvents$1 = function proxyEvents(from, to, events) {
  var _iterator = _createForOfIteratorHelper$a(events),
      _step;

  try {
    var _loop = function _loop() {
      var event = _step.value;
      from.on(event, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return to.emit.apply(to, [event].concat(args));
      });
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};

var isRequestPseudoHeader = function isRequestPseudoHeader(header) {
  switch (header) {
    case ':method':
    case ':scheme':
    case ':authority':
    case ':path':
      return true;

    default:
      return false;
  }
};

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var errors = createCommonjsModule(function (module) {
  /* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */

  var makeError = function makeError(Base, key, getMessage) {
    module.exports[key] = /*#__PURE__*/function (_Base) {
      _inherits(NodeError, _Base);

      var _super = _createSuper$5(NodeError);

      function NodeError() {
        var _thisSuper, _this;

        _classCallCheck(this, NodeError);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _super.call(this, typeof getMessage === 'string' ? getMessage : getMessage(args));
        _this.name = "".concat(_get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(NodeError.prototype)), "name", _thisSuper), " [").concat(key, "]");
        _this.code = key;
        return _this;
      }

      return NodeError;
    }(Base);
  };

  makeError(TypeError, 'ERR_INVALID_ARG_TYPE', function (args) {
    var type = args[0].includes('.') ? 'property' : 'argument';
    var valid = args[1];
    var isManyTypes = Array.isArray(valid);

    if (isManyTypes) {
      valid = "".concat(valid.slice(0, -1).join(', '), " or ").concat(valid.slice(-1));
    }

    return "The \"".concat(args[0], "\" ").concat(type, " must be ").concat(isManyTypes ? 'one of' : 'of', " type ").concat(valid, ". Received ").concat(_typeof(args[2]));
  });
  makeError(TypeError, 'ERR_INVALID_PROTOCOL', function (args) {
    return "Protocol \"".concat(args[0], "\" not supported. Expected \"").concat(args[1], "\"");
  });
  makeError(Error, 'ERR_HTTP_HEADERS_SENT', function (args) {
    return "Cannot ".concat(args[0], " headers after they are sent to the client");
  });
  makeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', function (args) {
    return "".concat(args[0], " must be a valid HTTP token [").concat(args[1], "]");
  });
  makeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', function (args) {
    return "Invalid value \"".concat(args[0], " for header \"").concat(args[1], "\"");
  });
  makeError(TypeError, 'ERR_INVALID_CHAR', function (args) {
    return "Invalid character in ".concat(args[0], " [").concat(args[1], "]");
  });
});

function _createForOfIteratorHelper$9(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }

function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Writable = require$$0$4.Writable;
var Agent = agent.Agent,
    globalAgent = agent.globalAgent;
var ERR_INVALID_ARG_TYPE = errors.ERR_INVALID_ARG_TYPE,
    ERR_INVALID_PROTOCOL = errors.ERR_INVALID_PROTOCOL,
    ERR_HTTP_HEADERS_SENT = errors.ERR_HTTP_HEADERS_SENT,
    ERR_INVALID_HTTP_TOKEN = errors.ERR_INVALID_HTTP_TOKEN,
    ERR_HTTP_INVALID_HEADER_VALUE = errors.ERR_HTTP_INVALID_HEADER_VALUE,
    ERR_INVALID_CHAR = errors.ERR_INVALID_CHAR;
var _http2$constants = http2.constants,
    HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS,
    HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,
    HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,
    HTTP2_METHOD_CONNECT = _http2$constants.HTTP2_METHOD_CONNECT;
var kHeaders = Symbol('headers');
var kOrigin = Symbol('origin');
var kSession = Symbol('session');
var kOptions = Symbol('options');
var kFlushedHeaders = Symbol('flushedHeaders');
var kJobs = Symbol('jobs');
var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;

var ClientRequest = /*#__PURE__*/function (_Writable) {
  _inherits(ClientRequest, _Writable);

  var _super = _createSuper$4(ClientRequest);

  function ClientRequest(input, options, callback) {
    var _this;

    _classCallCheck(this, ClientRequest);

    _this = _super.call(this, {
      autoDestroy: false
    });
    var hasInput = typeof input === 'string' || input instanceof URL;

    if (hasInput) {
      input = urlToOptions$1(input instanceof URL ? input : new URL(input));
    }

    if (typeof options === 'function' || options === undefined) {
      // (options, callback)
      callback = options;
      options = hasInput ? input : _objectSpread$6({}, input);
    } else {
      // (input, options, callback)
      options = _objectSpread$6(_objectSpread$6({}, input), options);
    }

    if (options.h2session) {
      _this[kSession] = options.h2session;
    } else if (options.agent === false) {
      _this.agent = new Agent({
        maxFreeSessions: 0
      });
    } else if (typeof options.agent === 'undefined' || options.agent === null) {
      if (typeof options.createConnection === 'function') {
        // This is a workaround - we don't have to create the session on our own.
        _this.agent = new Agent({
          maxFreeSessions: 0
        });
        _this.agent.createConnection = options.createConnection;
      } else {
        _this.agent = globalAgent;
      }
    } else if (typeof options.agent.request === 'function') {
      _this.agent = options.agent;
    } else {
      throw new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);
    }

    if (options.protocol && options.protocol !== 'https:') {
      throw new ERR_INVALID_PROTOCOL(options.protocol, 'https:');
    }

    var port = options.port || options.defaultPort || _this.agent && _this.agent.defaultPort || 443;
    var host = options.hostname || options.host || 'localhost'; // Don't enforce the origin via options. It may be changed in an Agent.

    delete options.hostname;
    delete options.host;
    delete options.port;
    var _options = options,
        timeout = _options.timeout;
    options.timeout = undefined;
    _this[kHeaders] = Object.create(null);
    _this[kJobs] = [];
    _this.socket = null;
    _this.connection = null;
    _this.method = options.method || 'GET';
    _this.path = options.path;
    _this.res = null;
    _this.aborted = false;
    _this.reusedSocket = false;

    if (options.headers) {
      for (var _i = 0, _Object$entries = Object.entries(options.headers); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            header = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        _this.setHeader(header, value);
      }
    }

    if (options.auth && !('authorization' in _this[kHeaders])) {
      _this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');
    }

    options.session = options.tlsSession;
    options.path = options.socketPath;
    _this[kOptions] = options; // Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.

    if (port === 443) {
      _this[kOrigin] = "https://".concat(host);

      if (!(':authority' in _this[kHeaders])) {
        _this[kHeaders][':authority'] = host;
      }
    } else {
      _this[kOrigin] = "https://".concat(host, ":").concat(port);

      if (!(':authority' in _this[kHeaders])) {
        _this[kHeaders][':authority'] = "".concat(host, ":").concat(port);
      }
    }

    if (timeout) {
      _this.setTimeout(timeout);
    }

    if (callback) {
      _this.once('response', callback);
    }

    _this[kFlushedHeaders] = false;
    return _this;
  }

  _createClass(ClientRequest, [{
    key: "method",
    get: function get() {
      return this[kHeaders][HTTP2_HEADER_METHOD];
    },
    set: function set(value) {
      if (value) {
        this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
      }
    }
  }, {
    key: "path",
    get: function get() {
      return this[kHeaders][HTTP2_HEADER_PATH];
    },
    set: function set(value) {
      if (value) {
        this[kHeaders][HTTP2_HEADER_PATH] = value;
      }
    }
  }, {
    key: "_mustNotHaveABody",
    get: function get() {
      return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';
    }
  }, {
    key: "_write",
    value: function _write(chunk, encoding, callback) {
      var _this2 = this;

      // https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156
      if (this._mustNotHaveABody) {
        callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));
        /* istanbul ignore next: Node.js 12 throws directly */

        return;
      }

      this.flushHeaders();

      var callWrite = function callWrite() {
        return _this2._request.write(chunk, encoding, callback);
      };

      if (this._request) {
        callWrite();
      } else {
        this[kJobs].push(callWrite);
      }
    }
  }, {
    key: "_final",
    value: function _final(callback) {
      var _this3 = this;

      if (this.destroyed) {
        return;
      }

      this.flushHeaders();

      var callEnd = function callEnd() {
        // For GET, HEAD and DELETE
        if (_this3._mustNotHaveABody) {
          callback();
          return;
        }

        _this3._request.end(callback);
      };

      if (this._request) {
        callEnd();
      } else {
        this[kJobs].push(callEnd);
      }
    }
  }, {
    key: "abort",
    value: function abort() {
      var _this4 = this;

      if (this.res && this.res.complete) {
        return;
      }

      if (!this.aborted) {
        process.nextTick(function () {
          return _this4.emit('abort');
        });
      }

      this.aborted = true;
      this.destroy();
    }
  }, {
    key: "_destroy",
    value: function _destroy(error, callback) {
      if (this.res) {
        this.res._dump();
      }

      if (this._request) {
        this._request.destroy();
      }

      callback(error);
    }
  }, {
    key: "flushHeaders",
    value: function () {
      var _flushHeaders = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var _this5 = this;

        var isConnectMethod, onStream;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this[kFlushedHeaders] || this.destroyed)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                this[kFlushedHeaders] = true;
                isConnectMethod = this.method === HTTP2_METHOD_CONNECT; // The real magic is here

                onStream = function onStream(stream) {
                  _this5._request = stream;

                  if (_this5.destroyed) {
                    stream.destroy();
                    return;
                  } // Forwards `timeout`, `continue`, `close` and `error` events to this instance.


                  if (!isConnectMethod) {
                    proxyEvents$1(stream, _this5, ['timeout', 'continue', 'close', 'error']);
                  } // Wait for the `finish` event. We don't want to emit the `response` event
                  // before `request.end()` is called.


                  var waitForEnd = function waitForEnd(fn) {
                    return function () {
                      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                      }

                      if (!_this5.writable && !_this5.destroyed) {
                        fn.apply(void 0, args);
                      } else {
                        _this5.once('finish', function () {
                          fn.apply(void 0, args);
                        });
                      }
                    };
                  }; // This event tells we are ready to listen for the data.


                  stream.once('response', waitForEnd(function (headers, flags, rawHeaders) {
                    // If we were to emit raw request stream, it would be as fast as the native approach.
                    // Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
                    var response = new incomingMessage(_this5.socket, stream.readableHighWaterMark);
                    _this5.res = response;
                    response.req = _this5;
                    response.statusCode = headers[HTTP2_HEADER_STATUS];
                    response.headers = headers;
                    response.rawHeaders = rawHeaders;
                    response.once('end', function () {
                      if (_this5.aborted) {
                        response.aborted = true;
                        response.emit('aborted');
                      } else {
                        response.complete = true; // Has no effect, just be consistent with the Node.js behavior

                        response.socket = null;
                        response.connection = null;
                      }
                    });

                    if (isConnectMethod) {
                      response.upgrade = true; // The HTTP1 API says the socket is detached here,
                      // but we can't do that so we pass the original HTTP2 request.

                      if (_this5.emit('connect', response, stream, Buffer.alloc(0))) {
                        _this5.emit('close');
                      } else {
                        // No listeners attached, destroy the original request.
                        stream.destroy();
                      }
                    } else {
                      // Forwards data
                      stream.on('data', function (chunk) {
                        if (!response._dumped && !response.push(chunk)) {
                          stream.pause();
                        }
                      });
                      stream.once('end', function () {
                        response.push(null);
                      });

                      if (!_this5.emit('response', response)) {
                        // No listeners attached, dump the response.
                        response._dump();
                      }
                    }
                  })); // Emits `information` event

                  stream.once('headers', waitForEnd(function (headers) {
                    return _this5.emit('information', {
                      statusCode: headers[HTTP2_HEADER_STATUS]
                    });
                  }));
                  stream.once('trailers', waitForEnd(function (trailers, flags, rawTrailers) {
                    var res = _this5.res; // Assigns trailers to the response object.

                    res.trailers = trailers;
                    res.rawTrailers = rawTrailers;
                  }));
                  var socket = stream.session.socket;
                  _this5.socket = socket;
                  _this5.connection = socket;

                  var _iterator = _createForOfIteratorHelper$9(_this5[kJobs]),
                      _step;

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      var job = _step.value;
                      job();
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }

                  _this5.emit('socket', _this5.socket);
                }; // Makes a HTTP2 request


                if (!this[kSession]) {
                  _context.next = 9;
                  break;
                }

                try {
                  onStream(this[kSession].request(this[kHeaders]));
                } catch (error) {
                  this.emit('error', error);
                }

                _context.next = 21;
                break;

              case 9:
                this.reusedSocket = true;
                _context.prev = 10;
                _context.t0 = onStream;
                _context.next = 14;
                return this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);

              case 14:
                _context.t1 = _context.sent;
                (0, _context.t0)(_context.t1);
                _context.next = 21;
                break;

              case 18:
                _context.prev = 18;
                _context.t2 = _context["catch"](10);
                this.emit('error', _context.t2);

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[10, 18]]);
      }));

      function flushHeaders() {
        return _flushHeaders.apply(this, arguments);
      }

      return flushHeaders;
    }()
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      if (typeof name !== 'string') {
        throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
      }

      return this[kHeaders][name.toLowerCase()];
    }
  }, {
    key: "headersSent",
    get: function get() {
      return this[kFlushedHeaders];
    }
  }, {
    key: "removeHeader",
    value: function removeHeader(name) {
      if (typeof name !== 'string') {
        throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
      }

      if (this.headersSent) {
        throw new ERR_HTTP_HEADERS_SENT('remove');
      }

      delete this[kHeaders][name.toLowerCase()];
    }
  }, {
    key: "setHeader",
    value: function setHeader(name, value) {
      if (this.headersSent) {
        throw new ERR_HTTP_HEADERS_SENT('set');
      }

      if (typeof name !== 'string' || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
        throw new ERR_INVALID_HTTP_TOKEN('Header name', name);
      }

      if (typeof value === 'undefined') {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
      }

      if (isInvalidHeaderValue.test(value)) {
        throw new ERR_INVALID_CHAR('header content', name);
      }

      this[kHeaders][name.toLowerCase()] = value;
    }
  }, {
    key: "setNoDelay",
    value: function setNoDelay() {// HTTP2 sockets cannot be malformed, do nothing.
    }
  }, {
    key: "setSocketKeepAlive",
    value: function setSocketKeepAlive() {// HTTP2 sockets cannot be malformed, do nothing.
    }
  }, {
    key: "setTimeout",
    value: function setTimeout(ms, callback) {
      var _this6 = this;

      var applyTimeout = function applyTimeout() {
        return _this6._request.setTimeout(ms, callback);
      };

      if (this._request) {
        applyTimeout();
      } else {
        this[kJobs].push(applyTimeout);
      }

      return this;
    }
  }, {
    key: "maxHeadersCount",
    get: function get() {
      if (!this.destroyed && this._request) {
        return this._request.session.localSettings.maxHeaderListSize;
      }

      return undefined;
    },
    set: function set(_value) {// Updating HTTP2 settings would affect all requests, do nothing.
    }
  }]);

  return ClientRequest;
}(Writable);

var clientRequest = ClientRequest;

var resolveAlpn = function resolveAlpn() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new Promise(function (resolve, reject) {
    var timeout = false;

    var callback = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                socket.off('timeout', onTimeout);
                socket.off('error', reject);

                if (!options.resolveSocket) {
                  _context.next = 10;
                  break;
                }

                resolve({
                  alpnProtocol: socket.alpnProtocol,
                  socket: socket,
                  timeout: timeout
                });

                if (!timeout) {
                  _context.next = 8;
                  break;
                }

                _context.next = 7;
                return Promise.resolve();

              case 7:
                socket.emit('timeout');

              case 8:
                _context.next = 12;
                break;

              case 10:
                socket.destroy();
                resolve({
                  alpnProtocol: socket.alpnProtocol,
                  timeout: timeout
                });

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function callback() {
        return _ref.apply(this, arguments);
      };
    }();

    var onTimeout = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                timeout = true;
                callback();

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function onTimeout() {
        return _ref2.apply(this, arguments);
      };
    }();

    var socket = tls.connect(options, callback);
    socket.on('error', reject);
    socket.once('timeout', onTimeout);
  });
};

/* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */


var calculateServerName = function calculateServerName(options) {
  var servername = options.host;
  var hostHeader = options.headers && options.headers.host;

  if (hostHeader) {
    if (hostHeader.startsWith('[')) {
      var index = hostHeader.indexOf(']');

      if (index === -1) {
        servername = hostHeader;
      } else {
        servername = hostHeader.slice(1, -1);
      }
    } else {
      servername = hostHeader.split(':', 1)[0];
    }
  }

  if (net.isIP(servername)) {
    return '';
  }

  return servername;
};

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var cache = new quickLru({
  maxSize: 100
});
var queue = new Map();

var installSocket = function installSocket(agent, socket, options) {
  socket._httpMessage = {
    shouldKeepAlive: true
  };

  var onFree = function onFree() {
    agent.emit('free', socket, options);
  };

  socket.on('free', onFree);

  var onClose = function onClose() {
    agent.removeSocket(socket, options);
  };

  socket.on('close', onClose);

  var onRemove = function onRemove() {
    agent.removeSocket(socket, options);
    socket.off('close', onClose);
    socket.off('free', onFree);
    socket.off('agentRemove', onRemove);
  };

  socket.on('agentRemove', onRemove);
  agent.emit('free', socket, options);
};

var resolveProtocol = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(options) {
    var name, result, path, agent, resultPromise, _yield$resultPromise, socket, alpnProtocol, globalAgent, defaultCreateConnection;

    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            name = "".concat(options.host, ":").concat(options.port, ":").concat(options.ALPNProtocols.sort());

            if (cache.has(name)) {
              _context.next = 28;
              break;
            }

            if (!queue.has(name)) {
              _context.next = 7;
              break;
            }

            _context.next = 5;
            return queue.get(name);

          case 5:
            result = _context.sent;
            return _context.abrupt("return", result.alpnProtocol);

          case 7:
            path = options.path, agent = options.agent;
            options.path = options.socketPath;
            resultPromise = resolveAlpn(options);
            queue.set(name, resultPromise);
            _context.prev = 11;
            _context.next = 14;
            return resultPromise;

          case 14:
            _yield$resultPromise = _context.sent;
            socket = _yield$resultPromise.socket;
            alpnProtocol = _yield$resultPromise.alpnProtocol;
            cache.set(name, alpnProtocol);
            options.path = path;

            if (alpnProtocol === 'h2') {
              // https://github.com/nodejs/node/issues/33343
              socket.destroy();
            } else {
              globalAgent = https.globalAgent;
              defaultCreateConnection = https.Agent.prototype.createConnection;

              if (agent) {
                if (agent.createConnection === defaultCreateConnection) {
                  installSocket(agent, socket, options);
                } else {
                  socket.destroy();
                }
              } else if (globalAgent.createConnection === defaultCreateConnection) {
                installSocket(globalAgent, socket, options);
              } else {
                socket.destroy();
              }
            }

            queue.delete(name);
            return _context.abrupt("return", alpnProtocol);

          case 24:
            _context.prev = 24;
            _context.t0 = _context["catch"](11);
            queue.delete(name);
            throw _context.t0;

          case 28:
            return _context.abrupt("return", cache.get(name));

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[11, 24]]);
  }));

  return function resolveProtocol(_x) {
    return _ref.apply(this, arguments);
  };
}();

var auto = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(input, options, callback) {
    var isHttps, agents, protocol;
    return regenerator.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (typeof input === 'string' || input instanceof URL) {
              input = urlToOptions$1(new URL(input));
            }

            if (typeof options === 'function') {
              callback = options;
              options = undefined;
            }

            options = _objectSpread$5(_objectSpread$5(_objectSpread$5({
              ALPNProtocols: ['h2', 'http/1.1']
            }, input), options), {}, {
              resolveSocket: true
            });

            if (!(!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0)) {
              _context2.next = 5;
              break;
            }

            throw new Error('The `ALPNProtocols` option must be an Array with at least one entry');

          case 5:
            options.protocol = options.protocol || 'https:';
            isHttps = options.protocol === 'https:';
            options.host = options.hostname || options.host || 'localhost';
            options.session = options.tlsSession;
            options.servername = options.servername || calculateServerName(options);
            options.port = options.port || (isHttps ? 443 : 80);
            options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;
            agents = options.agent;

            if (!agents) {
              _context2.next = 17;
              break;
            }

            if (!agents.addRequest) {
              _context2.next = 16;
              break;
            }

            throw new Error('The `options.agent` object can contain only `http`, `https` or `http2` properties');

          case 16:
            options.agent = agents[isHttps ? 'https' : 'http'];

          case 17:
            if (!isHttps) {
              _context2.next = 24;
              break;
            }

            _context2.next = 20;
            return resolveProtocol(options);

          case 20:
            protocol = _context2.sent;

            if (!(protocol === 'h2')) {
              _context2.next = 24;
              break;
            }

            if (agents) {
              options.agent = agents.http2;
            }

            return _context2.abrupt("return", new clientRequest(options, callback));

          case 24:
            return _context2.abrupt("return", http.request(options, callback));

          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function auto(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

var protocolCache = cache;
auto.protocolCache = protocolCache;

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var request = function request(url, options, callback) {
  return new clientRequest(url, options, callback);
};

var get = function get(url, options, callback) {
  // eslint-disable-next-line unicorn/prevent-abbreviations
  var req = new clientRequest(url, options, callback);
  req.end();
  return req;
};

var source$1 = _objectSpread$4(_objectSpread$4(_objectSpread$4({}, http2), {}, {
  ClientRequest: clientRequest,
  IncomingMessage: incomingMessage
}, agent), {}, {
  request: request,
  get: get,
  auto: auto
});

var _default$f = function _default(body) {
  return dist$1.default.nodeStream(body) && dist$1.default.function_(body.getBoundary);
};

var isFormData = /*#__PURE__*/Object.defineProperty({
  default: _default$f
}, '__esModule', {
  value: true
});

var statAsync = util_1.promisify(fs.stat);

var _default$e = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(body, headers) {
    var _yield$statAsync, size;

    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(headers && 'content-length' in headers)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", Number(headers['content-length']));

          case 2:
            if (body) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", 0);

          case 4:
            if (!dist$1.default.string(body)) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", Buffer.byteLength(body));

          case 6:
            if (!dist$1.default.buffer(body)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", body.length);

          case 8:
            if (!isFormData.default(body)) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return", util_1.promisify(body.getLength.bind(body))());

          case 10:
            if (!(body instanceof fs.ReadStream)) {
              _context.next = 18;
              break;
            }

            _context.next = 13;
            return statAsync(body.path);

          case 13:
            _yield$statAsync = _context.sent;
            size = _yield$statAsync.size;

            if (!(size === 0)) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", undefined);

          case 17:
            return _context.abrupt("return", size);

          case 18:
            return _context.abrupt("return", undefined);

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function _default(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var getBodySize = /*#__PURE__*/Object.defineProperty({
  default: _default$e
}, '__esModule', {
  value: true
});

function _createForOfIteratorHelper$8(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function default_1(from, to, events) {
  var fns = {};

  var _iterator = _createForOfIteratorHelper$8(events),
      _step;

  try {
    var _loop = function _loop() {
      var event = _step.value;

      fns[event] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        to.emit.apply(to, [event].concat(args));
      };

      from.on(event, fns[event]);
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return function () {
    var _iterator2 = _createForOfIteratorHelper$8(events),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var event = _step2.value;
        from.off(event, fns[event]);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  };
}

var _default$d = default_1;
var proxyEvents = /*#__PURE__*/Object.defineProperty({
  default: _default$d
}, '__esModule', {
  value: true
});

// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.

function _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _default$c = function _default() {
  var handlers = [];
  return {
    once: function once(origin, event, fn) {
      origin.once(event, fn);
      handlers.push({
        origin: origin,
        event: event,
        fn: fn
      });
    },
    unhandleAll: function unhandleAll() {
      var _iterator = _createForOfIteratorHelper$7(handlers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var handler = _step.value;
          var origin = handler.origin,
              event = handler.event,
              fn = handler.fn;
          origin.removeListener(event, fn);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      handlers.length = 0;
    }
  };
};

var unhandle = /*#__PURE__*/Object.defineProperty({
  default: _default$c
}, '__esModule', {
  value: true
});

function _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var timedOut = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TimeoutError = void 0;
  var reentry = Symbol('reentry');

  var noop = function noop() {};

  var TimeoutError = /*#__PURE__*/function (_Error) {
    _inherits(TimeoutError, _Error);

    var _super = _createSuper$3(TimeoutError);

    function TimeoutError(threshold, event) {
      var _this;

      _classCallCheck(this, TimeoutError);

      _this = _super.call(this, "Timeout awaiting '".concat(event, "' for ").concat(threshold, "ms"));
      _this.event = event;
      _this.name = 'TimeoutError';
      _this.code = 'ETIMEDOUT';
      return _this;
    }

    return TimeoutError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  exports.TimeoutError = TimeoutError;

  exports.default = function (request, delays, options) {
    if (reentry in request) {
      return noop;
    }

    request[reentry] = true;
    var cancelers = [];

    var _unhandle_1$default = unhandle.default(),
        once = _unhandle_1$default.once,
        unhandleAll = _unhandle_1$default.unhandleAll;

    var addTimeout = function addTimeout(delay, callback, event) {
      var _a;

      var timeout = setTimeout(callback, delay, delay, event);
      (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);

      var cancel = function cancel() {
        clearTimeout(timeout);
      };

      cancelers.push(cancel);
      return cancel;
    };

    var host = options.host,
        hostname = options.hostname;

    var timeoutHandler = function timeoutHandler(delay, event) {
      request.destroy(new TimeoutError(delay, event));
    };

    var cancelTimeouts = function cancelTimeouts() {
      var _iterator = _createForOfIteratorHelper$6(cancelers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var cancel = _step.value;
          cancel();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      unhandleAll();
    };

    request.once('error', function (error) {
      cancelTimeouts(); // Save original behavior

      /* istanbul ignore next */

      if (request.listenerCount('error') === 0) {
        throw error;
      }
    });
    request.once('close', cancelTimeouts);
    once(request, 'response', function (response) {
      once(response, 'end', cancelTimeouts);
    });

    if (typeof delays.request !== 'undefined') {
      addTimeout(delays.request, timeoutHandler, 'request');
    }

    if (typeof delays.socket !== 'undefined') {
      var socketTimeoutHandler = function socketTimeoutHandler() {
        timeoutHandler(delays.socket, 'socket');
      };

      request.setTimeout(delays.socket, socketTimeoutHandler); // `request.setTimeout(0)` causes a memory leak.
      // We can just remove the listener and forget about the timer - it's unreffed.
      // See https://github.com/sindresorhus/got/issues/690

      cancelers.push(function () {
        request.removeListener('timeout', socketTimeoutHandler);
      });
    }

    once(request, 'socket', function (socket) {
      var _a;

      var socketPath = request.socketPath;
      /* istanbul ignore next: hard to test */

      if (socket.connecting) {
        var hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);

        if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {
          var cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
          once(socket, 'lookup', cancelTimeout);
        }

        if (typeof delays.connect !== 'undefined') {
          var timeConnect = function timeConnect() {
            return addTimeout(delays.connect, timeoutHandler, 'connect');
          };

          if (hasPath) {
            once(socket, 'connect', timeConnect());
          } else {
            once(socket, 'lookup', function (error) {
              if (error === null) {
                once(socket, 'connect', timeConnect());
              }
            });
          }
        }

        if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {
          once(socket, 'connect', function () {
            var cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
            once(socket, 'secureConnect', cancelTimeout);
          });
        }
      }

      if (typeof delays.send !== 'undefined') {
        var timeRequest = function timeRequest() {
          return addTimeout(delays.send, timeoutHandler, 'send');
        };
        /* istanbul ignore next: hard to test */


        if (socket.connecting) {
          once(socket, 'connect', function () {
            once(request, 'upload-complete', timeRequest());
          });
        } else {
          once(request, 'upload-complete', timeRequest());
        }
      }
    });

    if (typeof delays.response !== 'undefined') {
      once(request, 'upload-complete', function () {
        var cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
        once(request, 'response', cancelTimeout);
      });
    }

    return cancelTimeouts;
  };
});

var _default$b = function _default(url) {
  // Cast to URL
  url = url;
  var options = {
    protocol: url.protocol,
    hostname: dist$1.default.string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
    host: url.host,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    href: url.href,
    path: "".concat(url.pathname || '').concat(url.search || '')
  };

  if (dist$1.default.string(url.port) && url.port.length > 0) {
    options.port = Number(url.port);
  }

  if (url.username || url.password) {
    options.auth = "".concat(url.username || '', ":").concat(url.password || '');
  }

  return options;
};

var urlToOptions = /*#__PURE__*/Object.defineProperty({
  default: _default$b
}, '__esModule', {
  value: true
});

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/* istanbul ignore file: deprecated */


var keys = ['protocol', 'host', 'hostname', 'port', 'pathname', 'search'];

var _default$a = function _default(origin, options) {
  var _a, _b;

  if (options.path) {
    if (options.pathname) {
      throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');
    }

    if (options.search) {
      throw new TypeError('Parameters `path` and `search` are mutually exclusive.');
    }

    if (options.searchParams) {
      throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');
    }
  }

  if (options.search && options.searchParams) {
    throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');
  }

  if (!origin) {
    if (!options.protocol) {
      throw new TypeError('No URL protocol specified');
    }

    origin = "".concat(options.protocol, "//").concat((_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : '');
  }

  var url = new url_1.URL(origin);

  if (options.path) {
    var searchIndex = options.path.indexOf('?');

    if (searchIndex === -1) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.slice(0, searchIndex);
      options.search = options.path.slice(searchIndex + 1);
    }

    delete options.path;
  }

  var _iterator = _createForOfIteratorHelper$5(keys),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;

      if (options[key]) {
        url[key] = options[key].toString();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return url;
};

var optionsToUrl = /*#__PURE__*/Object.defineProperty({
  default: _default$a
}, '__esModule', {
  value: true
});

var WeakableMap = /*#__PURE__*/function () {
  function WeakableMap() {
    _classCallCheck(this, WeakableMap);

    this.weakMap = new WeakMap();
    this.map = new Map();
  }

  _createClass(WeakableMap, [{
    key: "set",
    value: function set(key, value) {
      if (_typeof(key) === 'object') {
        this.weakMap.set(key, value);
      } else {
        this.map.set(key, value);
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      if (_typeof(key) === 'object') {
        return this.weakMap.get(key);
      }

      return this.map.get(key);
    }
  }, {
    key: "has",
    value: function has(key) {
      if (_typeof(key) === 'object') {
        return this.weakMap.has(key);
      }

      return this.map.has(key);
    }
  }]);

  return WeakableMap;
}();

var _default$9 = WeakableMap;
var weakableMap = /*#__PURE__*/Object.defineProperty({
  default: _default$9
}, '__esModule', {
  value: true
});

var getBuffer = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(stream) {
    var chunks, length, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chunks = [];
            length = 0;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 4;
            _iterator = _asyncIterator(stream);

          case 6:
            _context.next = 8;
            return _iterator.next();

          case 8:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 12;
            return _step.value;

          case 12:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 20;
              break;
            }

            chunk = _value;
            chunks.push(chunk);
            length += Buffer.byteLength(chunk);

          case 17:
            _iteratorNormalCompletion = true;
            _context.next = 6;
            break;

          case 20:
            _context.next = 26;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 26:
            _context.prev = 26;
            _context.prev = 27;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 31;
              break;
            }

            _context.next = 31;
            return _iterator.return();

          case 31:
            _context.prev = 31;

            if (!_didIteratorError) {
              _context.next = 34;
              break;
            }

            throw _iteratorError;

          case 34:
            return _context.finish(31);

          case 35:
            return _context.finish(26);

          case 36:
            if (!Buffer.isBuffer(chunks[0])) {
              _context.next = 38;
              break;
            }

            return _context.abrupt("return", Buffer.concat(chunks, length));

          case 38:
            return _context.abrupt("return", Buffer.from(chunks.join('')));

          case 39:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 22, 26, 36], [27,, 31, 35]]);
  }));

  return function getBuffer(_x) {
    return _ref.apply(this, arguments);
  };
}();

var _default$8 = getBuffer;
var getBuffer_1 = /*#__PURE__*/Object.defineProperty({
  default: _default$8
}, '__esModule', {
  value: true
});

var dnsIpVersion = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;
  var conversionTable = {
    auto: 0,
    ipv4: 4,
    ipv6: 6
  };

  exports.isDnsLookupIpVersion = function (value) {
    return value in conversionTable;
  };

  exports.dnsLookupIpVersionToFamily = function (dnsLookupIpVersion) {
    if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {
      return conversionTable[dnsLookupIpVersion];
    }

    throw new Error('Invalid DNS lookup IP version');
  };
});

var isResponseOk = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isResponseOk = void 0;

  exports.isResponseOk = function (response) {
    var statusCode = response.statusCode;
    var limitStatusCode = response.request.options.followRedirect ? 299 : 399;
    return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
  };
});

var alreadyWarned = new Set();

var _default$7 = function _default(message) {
  if (alreadyWarned.has(message)) {
    return;
  }

  alreadyWarned.add(message); // @ts-expect-error Missing types.

  process.emitWarning("Got: ".concat(message), {
    type: 'DeprecationWarning'
  });
};

var deprecationWarning = /*#__PURE__*/Object.defineProperty({
  default: _default$7
}, '__esModule', {
  value: true
});

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var normalizeArguments = function normalizeArguments(options, defaults) {
  if (dist$1.default.null_(options.encoding)) {
    throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
  }

  dist$1.assert.any([dist$1.default.string, dist$1.default.undefined], options.encoding);
  dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.resolveBodyOnly);
  dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.methodRewriting);
  dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.isStream);
  dist$1.assert.any([dist$1.default.string, dist$1.default.undefined], options.responseType); // `options.responseType`

  if (options.responseType === undefined) {
    options.responseType = 'text';
  } // `options.retry`


  var retry = options.retry;

  if (defaults) {
    options.retry = _objectSpread$3({}, defaults.retry);
  } else {
    options.retry = {
      calculateDelay: function calculateDelay(retryObject) {
        return retryObject.computedValue;
      },
      limit: 0,
      methods: [],
      statusCodes: [],
      errorCodes: [],
      maxRetryAfter: undefined
    };
  }

  if (dist$1.default.object(retry)) {
    options.retry = _objectSpread$3(_objectSpread$3({}, options.retry), retry);
    options.retry.methods = _toConsumableArray(new Set(options.retry.methods.map(function (method) {
      return method.toUpperCase();
    })));
    options.retry.statusCodes = _toConsumableArray(new Set(options.retry.statusCodes));
    options.retry.errorCodes = _toConsumableArray(new Set(options.retry.errorCodes));
  } else if (dist$1.default.number(retry)) {
    options.retry.limit = retry;
  }

  if (dist$1.default.undefined(options.retry.maxRetryAfter)) {
    options.retry.maxRetryAfter = Math.min.apply(Math, _toConsumableArray([options.timeout.request, options.timeout.connect].filter(dist$1.default.number)));
  } // `options.pagination`


  if (dist$1.default.object(options.pagination)) {
    if (defaults) {
      options.pagination = _objectSpread$3(_objectSpread$3({}, defaults.pagination), options.pagination);
    }

    var pagination = options.pagination;

    if (!dist$1.default.function_(pagination.transform)) {
      throw new Error('`options.pagination.transform` must be implemented');
    }

    if (!dist$1.default.function_(pagination.shouldContinue)) {
      throw new Error('`options.pagination.shouldContinue` must be implemented');
    }

    if (!dist$1.default.function_(pagination.filter)) {
      throw new TypeError('`options.pagination.filter` must be implemented');
    }

    if (!dist$1.default.function_(pagination.paginate)) {
      throw new Error('`options.pagination.paginate` must be implemented');
    }
  } // JSON mode


  if (options.responseType === 'json' && options.headers.accept === undefined) {
    options.headers.accept = 'application/json';
  }

  return options;
};

var _default$6 = normalizeArguments;
var normalizeArguments_1 = /*#__PURE__*/Object.defineProperty({
  default: _default$6
}, '__esModule', {
  value: true
});

var calculateRetryDelay_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.retryAfterStatusCodes = void 0;
  exports.retryAfterStatusCodes = new Set([413, 429, 503]);

  var calculateRetryDelay = function calculateRetryDelay(_ref) {
    var attemptCount = _ref.attemptCount,
        retryOptions = _ref.retryOptions,
        error = _ref.error,
        retryAfter = _ref.retryAfter;

    if (attemptCount > retryOptions.limit) {
      return 0;
    }

    var hasMethod = retryOptions.methods.includes(error.options.method);
    var hasErrorCode = retryOptions.errorCodes.includes(error.code);
    var hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);

    if (!hasMethod || !hasErrorCode && !hasStatusCode) {
      return 0;
    }

    if (error.response) {
      if (retryAfter) {
        if (retryOptions.maxRetryAfter === undefined || retryAfter > retryOptions.maxRetryAfter) {
          return 0;
        }

        return retryAfter;
      }

      if (error.response.statusCode === 413) {
        return 0;
      }
    }

    var noise = Math.random() * 100;
    return Math.pow(2, attemptCount - 1) * 1000 + noise;
  };

  exports.default = calculateRetryDelay;
});

function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); _groups.set(_this, groups || _groups.get(re)); return _setPrototypeOf(_this, BabelRegExp.prototype); } _inherits(BabelRegExp, RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; if (_typeof(args[args.length - 1]) !== "object") { args = [].slice.call(args); args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var core = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;
  var http_1 = http; // @ts-expect-error Missing types

  var globalDnsCache;
  var kRequest = Symbol('request');
  var kResponse = Symbol('response');
  var kResponseSize = Symbol('responseSize');
  var kDownloadedSize = Symbol('downloadedSize');
  var kBodySize = Symbol('bodySize');
  var kUploadedSize = Symbol('uploadedSize');
  var kServerResponsesPiped = Symbol('serverResponsesPiped');
  var kUnproxyEvents = Symbol('unproxyEvents');
  var kIsFromCache = Symbol('isFromCache');
  var kCancelTimeouts = Symbol('cancelTimeouts');
  var kStartedReading = Symbol('startedReading');
  var kStopReading = Symbol('stopReading');
  var kTriggerRead = Symbol('triggerRead');
  var kBody = Symbol('body');
  var kJobs = Symbol('jobs');
  var kOriginalResponse = Symbol('originalResponse');
  var kRetryTimeout = Symbol('retryTimeout');
  exports.kIsNormalizedAlready = Symbol('isNormalizedAlready');
  var supportsBrotli = dist$1.default.string(process.versions.brotli);
  exports.withoutBody = new Set(['GET', 'HEAD']);
  exports.knownHookEvents = ['init', 'beforeRequest', 'beforeRedirect', 'beforeError', 'beforeRetry', // Promise-Only
  'afterResponse'];

  function validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for (var key in searchParameters) {
      var value = searchParameters[key];

      if (!dist$1.default.string(value) && !dist$1.default.number(value) && !dist$1.default.boolean(value) && !dist$1.default.null_(value) && !dist$1.default.undefined(value)) {
        throw new TypeError("The `searchParams` value '".concat(String(value), "' must be a string, number, boolean or null"));
      }
    }
  }

  function isClientRequest(clientRequest) {
    return dist$1.default.object(clientRequest) && !('statusCode' in clientRequest);
  }

  var cacheableStore = new weakableMap.default();

  var waitForOpenFile = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(file) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var onError = function onError(error) {
                  reject(error);
                }; // Node.js 12 has incomplete types


                // Node.js 12 has incomplete types
                if (!file.pending) {
                  resolve();
                }

                file.once('error', onError);
                file.once('ready', function () {
                  file.off('error', onError);
                  resolve();
                });
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function waitForOpenFile(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
  var nonEnumerableProperties = ['context', 'body', 'json', 'form'];

  exports.setNonEnumerableProperties = function (sources, to) {
    // Non enumerable properties shall not be merged
    var properties = {};

    var _iterator = _createForOfIteratorHelper$4(sources),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var source = _step.value;

        if (!source) {
          continue;
        }

        var _iterator2 = _createForOfIteratorHelper$4(nonEnumerableProperties),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var name = _step2.value;

            if (!(name in source)) {
              continue;
            }

            properties[name] = {
              writable: true,
              configurable: true,
              enumerable: false,
              // @ts-expect-error TS doesn't see the check above
              value: source[name]
            };
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    Object.defineProperties(to, properties);
  };
  /**
  An error to be thrown when a request fails.
  Contains a `code` property with error class code, like `ECONNREFUSED`.
  */


  var RequestError = /*#__PURE__*/function (_Error) {
    _inherits(RequestError, _Error);

    var _super = _createSuper$2(RequestError);

    function RequestError(message, error, self) {
      var _this;

      _classCallCheck(this, RequestError);

      var _a;

      _this = _super.call(this, message);
      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
      _this.name = 'RequestError';
      _this.code = error.code;

      if (self instanceof Request) {
        Object.defineProperty(_assertThisInitialized(_this), 'request', {
          enumerable: false,
          value: self
        });
        Object.defineProperty(_assertThisInitialized(_this), 'response', {
          enumerable: false,
          value: self[kResponse]
        });
        Object.defineProperty(_assertThisInitialized(_this), 'options', {
          // This fails because of TS 3.7.2 useDefineForClassFields
          // Ref: https://github.com/microsoft/TypeScript/issues/34972
          enumerable: false,
          value: self.options
        });
      } else {
        Object.defineProperty(_assertThisInitialized(_this), 'options', {
          // This fails because of TS 3.7.2 useDefineForClassFields
          // Ref: https://github.com/microsoft/TypeScript/issues/34972
          enumerable: false,
          value: self
        });
      }

      _this.timings = (_a = _this.request) === null || _a === void 0 ? void 0 : _a.timings; // Recover the original stacktrace

      if (dist$1.default.string(error.stack) && dist$1.default.string(_this.stack)) {
        var indexOfMessage = _this.stack.indexOf(_this.message) + _this.message.length;

        var thisStackTrace = _this.stack.slice(indexOfMessage).split('\n').reverse();

        var errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\n').reverse(); // Remove duplicated traces

        while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
          thisStackTrace.shift();
        }

        _this.stack = "".concat(_this.stack.slice(0, indexOfMessage)).concat(thisStackTrace.reverse().join('\n')).concat(errorStackTrace.reverse().join('\n'));
      }

      return _this;
    }

    return RequestError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  exports.RequestError = RequestError;
  /**
  An error to be thrown when the server redirects you more than ten times.
  Includes a `response` property.
  */

  var MaxRedirectsError = /*#__PURE__*/function (_RequestError) {
    _inherits(MaxRedirectsError, _RequestError);

    var _super2 = _createSuper$2(MaxRedirectsError);

    function MaxRedirectsError(request) {
      var _this2;

      _classCallCheck(this, MaxRedirectsError);

      _this2 = _super2.call(this, "Redirected ".concat(request.options.maxRedirects, " times. Aborting."), {}, request);
      _this2.name = 'MaxRedirectsError';
      return _this2;
    }

    return MaxRedirectsError;
  }(RequestError);

  exports.MaxRedirectsError = MaxRedirectsError;
  /**
  An error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.
  Includes a `response` property.
  */

  var HTTPError = /*#__PURE__*/function (_RequestError2) {
    _inherits(HTTPError, _RequestError2);

    var _super3 = _createSuper$2(HTTPError);

    function HTTPError(response) {
      var _this3;

      _classCallCheck(this, HTTPError);

      _this3 = _super3.call(this, "Response code ".concat(response.statusCode, " (").concat(response.statusMessage, ")"), {}, response.request);
      _this3.name = 'HTTPError';
      return _this3;
    }

    return HTTPError;
  }(RequestError);

  exports.HTTPError = HTTPError;
  /**
  An error to be thrown when a cache method fails.
  For example, if the database goes down or there's a filesystem error.
  */

  var CacheError = /*#__PURE__*/function (_RequestError3) {
    _inherits(CacheError, _RequestError3);

    var _super4 = _createSuper$2(CacheError);

    function CacheError(error, request) {
      var _this4;

      _classCallCheck(this, CacheError);

      _this4 = _super4.call(this, error.message, error, request);
      _this4.name = 'CacheError';
      return _this4;
    }

    return CacheError;
  }(RequestError);

  exports.CacheError = CacheError;
  /**
  An error to be thrown when the request body is a stream and an error occurs while reading from that stream.
  */

  var UploadError = /*#__PURE__*/function (_RequestError4) {
    _inherits(UploadError, _RequestError4);

    var _super5 = _createSuper$2(UploadError);

    function UploadError(error, request) {
      var _this5;

      _classCallCheck(this, UploadError);

      _this5 = _super5.call(this, error.message, error, request);
      _this5.name = 'UploadError';
      return _this5;
    }

    return UploadError;
  }(RequestError);

  exports.UploadError = UploadError;
  /**
  An error to be thrown when the request is aborted due to a timeout.
  Includes an `event` and `timings` property.
  */

  var TimeoutError = /*#__PURE__*/function (_RequestError5) {
    _inherits(TimeoutError, _RequestError5);

    var _super6 = _createSuper$2(TimeoutError);

    function TimeoutError(error, timings, request) {
      var _this6;

      _classCallCheck(this, TimeoutError);

      _this6 = _super6.call(this, error.message, error, request);
      _this6.name = 'TimeoutError';
      _this6.event = error.event;
      _this6.timings = timings;
      return _this6;
    }

    return TimeoutError;
  }(RequestError);

  exports.TimeoutError = TimeoutError;
  /**
  An error to be thrown when reading from response stream fails.
  */

  var ReadError = /*#__PURE__*/function (_RequestError6) {
    _inherits(ReadError, _RequestError6);

    var _super7 = _createSuper$2(ReadError);

    function ReadError(error, request) {
      var _this7;

      _classCallCheck(this, ReadError);

      _this7 = _super7.call(this, error.message, error, request);
      _this7.name = 'ReadError';
      return _this7;
    }

    return ReadError;
  }(RequestError);

  exports.ReadError = ReadError;
  /**
  An error to be thrown when given an unsupported protocol.
  */

  var UnsupportedProtocolError = /*#__PURE__*/function (_RequestError7) {
    _inherits(UnsupportedProtocolError, _RequestError7);

    var _super8 = _createSuper$2(UnsupportedProtocolError);

    function UnsupportedProtocolError(options) {
      var _this8;

      _classCallCheck(this, UnsupportedProtocolError);

      _this8 = _super8.call(this, "Unsupported protocol \"".concat(options.url.protocol, "\""), {}, options);
      _this8.name = 'UnsupportedProtocolError';
      return _this8;
    }

    return UnsupportedProtocolError;
  }(RequestError);

  exports.UnsupportedProtocolError = UnsupportedProtocolError;
  var proxiedRequestEvents = ['socket', 'connect', 'continue', 'information', 'upgrade', 'timeout'];

  var Request = /*#__PURE__*/function (_stream_1$Duplex) {
    _inherits(Request, _stream_1$Duplex);

    var _super9 = _createSuper$2(Request);

    function Request(url) {
      var _this9;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var defaults = arguments.length > 2 ? arguments[2] : undefined;

      _classCallCheck(this, Request);

      _this9 = _super9.call(this, {
        // This must be false, to enable throwing after destroy
        // It is used for retry logic in Promise API
        autoDestroy: false,
        // It needs to be zero because we're just proxying the data to another stream
        highWaterMark: 0
      });
      _this9[kDownloadedSize] = 0;
      _this9[kUploadedSize] = 0;
      _this9.requestInitialized = false;
      _this9[kServerResponsesPiped] = new Set();
      _this9.redirects = [];
      _this9[kStopReading] = false;
      _this9[kTriggerRead] = false;
      _this9[kJobs] = [];
      _this9.retryCount = 0; // TODO: Remove this when targeting Node.js >= 12

      _this9._progressCallbacks = [];

      var unlockWrite = function unlockWrite() {
        return _this9._unlockWrite();
      };

      var lockWrite = function lockWrite() {
        return _this9._lockWrite();
      };

      _this9.on('pipe', function (source) {
        source.prependListener('data', unlockWrite);
        source.on('data', lockWrite);
        source.prependListener('end', unlockWrite);
        source.on('end', lockWrite);
      });

      _this9.on('unpipe', function (source) {
        source.off('data', unlockWrite);
        source.off('data', lockWrite);
        source.off('end', unlockWrite);
        source.off('end', lockWrite);
      });

      _this9.on('pipe', function (source) {
        if (source instanceof http_1.IncomingMessage) {
          _this9.options.headers = _objectSpread$2(_objectSpread$2({}, source.headers), _this9.options.headers);
        }
      });

      var json = options.json,
          body = options.body,
          form = options.form;

      if (json || body || form) {
        _this9._lockWrite();
      }

      if (exports.kIsNormalizedAlready in options) {
        _this9.options = options;
      } else {
        try {
          // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible
          _this9.options = _this9.constructor.normalizeArguments(url, options, defaults);
        } catch (error) {
          // TODO: Move this to `_destroy()`
          if (dist$1.default.nodeStream(options.body)) {
            options.body.destroy();
          }

          _this9.destroy(error);

          return _possibleConstructorReturn(_this9);
        }
      }

      _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var _a, normalizedURL, _iterator3, _step3, job;

        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;

                if (!(_this9.options.body instanceof fs.ReadStream)) {
                  _context2.next = 4;
                  break;
                }

                _context2.next = 4;
                return waitForOpenFile(_this9.options.body);

              case 4:
                normalizedURL = _this9.options.url;

                if (normalizedURL) {
                  _context2.next = 7;
                  break;
                }

                throw new TypeError('Missing `url` property');

              case 7:
                _this9.requestUrl = normalizedURL.toString();
                decodeURI(_this9.requestUrl);
                _context2.next = 11;
                return _this9._finalizeBody();

              case 11:
                _context2.next = 13;
                return _this9._makeRequest();

              case 13:
                if (!_this9.destroyed) {
                  _context2.next = 16;
                  break;
                }

                (_a = _this9[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();
                return _context2.abrupt("return");

              case 16:
                // Queued writes etc.
                _iterator3 = _createForOfIteratorHelper$4(_this9[kJobs]);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    job = _step3.value;
                    job();
                  } // Prevent memory leak

                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                _this9[kJobs].length = 0;
                _this9.requestInitialized = true;
                _context2.next = 28;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](0);

                if (!(_context2.t0 instanceof RequestError)) {
                  _context2.next = 27;
                  break;
                }

                _this9._beforeError(_context2.t0);

                return _context2.abrupt("return");

              case 27:
                // This is a workaround for https://github.com/nodejs/node/issues/33335
                if (!_this9.destroyed) {
                  _this9.destroy(_context2.t0);
                }

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 22]]);
      }))();

      return _this9;
    }

    _createClass(Request, [{
      key: "_lockWrite",
      value: function _lockWrite() {
        var onLockedWrite = function onLockedWrite() {
          throw new TypeError('The payload has been already provided');
        };

        this.write = onLockedWrite;
        this.end = onLockedWrite;
      }
    }, {
      key: "_unlockWrite",
      value: function _unlockWrite() {
        this.write = _get(_getPrototypeOf(Request.prototype), "write", this);
        this.end = _get(_getPrototypeOf(Request.prototype), "end", this);
      }
    }, {
      key: "_finalizeBody",
      value: function () {
        var _finalizeBody2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var options, headers, isForm, isJSON, isBody, hasPayload, cannotHaveBody, noContentType, uploadBodySize;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  options = this.options;
                  headers = options.headers;
                  isForm = !dist$1.default.undefined(options.form);
                  isJSON = !dist$1.default.undefined(options.json);
                  isBody = !dist$1.default.undefined(options.body);
                  hasPayload = isForm || isJSON || isBody;
                  cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);
                  this._cannotHaveBody = cannotHaveBody;

                  if (!hasPayload) {
                    _context3.next = 25;
                    break;
                  }

                  if (!cannotHaveBody) {
                    _context3.next = 11;
                    break;
                  }

                  throw new TypeError("The `".concat(options.method, "` method cannot be used with a body"));

                case 11:
                  if (!([isBody, isForm, isJSON].filter(function (isTrue) {
                    return isTrue;
                  }).length > 1)) {
                    _context3.next = 13;
                    break;
                  }

                  throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');

                case 13:
                  if (!(isBody && !(options.body instanceof require$$0$4.Readable) && !dist$1.default.string(options.body) && !dist$1.default.buffer(options.body) && !isFormData.default(options.body))) {
                    _context3.next = 15;
                    break;
                  }

                  throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');

                case 15:
                  if (!(isForm && !dist$1.default.object(options.form))) {
                    _context3.next = 17;
                    break;
                  }

                  throw new TypeError('The `form` option must be an Object');

                case 17:
                  // Serialize body
                  noContentType = !dist$1.default.string(headers['content-type']);

                  if (isBody) {
                    // Special case for https://github.com/form-data/form-data
                    if (isFormData.default(options.body) && noContentType) {
                      headers['content-type'] = "multipart/form-data; boundary=".concat(options.body.getBoundary());
                    }

                    this[kBody] = options.body;
                  } else if (isForm) {
                    if (noContentType) {
                      headers['content-type'] = 'application/x-www-form-urlencoded';
                    }

                    this[kBody] = new url_1.URLSearchParams(options.form).toString();
                  } else {
                    if (noContentType) {
                      headers['content-type'] = 'application/json';
                    }

                    this[kBody] = options.stringifyJson(options.json);
                  }

                  _context3.next = 21;
                  return getBodySize.default(this[kBody], options.headers);

                case 21:
                  uploadBodySize = _context3.sent;

                  // See https://tools.ietf.org/html/rfc7230#section-3.3.2
                  // A user agent SHOULD send a Content-Length in a request message when
                  // no Transfer-Encoding is sent and the request method defines a meaning
                  // for an enclosed payload body.  For example, a Content-Length header
                  // field is normally sent in a POST request even when the value is 0
                  // (indicating an empty payload body).  A user agent SHOULD NOT send a
                  // Content-Length header field when the request message does not contain
                  // a payload body and the method semantics do not anticipate such a
                  // body.
                  if (dist$1.default.undefined(headers['content-length']) && dist$1.default.undefined(headers['transfer-encoding'])) {
                    if (!cannotHaveBody && !dist$1.default.undefined(uploadBodySize)) {
                      headers['content-length'] = String(uploadBodySize);
                    }
                  }

                  _context3.next = 26;
                  break;

                case 25:
                  if (cannotHaveBody) {
                    this._lockWrite();
                  } else {
                    this._unlockWrite();
                  }

                case 26:
                  this[kBodySize] = Number(headers['content-length']) || undefined;

                case 27:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function _finalizeBody() {
          return _finalizeBody2.apply(this, arguments);
        }

        return _finalizeBody;
      }()
    }, {
      key: "_onResponseBase",
      value: function () {
        var _onResponseBase2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(response) {
          var _this10 = this;

          var options, url, statusCode, typedResponse, rawCookies, promises, shouldBeGet, redirectBuffer, redirectUrl, redirectString, _iterator4, _step4, hook, _iterator5, _step5, destination, key, isAllowed, value;

          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  options = this.options;
                  url = options.url;
                  this[kOriginalResponse] = response;

                  if (options.decompress) {
                    response = decompressResponse(response);
                  }

                  statusCode = response.statusCode;
                  typedResponse = response;
                  typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
                  typedResponse.url = options.url.toString();
                  typedResponse.requestUrl = this.requestUrl;
                  typedResponse.redirectUrls = this.redirects;
                  typedResponse.request = this;
                  typedResponse.isFromCache = response.fromCache || false;
                  typedResponse.ip = this.ip;
                  typedResponse.retryCount = this.retryCount;
                  this[kIsFromCache] = typedResponse.isFromCache;
                  this[kResponseSize] = Number(response.headers['content-length']) || undefined;
                  this[kResponse] = response;
                  response.once('end', function () {
                    _this10[kResponseSize] = _this10[kDownloadedSize];

                    _this10.emit('downloadProgress', _this10.downloadProgress);
                  });
                  response.once('error', function (error) {
                    // Force clean-up, because some packages don't do this.
                    // TODO: Fix decompress-response
                    response.destroy();

                    _this10._beforeError(new ReadError(error, _this10));
                  });
                  response.once('aborted', function () {
                    _this10._beforeError(new ReadError({
                      name: 'Error',
                      message: 'The server aborted pending request',
                      code: 'ECONNRESET'
                    }, _this10));
                  });
                  this.emit('downloadProgress', this.downloadProgress);
                  rawCookies = response.headers['set-cookie'];

                  if (!(dist$1.default.object(options.cookieJar) && rawCookies)) {
                    _context6.next = 34;
                    break;
                  }

                  promises = rawCookies.map( /*#__PURE__*/function () {
                    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(rawCookie) {
                      return regenerator.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              return _context4.abrupt("return", options.cookieJar.setCookie(rawCookie, url.toString()));

                            case 1:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));

                    return function (_x3) {
                      return _ref3.apply(this, arguments);
                    };
                  }());

                  if (options.ignoreInvalidCookies) {
                    promises = promises.map( /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(p) {
                        return regenerator.wrap(function _callee5$(_context5) {
                          while (1) {
                            switch (_context5.prev = _context5.next) {
                              case 0:
                                return _context5.abrupt("return", p.catch(function () {}));

                              case 1:
                              case "end":
                                return _context5.stop();
                            }
                          }
                        }, _callee5);
                      }));

                      return function (_x4) {
                        return _ref4.apply(this, arguments);
                      };
                    }());
                  }

                  _context6.prev = 25;
                  _context6.next = 28;
                  return Promise.all(promises);

                case 28:
                  _context6.next = 34;
                  break;

                case 30:
                  _context6.prev = 30;
                  _context6.t0 = _context6["catch"](25);

                  this._beforeError(_context6.t0);

                  return _context6.abrupt("return");

                case 34:
                  if (!(options.followRedirect && response.headers.location && redirectCodes.has(statusCode))) {
                    _context6.next = 77;
                    break;
                  }

                  // We're being redirected, we don't care about the response.
                  // It'd be best to abort the request, but we can't because
                  // we would have to sacrifice the TCP connection. We don't want that.
                  response.resume();

                  if (this[kRequest]) {
                    this[kCancelTimeouts](); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete

                    delete this[kRequest];
                    this[kUnproxyEvents]();
                  }

                  shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';

                  if (shouldBeGet || !options.methodRewriting) {
                    // Server responded with "see other", indicating that the resource exists at another location,
                    // and the client should request it from that location via GET or HEAD.
                    options.method = 'GET';

                    if ('body' in options) {
                      delete options.body;
                    }

                    if ('json' in options) {
                      delete options.json;
                    }

                    if ('form' in options) {
                      delete options.form;
                    }

                    this[kBody] = undefined;
                    delete options.headers['content-length'];
                  }

                  if (!(this.redirects.length >= options.maxRedirects)) {
                    _context6.next = 42;
                    break;
                  }

                  this._beforeError(new MaxRedirectsError(this));

                  return _context6.abrupt("return");

                case 42:
                  _context6.prev = 42;
                  // Do not remove. See https://github.com/sindresorhus/got/pull/214
                  redirectBuffer = Buffer.from(response.headers.location, 'binary').toString(); // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604

                  redirectUrl = new url_1.URL(redirectBuffer, url);
                  redirectString = redirectUrl.toString();

                  if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
                    if ('host' in options.headers) {
                      delete options.headers.host;
                    }

                    if ('cookie' in options.headers) {
                      delete options.headers.cookie;
                    }

                    if ('authorization' in options.headers) {
                      delete options.headers.authorization;
                    }

                    if (options.username || options.password) {
                      options.username = '';
                      options.password = '';
                    }
                  } else {
                    redirectUrl.username = options.username;
                    redirectUrl.password = options.password;
                  }

                  this.redirects.push(redirectString);
                  options.url = redirectUrl;
                  _iterator4 = _createForOfIteratorHelper$4(options.hooks.beforeRedirect);
                  _context6.prev = 51;

                  _iterator4.s();

                case 53:
                  if ((_step4 = _iterator4.n()).done) {
                    _context6.next = 59;
                    break;
                  }

                  hook = _step4.value;
                  _context6.next = 57;
                  return hook(options, typedResponse);

                case 57:
                  _context6.next = 53;
                  break;

                case 59:
                  _context6.next = 64;
                  break;

                case 61:
                  _context6.prev = 61;
                  _context6.t1 = _context6["catch"](51);

                  _iterator4.e(_context6.t1);

                case 64:
                  _context6.prev = 64;

                  _iterator4.f();

                  return _context6.finish(64);

                case 67:
                  this.emit('redirect', typedResponse, options);
                  _context6.next = 70;
                  return this._makeRequest();

                case 70:
                  _context6.next = 76;
                  break;

                case 72:
                  _context6.prev = 72;
                  _context6.t2 = _context6["catch"](42);

                  this._beforeError(_context6.t2);

                  return _context6.abrupt("return");

                case 76:
                  return _context6.abrupt("return");

                case 77:
                  if (!(options.isStream && options.throwHttpErrors && !isResponseOk.isResponseOk(typedResponse))) {
                    _context6.next = 80;
                    break;
                  }

                  this._beforeError(new HTTPError(typedResponse));

                  return _context6.abrupt("return");

                case 80:
                  response.on('readable', function () {
                    if (_this10[kTriggerRead]) {
                      _this10._read();
                    }
                  });
                  this.on('resume', function () {
                    response.resume();
                  });
                  this.on('pause', function () {
                    response.pause();
                  });
                  response.once('end', function () {
                    _this10.push(null);
                  });
                  this.emit('response', response);
                  _iterator5 = _createForOfIteratorHelper$4(this[kServerResponsesPiped]);
                  _context6.prev = 86;

                  _iterator5.s();

                case 88:
                  if ((_step5 = _iterator5.n()).done) {
                    _context6.next = 96;
                    break;
                  }

                  destination = _step5.value;

                  if (!destination.headersSent) {
                    _context6.next = 92;
                    break;
                  }

                  return _context6.abrupt("continue", 94);

                case 92:
                  // eslint-disable-next-line guard-for-in
                  for (key in response.headers) {
                    isAllowed = options.decompress ? key !== 'content-encoding' : true;
                    value = response.headers[key];

                    if (isAllowed) {
                      destination.setHeader(key, value);
                    }
                  }

                  destination.statusCode = statusCode;

                case 94:
                  _context6.next = 88;
                  break;

                case 96:
                  _context6.next = 101;
                  break;

                case 98:
                  _context6.prev = 98;
                  _context6.t3 = _context6["catch"](86);

                  _iterator5.e(_context6.t3);

                case 101:
                  _context6.prev = 101;

                  _iterator5.f();

                  return _context6.finish(101);

                case 104:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this, [[25, 30], [42, 72], [51, 61, 64, 67], [86, 98, 101, 104]]);
        }));

        function _onResponseBase(_x2) {
          return _onResponseBase2.apply(this, arguments);
        }

        return _onResponseBase;
      }()
    }, {
      key: "_onResponse",
      value: function () {
        var _onResponse2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(response) {
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.prev = 0;
                  _context7.next = 3;
                  return this._onResponseBase(response);

                case 3:
                  _context7.next = 8;
                  break;

                case 5:
                  _context7.prev = 5;
                  _context7.t0 = _context7["catch"](0);

                  /* istanbul ignore next: better safe than sorry */
                  this._beforeError(_context7.t0);

                case 8:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this, [[0, 5]]);
        }));

        function _onResponse(_x5) {
          return _onResponse2.apply(this, arguments);
        }

        return _onResponse;
      }()
    }, {
      key: "_onRequest",
      value: function _onRequest(request) {
        var _this11 = this;

        var options = this.options;
        var timeout = options.timeout,
            url = options.url;
        source$3.default(request);
        this[kCancelTimeouts] = timedOut.default(request, timeout, url);
        var responseEventName = options.cache ? 'cacheableResponse' : 'response';
        request.once(responseEventName, function (response) {
          void _this11._onResponse(response);
        });
        request.once('error', function (error) {
          var _a; // Force clean-up, because some packages (e.g. nock) don't do this.


          request.destroy(); // Node.js <= 12.18.2 mistakenly emits the response `end` first.

          (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners('end');
          error = error instanceof timedOut.TimeoutError ? new TimeoutError(error, _this11.timings, _this11) : new RequestError(error.message, error, _this11);

          _this11._beforeError(error);
        });
        this[kUnproxyEvents] = proxyEvents.default(request, this, proxiedRequestEvents);
        this[kRequest] = request;
        this.emit('uploadProgress', this.uploadProgress); // Send body

        var body = this[kBody];
        var currentRequest = this.redirects.length === 0 ? this : request;

        if (dist$1.default.nodeStream(body)) {
          body.pipe(currentRequest);
          body.once('error', function (error) {
            _this11._beforeError(new UploadError(error, _this11));
          });
        } else {
          this._unlockWrite();

          if (!dist$1.default.undefined(body)) {
            this._writeRequest(body, undefined, function () {});

            currentRequest.end();

            this._lockWrite();
          } else if (this._cannotHaveBody || this._noPipe) {
            currentRequest.end();

            this._lockWrite();
          }
        }

        this.emit('request', request);
      }
    }, {
      key: "_createCacheableRequest",
      value: function () {
        var _createCacheableRequest2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10(url, options) {
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  return _context10.abrupt("return", new Promise(function (resolve, reject) {
                    // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
                    Object.assign(options, urlToOptions.default(url)); // `http-cache-semantics` checks this
                    // TODO: Fix this ignore.
                    // @ts-expect-error

                    // `http-cache-semantics` checks this
                    // TODO: Fix this ignore.
                    // @ts-expect-error
                    delete options.url;
                    var request; // This is ugly

                    // This is ugly
                    var cacheRequest = cacheableStore.get(options.cache)(options, /*#__PURE__*/function () {
                      var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(response) {
                        return regenerator.wrap(function _callee8$(_context8) {
                          while (1) {
                            switch (_context8.prev = _context8.next) {
                              case 0:
                                // TODO: Fix `cacheable-response`
                                response._readableState.autoDestroy = false;

                                if (!request) {
                                  _context8.next = 5;
                                  break;
                                }

                                _context8.next = 4;
                                return request;

                              case 4:
                                _context8.sent.emit('cacheableResponse', response);

                              case 5:
                                resolve(response);

                              case 6:
                              case "end":
                                return _context8.stop();
                            }
                          }
                        }, _callee8);
                      }));

                      return function (_x8) {
                        return _ref5.apply(this, arguments);
                      };
                    }()); // Restore options

                    // Restore options
                    options.url = url;
                    cacheRequest.once('error', reject);
                    cacheRequest.once('request', /*#__PURE__*/function () {
                      var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9(requestOrPromise) {
                        return regenerator.wrap(function _callee9$(_context9) {
                          while (1) {
                            switch (_context9.prev = _context9.next) {
                              case 0:
                                request = requestOrPromise;
                                resolve(request);

                              case 2:
                              case "end":
                                return _context9.stop();
                            }
                          }
                        }, _callee9);
                      }));

                      return function (_x9) {
                        return _ref6.apply(this, arguments);
                      };
                    }());
                  }));

                case 1:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));

        function _createCacheableRequest(_x6, _x7) {
          return _createCacheableRequest2.apply(this, arguments);
        }

        return _createCacheableRequest;
      }()
    }, {
      key: "_makeRequest",
      value: function () {
        var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
          var _this12 = this;

          var _a, _b, _c, _d, _e, options, headers, key, cookieString, _iterator6, _step6, _loop, _ret, agent, request, timeout, url, matches, _matches$groups, socketPath, path, isHttps, fallbackFn, realFn, fn, requestOptions, requestOrResponse;

          return regenerator.wrap(function _callee11$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  options = this.options;
                  headers = options.headers;
                  _context12.t0 = regenerator.keys(headers);

                case 3:
                  if ((_context12.t1 = _context12.t0()).done) {
                    _context12.next = 13;
                    break;
                  }

                  key = _context12.t1.value;

                  if (!dist$1.default.undefined(headers[key])) {
                    _context12.next = 9;
                    break;
                  }

                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                  delete headers[key];
                  _context12.next = 11;
                  break;

                case 9:
                  if (!dist$1.default.null_(headers[key])) {
                    _context12.next = 11;
                    break;
                  }

                  throw new TypeError("Use `undefined` instead of `null` to delete the `".concat(key, "` header"));

                case 11:
                  _context12.next = 3;
                  break;

                case 13:
                  if (options.decompress && dist$1.default.undefined(headers['accept-encoding'])) {
                    headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';
                  } // Set cookies


                  if (!options.cookieJar) {
                    _context12.next = 19;
                    break;
                  }

                  _context12.next = 17;
                  return options.cookieJar.getCookieString(options.url.toString());

                case 17:
                  cookieString = _context12.sent;

                  if (dist$1.default.nonEmptyString(cookieString)) {
                    options.headers.cookie = cookieString;
                  }

                case 19:
                  _iterator6 = _createForOfIteratorHelper$4(options.hooks.beforeRequest);
                  _context12.prev = 20;
                  _loop = /*#__PURE__*/regenerator.mark(function _loop() {
                    var hook, result;
                    return regenerator.wrap(function _loop$(_context11) {
                      while (1) {
                        switch (_context11.prev = _context11.next) {
                          case 0:
                            hook = _step6.value;
                            _context11.next = 3;
                            return hook(options);

                          case 3:
                            result = _context11.sent;

                            if (dist$1.default.undefined(result)) {
                              _context11.next = 7;
                              break;
                            }

                            // @ts-expect-error Skip the type mismatch to support abstract responses
                            options.request = function () {
                              return result;
                            };

                            return _context11.abrupt("return", "break");

                          case 7:
                          case "end":
                            return _context11.stop();
                        }
                      }
                    }, _loop);
                  });

                  _iterator6.s();

                case 23:
                  if ((_step6 = _iterator6.n()).done) {
                    _context12.next = 30;
                    break;
                  }

                  return _context12.delegateYield(_loop(), "t2", 25);

                case 25:
                  _ret = _context12.t2;

                  if (!(_ret === "break")) {
                    _context12.next = 28;
                    break;
                  }

                  return _context12.abrupt("break", 30);

                case 28:
                  _context12.next = 23;
                  break;

                case 30:
                  _context12.next = 35;
                  break;

                case 32:
                  _context12.prev = 32;
                  _context12.t3 = _context12["catch"](20);

                  _iterator6.e(_context12.t3);

                case 35:
                  _context12.prev = 35;

                  _iterator6.f();

                  return _context12.finish(35);

                case 38:
                  if (options.body && this[kBody] !== options.body) {
                    this[kBody] = options.body;
                  }

                  agent = options.agent, request = options.request, timeout = options.timeout, url = options.url;

                  if (options.dnsCache && !('lookup' in options)) {
                    options.lookup = options.dnsCache.lookup;
                  } // UNIX sockets


                  if (url.hostname === 'unix') {
                    matches = /*#__PURE__*/_wrapRegExp(/(.+?):(.+)/, {
                      socketPath: 1,
                      path: 2
                    }).exec("".concat(url.pathname).concat(url.search));

                    if (matches === null || matches === void 0 ? void 0 : matches.groups) {
                      _matches$groups = matches.groups, socketPath = _matches$groups.socketPath, path = _matches$groups.path;
                      Object.assign(options, {
                        socketPath: socketPath,
                        path: path,
                        host: ''
                      });
                    }
                  }

                  isHttps = url.protocol === 'https:'; // Fallback function

                  if (options.http2) {
                    fallbackFn = source$1.auto;
                  } else {
                    fallbackFn = isHttps ? https.request : http.request;
                  }

                  realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn; // Cache support

                  fn = options.cache ? this._createCacheableRequest : realFn; // Pass an agent directly when HTTP2 is disabled

                  if (agent && !options.http2) {
                    options.agent = agent[isHttps ? 'https' : 'http'];
                  } // Prepare plain HTTP request options


                  options[kRequest] = realFn;
                  delete options.request; // TODO: Fix this ignore.
                  // @ts-expect-error

                  delete options.timeout;
                  requestOptions = options;
                  requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
                  requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
                  requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
                  requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult; // If `dnsLookupIpVersion` is not present do not override `family`

                  if (!(options.dnsLookupIpVersion !== undefined)) {
                    _context12.next = 63;
                    break;
                  }

                  _context12.prev = 56;
                  requestOptions.family = dnsIpVersion.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
                  _context12.next = 63;
                  break;

                case 60:
                  _context12.prev = 60;
                  _context12.t4 = _context12["catch"](56);
                  throw new Error('Invalid `dnsLookupIpVersion` option value');

                case 63:
                  // HTTPS options remapping
                  if (options.https) {
                    if ('rejectUnauthorized' in options.https) {
                      requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
                    }

                    if (options.https.checkServerIdentity) {
                      requestOptions.checkServerIdentity = options.https.checkServerIdentity;
                    }

                    if (options.https.certificateAuthority) {
                      requestOptions.ca = options.https.certificateAuthority;
                    }

                    if (options.https.certificate) {
                      requestOptions.cert = options.https.certificate;
                    }

                    if (options.https.key) {
                      requestOptions.key = options.https.key;
                    }

                    if (options.https.passphrase) {
                      requestOptions.passphrase = options.https.passphrase;
                    }

                    if (options.https.pfx) {
                      requestOptions.pfx = options.https.pfx;
                    }
                  }

                  _context12.prev = 64;
                  _context12.next = 67;
                  return fn(url, requestOptions);

                case 67:
                  requestOrResponse = _context12.sent;

                  if (dist$1.default.undefined(requestOrResponse)) {
                    requestOrResponse = fallbackFn(url, requestOptions);
                  } // Restore options


                  options.request = request;
                  options.timeout = timeout;
                  options.agent = agent; // HTTPS options restore

                  if (options.https) {
                    if ('rejectUnauthorized' in options.https) {
                      delete requestOptions.rejectUnauthorized;
                    }

                    if (options.https.checkServerIdentity) {
                      // @ts-expect-error - This one will be removed when we remove the alias.
                      delete requestOptions.checkServerIdentity;
                    }

                    if (options.https.certificateAuthority) {
                      delete requestOptions.ca;
                    }

                    if (options.https.certificate) {
                      delete requestOptions.cert;
                    }

                    if (options.https.key) {
                      delete requestOptions.key;
                    }

                    if (options.https.passphrase) {
                      delete requestOptions.passphrase;
                    }

                    if (options.https.pfx) {
                      delete requestOptions.pfx;
                    }
                  }

                  if (isClientRequest(requestOrResponse)) {
                    this._onRequest(requestOrResponse); // Emit the response after the stream has been ended

                  } else if (this.writable) {
                    this.once('finish', function () {
                      void _this12._onResponse(requestOrResponse);
                    });

                    this._unlockWrite();

                    this.end();

                    this._lockWrite();
                  } else {
                    void this._onResponse(requestOrResponse);
                  }

                  _context12.next = 81;
                  break;

                case 76:
                  _context12.prev = 76;
                  _context12.t5 = _context12["catch"](64);

                  if (!(_context12.t5 instanceof src.CacheError)) {
                    _context12.next = 80;
                    break;
                  }

                  throw new CacheError(_context12.t5, this);

                case 80:
                  throw new RequestError(_context12.t5.message, _context12.t5, this);

                case 81:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee11, this, [[20, 32, 35, 38], [56, 60], [64, 76]]);
        }));

        function _makeRequest() {
          return _makeRequest2.apply(this, arguments);
        }

        return _makeRequest;
      }()
    }, {
      key: "_error",
      value: function () {
        var _error2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12(error) {
          var _iterator7, _step7, hook;

          return regenerator.wrap(function _callee12$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  _context13.prev = 0;
                  _iterator7 = _createForOfIteratorHelper$4(this.options.hooks.beforeError);
                  _context13.prev = 2;

                  _iterator7.s();

                case 4:
                  if ((_step7 = _iterator7.n()).done) {
                    _context13.next = 11;
                    break;
                  }

                  hook = _step7.value;
                  _context13.next = 8;
                  return hook(error);

                case 8:
                  error = _context13.sent;

                case 9:
                  _context13.next = 4;
                  break;

                case 11:
                  _context13.next = 16;
                  break;

                case 13:
                  _context13.prev = 13;
                  _context13.t0 = _context13["catch"](2);

                  _iterator7.e(_context13.t0);

                case 16:
                  _context13.prev = 16;

                  _iterator7.f();

                  return _context13.finish(16);

                case 19:
                  _context13.next = 24;
                  break;

                case 21:
                  _context13.prev = 21;
                  _context13.t1 = _context13["catch"](0);
                  error = new RequestError(_context13.t1.message, _context13.t1, this);

                case 24:
                  this.destroy(error);

                case 25:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee12, this, [[0, 21], [2, 13, 16, 19]]);
        }));

        function _error(_x10) {
          return _error2.apply(this, arguments);
        }

        return _error;
      }()
    }, {
      key: "_beforeError",
      value: function _beforeError(error) {
        var _this13 = this;

        if (this[kStopReading]) {
          return;
        }

        var options = this.options;
        var retryCount = this.retryCount + 1;
        this[kStopReading] = true;

        if (!(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }

        var typedError = error;
        var response = typedError.response;
        void _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14() {
          var backoff, retryAfter, retry;
          return regenerator.wrap(function _callee14$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  if (!(response && !response.body)) {
                    _context15.next = 11;
                    break;
                  }

                  response.setEncoding(_this13._readableState.encoding);
                  _context15.prev = 2;
                  _context15.next = 5;
                  return getBuffer_1.default(response);

                case 5:
                  response.rawBody = _context15.sent;
                  response.body = response.rawBody.toString();
                  _context15.next = 11;
                  break;

                case 9:
                  _context15.prev = 9;
                  _context15.t0 = _context15["catch"](2);

                case 11:
                  if (!(_this13.listenerCount('retry') !== 0)) {
                    _context15.next = 27;
                    break;
                  }

                  _context15.prev = 12;

                  if (response && 'retry-after' in response.headers) {
                    retryAfter = Number(response.headers['retry-after']);

                    if (Number.isNaN(retryAfter)) {
                      retryAfter = Date.parse(response.headers['retry-after']) - Date.now();

                      if (retryAfter <= 0) {
                        retryAfter = 1;
                      }
                    } else {
                      retryAfter *= 1000;
                    }
                  }

                  _context15.next = 16;
                  return options.retry.calculateDelay({
                    attemptCount: retryCount,
                    retryOptions: options.retry,
                    error: typedError,
                    retryAfter: retryAfter,
                    computedValue: calculateRetryDelay_1.default({
                      attemptCount: retryCount,
                      retryOptions: options.retry,
                      error: typedError,
                      retryAfter: retryAfter,
                      computedValue: 0
                    })
                  });

                case 16:
                  backoff = _context15.sent;
                  _context15.next = 23;
                  break;

                case 19:
                  _context15.prev = 19;
                  _context15.t1 = _context15["catch"](12);
                  void _this13._error(new RequestError(_context15.t1.message, _context15.t1, _this13));
                  return _context15.abrupt("return");

                case 23:
                  if (!backoff) {
                    _context15.next = 27;
                    break;
                  }

                  retry = /*#__PURE__*/function () {
                    var _ref8 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13() {
                      var _iterator8, _step8, hook;

                      return regenerator.wrap(function _callee13$(_context14) {
                        while (1) {
                          switch (_context14.prev = _context14.next) {
                            case 0:
                              _context14.prev = 0;
                              _iterator8 = _createForOfIteratorHelper$4(_this13.options.hooks.beforeRetry);
                              _context14.prev = 2;

                              _iterator8.s();

                            case 4:
                              if ((_step8 = _iterator8.n()).done) {
                                _context14.next = 10;
                                break;
                              }

                              hook = _step8.value;
                              _context14.next = 8;
                              return hook(_this13.options, typedError, retryCount);

                            case 8:
                              _context14.next = 4;
                              break;

                            case 10:
                              _context14.next = 15;
                              break;

                            case 12:
                              _context14.prev = 12;
                              _context14.t0 = _context14["catch"](2);

                              _iterator8.e(_context14.t0);

                            case 15:
                              _context14.prev = 15;

                              _iterator8.f();

                              return _context14.finish(15);

                            case 18:
                              _context14.next = 24;
                              break;

                            case 20:
                              _context14.prev = 20;
                              _context14.t1 = _context14["catch"](0);
                              void _this13._error(new RequestError(_context14.t1.message, error, _this13));
                              return _context14.abrupt("return");

                            case 24:
                              if (!_this13.destroyed) {
                                _context14.next = 26;
                                break;
                              }

                              return _context14.abrupt("return");

                            case 26:
                              _this13.destroy();

                              _this13.emit('retry', retryCount, error);

                            case 28:
                            case "end":
                              return _context14.stop();
                          }
                        }
                      }, _callee13, null, [[0, 20], [2, 12, 15, 18]]);
                    }));

                    return function retry() {
                      return _ref8.apply(this, arguments);
                    };
                  }();

                  _this13[kRetryTimeout] = setTimeout(retry, backoff);
                  return _context15.abrupt("return");

                case 27:
                  void _this13._error(typedError);

                case 28:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee14, null, [[2, 9], [12, 19]]);
        }))();
      }
    }, {
      key: "_read",
      value: function _read() {
        this[kTriggerRead] = true;
        var response = this[kResponse];

        if (response && !this[kStopReading]) {
          // We cannot put this in the `if` above
          // because `.read()` also triggers the `end` event
          if (response.readableLength) {
            this[kTriggerRead] = false;
          }

          var data;

          while ((data = response.read()) !== null) {
            this[kDownloadedSize] += data.length;
            this[kStartedReading] = true;
            var progress = this.downloadProgress;

            if (progress.percent < 1) {
              this.emit('downloadProgress', progress);
            }

            this.push(data);
          }
        }
      } // Node.js 12 has incorrect types, so the encoding must be a string

    }, {
      key: "_write",
      value: function _write(chunk, encoding, callback) {
        var _this14 = this;

        var write = function write() {
          _this14._writeRequest(chunk, encoding, callback);
        };

        if (this.requestInitialized) {
          write();
        } else {
          this[kJobs].push(write);
        }
      }
    }, {
      key: "_writeRequest",
      value: function _writeRequest(chunk, encoding, callback) {
        var _this15 = this;

        if (this[kRequest].destroyed) {
          // Probably the `ClientRequest` instance will throw
          return;
        }

        this._progressCallbacks.push(function () {
          _this15[kUploadedSize] += Buffer.byteLength(chunk, encoding);
          var progress = _this15.uploadProgress;

          if (progress.percent < 1) {
            _this15.emit('uploadProgress', progress);
          }
        }); // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.


        this[kRequest].write(chunk, encoding, function (error) {
          if (!error && _this15._progressCallbacks.length > 0) {
            _this15._progressCallbacks.shift()();
          }

          callback(error);
        });
      }
    }, {
      key: "_final",
      value: function _final(callback) {
        var _this16 = this;

        var endRequest = function endRequest() {
          // FIX: Node.js 10 calls the write callback AFTER the end callback!
          while (_this16._progressCallbacks.length !== 0) {
            _this16._progressCallbacks.shift()();
          } // We need to check if `this[kRequest]` is present,
          // because it isn't when we use cache.


          if (!(kRequest in _this16)) {
            callback();
            return;
          }

          if (_this16[kRequest].destroyed) {
            callback();
            return;
          }

          _this16[kRequest].end(function (error) {
            if (!error) {
              _this16[kBodySize] = _this16[kUploadedSize];

              _this16.emit('uploadProgress', _this16.uploadProgress);

              _this16[kRequest].emit('upload-complete');
            }

            callback(error);
          });
        };

        if (this.requestInitialized) {
          endRequest();
        } else {
          this[kJobs].push(endRequest);
        }
      }
    }, {
      key: "_destroy",
      value: function _destroy(error, callback) {
        var _a;

        this[kStopReading] = true; // Prevent further retries

        clearTimeout(this[kRetryTimeout]);

        if (kRequest in this) {
          this[kCancelTimeouts](); // TODO: Remove the next `if` when these get fixed:
          // - https://github.com/nodejs/node/issues/32851

          if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {
            this[kRequest].destroy();
          }
        }

        if (error !== null && !dist$1.default.undefined(error) && !(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }

        callback(error);
      }
    }, {
      key: "_isAboutToError",
      get: function get() {
        return this[kStopReading];
      }
      /**
      The remote IP address.
      */

    }, {
      key: "ip",
      get: function get() {
        var _a;

        return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;
      }
      /**
      Indicates whether the request has been aborted or not.
      */

    }, {
      key: "aborted",
      get: function get() {
        var _a, _b, _c;

        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
      }
    }, {
      key: "socket",
      get: function get() {
        var _a, _b;

        return (_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : undefined;
      }
      /**
      Progress event for downloading (receiving a response).
      */

    }, {
      key: "downloadProgress",
      get: function get() {
        var percent;

        if (this[kResponseSize]) {
          percent = this[kDownloadedSize] / this[kResponseSize];
        } else if (this[kResponseSize] === this[kDownloadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }

        return {
          percent: percent,
          transferred: this[kDownloadedSize],
          total: this[kResponseSize]
        };
      }
      /**
      Progress event for uploading (sending a request).
      */

    }, {
      key: "uploadProgress",
      get: function get() {
        var percent;

        if (this[kBodySize]) {
          percent = this[kUploadedSize] / this[kBodySize];
        } else if (this[kBodySize] === this[kUploadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }

        return {
          percent: percent,
          transferred: this[kUploadedSize],
          total: this[kBodySize]
        };
      }
      /**
      The object contains the following properties:
       - `start` - Time when the request started.
      - `socket` - Time when a socket was assigned to the request.
      - `lookup` - Time when the DNS lookup finished.
      - `connect` - Time when the socket successfully connected.
      - `secureConnect` - Time when the socket securely connected.
      - `upload` - Time when the request finished uploading.
      - `response` - Time when the request fired `response` event.
      - `end` - Time when the response fired `end` event.
      - `error` - Time when the request fired `error` event.
      - `abort` - Time when the request fired `abort` event.
      - `phases`
          - `wait` - `timings.socket - timings.start`
          - `dns` - `timings.lookup - timings.socket`
          - `tcp` - `timings.connect - timings.lookup`
          - `tls` - `timings.secureConnect - timings.connect`
          - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
          - `firstByte` - `timings.response - timings.upload`
          - `download` - `timings.end - timings.response`
          - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
       If something has not been measured yet, it will be `undefined`.
       __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
      */

    }, {
      key: "timings",
      get: function get() {
        var _a;

        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;
      }
      /**
      Whether the response was retrieved from the cache.
      */

    }, {
      key: "isFromCache",
      get: function get() {
        return this[kIsFromCache];
      }
    }, {
      key: "pipe",
      value: function pipe(destination, options) {
        if (this[kStartedReading]) {
          throw new Error('Failed to pipe. The response has been emitted already.');
        }

        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].add(destination);
        }

        return _get(_getPrototypeOf(Request.prototype), "pipe", this).call(this, destination, options);
      }
    }, {
      key: "unpipe",
      value: function unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].delete(destination);
        }

        _get(_getPrototypeOf(Request.prototype), "unpipe", this).call(this, destination);

        return this;
      }
    }], [{
      key: "normalizeArguments",
      value: function normalizeArguments(url, options, defaults) {
        var _a, _b, _c, _d, _e;

        var rawOptions = options;

        if (dist$1.default.object(url) && !dist$1.default.urlInstance(url)) {
          options = _objectSpread$2(_objectSpread$2(_objectSpread$2({}, defaults), url), options);
        } else {
          if (url && options && options.url !== undefined) {
            throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
          }

          options = _objectSpread$2(_objectSpread$2({}, defaults), options);

          if (url !== undefined) {
            options.url = url;
          }

          if (dist$1.default.urlInstance(options.url)) {
            options.url = new url_1.URL(options.url.toString());
          }
        } // TODO: Deprecate URL options in Got 12.
        // Support extend-specific options


        if (options.cache === false) {
          options.cache = undefined;
        }

        if (options.dnsCache === false) {
          options.dnsCache = undefined;
        } // Nice type assertions


        dist$1.assert.any([dist$1.default.string, dist$1.default.undefined], options.method);
        dist$1.assert.any([dist$1.default.object, dist$1.default.undefined], options.headers);
        dist$1.assert.any([dist$1.default.string, dist$1.default.urlInstance, dist$1.default.undefined], options.prefixUrl);
        dist$1.assert.any([dist$1.default.object, dist$1.default.undefined], options.cookieJar);
        dist$1.assert.any([dist$1.default.object, dist$1.default.string, dist$1.default.undefined], options.searchParams);
        dist$1.assert.any([dist$1.default.object, dist$1.default.string, dist$1.default.undefined], options.cache);
        dist$1.assert.any([dist$1.default.object, dist$1.default.number, dist$1.default.undefined], options.timeout);
        dist$1.assert.any([dist$1.default.object, dist$1.default.undefined], options.context);
        dist$1.assert.any([dist$1.default.object, dist$1.default.undefined], options.hooks);
        dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.decompress);
        dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.ignoreInvalidCookies);
        dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.followRedirect);
        dist$1.assert.any([dist$1.default.number, dist$1.default.undefined], options.maxRedirects);
        dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.throwHttpErrors);
        dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.http2);
        dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.allowGetBody);
        dist$1.assert.any([dist$1.default.string, dist$1.default.undefined], options.localAddress);
        dist$1.assert.any([dnsIpVersion.isDnsLookupIpVersion, dist$1.default.undefined], options.dnsLookupIpVersion);
        dist$1.assert.any([dist$1.default.object, dist$1.default.undefined], options.https);
        dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.rejectUnauthorized);

        if (options.https) {
          dist$1.assert.any([dist$1.default.boolean, dist$1.default.undefined], options.https.rejectUnauthorized);
          dist$1.assert.any([dist$1.default.function_, dist$1.default.undefined], options.https.checkServerIdentity);
          dist$1.assert.any([dist$1.default.string, dist$1.default.object, dist$1.default.array, dist$1.default.undefined], options.https.certificateAuthority);
          dist$1.assert.any([dist$1.default.string, dist$1.default.object, dist$1.default.array, dist$1.default.undefined], options.https.key);
          dist$1.assert.any([dist$1.default.string, dist$1.default.object, dist$1.default.array, dist$1.default.undefined], options.https.certificate);
          dist$1.assert.any([dist$1.default.string, dist$1.default.undefined], options.https.passphrase);
          dist$1.assert.any([dist$1.default.string, dist$1.default.buffer, dist$1.default.array, dist$1.default.undefined], options.https.pfx);
        }

        dist$1.assert.any([dist$1.default.object, dist$1.default.undefined], options.cacheOptions); // `options.method`

        if (dist$1.default.string(options.method)) {
          options.method = options.method.toUpperCase();
        } else {
          options.method = 'GET';
        } // `options.headers`


        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
          options.headers = _objectSpread$2({}, options.headers);
        } else {
          options.headers = lowercaseKeys(_objectSpread$2(_objectSpread$2({}, defaults === null || defaults === void 0 ? void 0 : defaults.headers), options.headers));
        } // Disallow legacy `url.Url`


        if ('slashes' in options) {
          throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');
        } // `options.auth`


        if ('auth' in options) {
          throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');
        } // `options.searchParams`


        if ('searchParams' in options) {
          if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
            var searchParameters;

            if (dist$1.default.string(options.searchParams) || options.searchParams instanceof url_1.URLSearchParams) {
              searchParameters = new url_1.URLSearchParams(options.searchParams);
            } else {
              validateSearchParameters(options.searchParams);
              searchParameters = new url_1.URLSearchParams(); // eslint-disable-next-line guard-for-in

              for (var key in options.searchParams) {
                var value = options.searchParams[key];

                if (value === null) {
                  searchParameters.append(key, '');
                } else if (value !== undefined) {
                  searchParameters.append(key, value);
                }
              }
            } // `normalizeArguments()` is also used to merge options


            (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach(function (value, key) {
              // Only use default if one isn't already defined
              if (!searchParameters.has(key)) {
                searchParameters.append(key, value);
              }
            });
            options.searchParams = searchParameters;
          }
        } // `options.username` & `options.password`


        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';
        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : ''; // `options.prefixUrl` & `options.url`

        if (dist$1.default.undefined(options.prefixUrl)) {
          options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : '';
        } else {
          options.prefixUrl = options.prefixUrl.toString();

          if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {
            options.prefixUrl += '/';
          }
        }

        if (dist$1.default.string(options.url)) {
          if (options.url.startsWith('/')) {
            throw new Error('`input` must not start with a slash when using `prefixUrl`');
          }

          options.url = optionsToUrl.default(options.prefixUrl + options.url, options);
        } else if (dist$1.default.undefined(options.url) && options.prefixUrl !== '' || options.protocol) {
          options.url = optionsToUrl.default(options.prefixUrl, options);
        }

        if (options.url) {
          if ('port' in options) {
            delete options.port;
          } // Make it possible to change `options.prefixUrl`


          var _options = options,
              prefixUrl = _options.prefixUrl;
          Object.defineProperty(options, 'prefixUrl', {
            set: function set(value) {
              var url = options.url;

              if (!url.href.startsWith(value)) {
                throw new Error("Cannot change `prefixUrl` from ".concat(prefixUrl, " to ").concat(value, ": ").concat(url.href));
              }

              options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));
              prefixUrl = value;
            },
            get: function get() {
              return prefixUrl;
            }
          }); // Support UNIX sockets

          var protocol = options.url.protocol;

          if (protocol === 'unix:') {
            protocol = 'http:';
            options.url = new url_1.URL("http://unix".concat(options.url.pathname).concat(options.url.search));
          } // Set search params


          if (options.searchParams) {
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            options.url.search = options.searchParams.toString();
          } // Protocol check


          if (protocol !== 'http:' && protocol !== 'https:') {
            throw new UnsupportedProtocolError(options);
          } // Update `username`


          if (options.username === '') {
            options.username = options.url.username;
          } else {
            options.url.username = options.username;
          } // Update `password`


          if (options.password === '') {
            options.password = options.url.password;
          } else {
            options.url.password = options.password;
          }
        } // `options.cookieJar`


        var _options2 = options,
            cookieJar = _options2.cookieJar;

        if (cookieJar) {
          var setCookie = cookieJar.setCookie,
              getCookieString = cookieJar.getCookieString;
          dist$1.assert.function_(setCookie);
          dist$1.assert.function_(getCookieString);
          /* istanbul ignore next: Horrible `tough-cookie` v3 check */

          if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
            getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
            options.cookieJar = {
              setCookie: setCookie,
              getCookieString: getCookieString
            };
          }
        } // `options.cache`


        var _options3 = options,
            cache = _options3.cache;

        if (cache) {
          if (!cacheableStore.has(cache)) {
            cacheableStore.set(cache, new src(function (requestOptions, handler) {
              var result = requestOptions[kRequest](requestOptions, handler); // TODO: remove this when `cacheable-request` supports async request functions.

              if (dist$1.default.promise(result)) {
                // @ts-expect-error
                // We only need to implement the error handler in order to support HTTP2 caching.
                // The result will be a promise anyway.
                result.once = function (event, handler) {
                  if (event === 'error') {
                    result.catch(handler);
                  } else if (event === 'abort') {
                    // The empty catch is needed here in case when
                    // it rejects before it's `await`ed in `_makeRequest`.
                    _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15() {
                      var request;
                      return regenerator.wrap(function _callee15$(_context16) {
                        while (1) {
                          switch (_context16.prev = _context16.next) {
                            case 0:
                              _context16.prev = 0;
                              _context16.next = 3;
                              return result;

                            case 3:
                              request = _context16.sent;
                              request.once('abort', handler);
                              _context16.next = 9;
                              break;

                            case 7:
                              _context16.prev = 7;
                              _context16.t0 = _context16["catch"](0);

                            case 9:
                            case "end":
                              return _context16.stop();
                          }
                        }
                      }, _callee15, null, [[0, 7]]);
                    }))();
                  } else {
                    /* istanbul ignore next: safety check */
                    throw new Error("Unknown HTTP2 promise event: ".concat(event));
                  }

                  return result;
                };
              }

              return result;
            }, cache));
          }
        } // `options.cacheOptions`


        options.cacheOptions = _objectSpread$2({}, options.cacheOptions); // `options.dnsCache`

        if (options.dnsCache === true) {
          if (!globalDnsCache) {
            globalDnsCache = new source$2.default();
          }

          options.dnsCache = globalDnsCache;
        } else if (!dist$1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
          throw new TypeError("Parameter `dnsCache` must be a CacheableLookup instance or a boolean, got ".concat(dist$1.default(options.dnsCache)));
        } // `options.timeout`


        if (dist$1.default.number(options.timeout)) {
          options.timeout = {
            request: options.timeout
          };
        } else if (defaults && options.timeout !== defaults.timeout) {
          options.timeout = _objectSpread$2(_objectSpread$2({}, defaults.timeout), options.timeout);
        } else {
          options.timeout = _objectSpread$2({}, options.timeout);
        } // `options.context`


        if (!options.context) {
          options.context = {};
        } // `options.hooks`


        var areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
        options.hooks = _objectSpread$2({}, options.hooks);

        var _iterator9 = _createForOfIteratorHelper$4(exports.knownHookEvents),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var _event = _step9.value;

            if (_event in options.hooks) {
              if (dist$1.default.array(options.hooks[_event])) {
                // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                options.hooks[_event] = _toConsumableArray(options.hooks[_event]);
              } else {
                throw new TypeError("Parameter `".concat(_event, "` must be an Array, got ").concat(dist$1.default(options.hooks[_event])));
              }
            } else {
              options.hooks[_event] = [];
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        if (defaults && !areHooksDefault) {
          var _iterator10 = _createForOfIteratorHelper$4(exports.knownHookEvents),
              _step10;

          try {
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
              var event = _step10.value;
              var defaultHooks = defaults.hooks[event];

              if (defaultHooks.length > 0) {
                // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                options.hooks[event] = [].concat(_toConsumableArray(defaults.hooks[event]), _toConsumableArray(options.hooks[event]));
              }
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }
        } // DNS options


        if ('family' in options) {
          deprecationWarning.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
        } // HTTPS options


        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {
          options.https = _objectSpread$2(_objectSpread$2({}, defaults.https), options.https);
        }

        if ('rejectUnauthorized' in options) {
          deprecationWarning.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
        }

        if ('checkServerIdentity' in options) {
          deprecationWarning.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
        }

        if ('ca' in options) {
          deprecationWarning.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
        }

        if ('key' in options) {
          deprecationWarning.default('"options.key" was never documented, please use "options.https.key"');
        }

        if ('cert' in options) {
          deprecationWarning.default('"options.cert" was never documented, please use "options.https.certificate"');
        }

        if ('passphrase' in options) {
          deprecationWarning.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
        }

        if ('pfx' in options) {
          deprecationWarning.default('"options.pfx" was never documented, please use "options.https.pfx"');
        } // Other options


        if ('followRedirects' in options) {
          throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
        }

        if (options.agent) {
          for (var _key in options.agent) {
            if (_key !== 'http' && _key !== 'https' && _key !== 'http2') {
              throw new TypeError("Expected the `options.agent` properties to be `http`, `https` or `http2`, got `".concat(_key, "`"));
            }
          }
        }

        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0; // Set non-enumerable properties

        exports.setNonEnumerableProperties([defaults, rawOptions], options);
        return normalizeArguments_1.default(options, defaults);
      }
    }]);

    return Request;
  }(require$$0$4.Duplex);

  exports.default = Request;
});

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var types$1 = createCommonjsModule(function (module, exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) {
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CancelError = exports.ParseError = void 0;
  /**
  An error to be thrown when server response code is 2xx, and parsing body fails.
  Includes a `response` property.
  */

  var ParseError = /*#__PURE__*/function (_core_1$RequestError) {
    _inherits(ParseError, _core_1$RequestError);

    var _super = _createSuper$1(ParseError);

    function ParseError(error, response) {
      var _this;

      _classCallCheck(this, ParseError);

      var options = response.request.options;
      _this = _super.call(this, "".concat(error.message, " in \"").concat(options.url.toString(), "\""), error, response.request);
      _this.name = 'ParseError';
      return _this;
    }

    return ParseError;
  }(core.RequestError);

  exports.ParseError = ParseError;
  /**
  An error to be thrown when the request is aborted with `.cancel()`.
  */

  var CancelError = /*#__PURE__*/function (_core_1$RequestError2) {
    _inherits(CancelError, _core_1$RequestError2);

    var _super2 = _createSuper$1(CancelError);

    function CancelError(request) {
      var _this2;

      _classCallCheck(this, CancelError);

      _this2 = _super2.call(this, 'Promise was canceled', {}, request);
      _this2.name = 'CancelError';
      return _this2;
    }

    _createClass(CancelError, [{
      key: "isCanceled",
      get: function get() {
        return true;
      }
    }]);

    return CancelError;
  }(core.RequestError);

  exports.CancelError = CancelError;

  __exportStar(core, exports);
});

var parseBody = function parseBody(response, responseType, parseJson, encoding) {
  var rawBody = response.rawBody;

  try {
    if (responseType === 'text') {
      return rawBody.toString(encoding);
    }

    if (responseType === 'json') {
      return rawBody.length === 0 ? '' : parseJson(rawBody.toString());
    }

    if (responseType === 'buffer') {
      return rawBody;
    }

    throw new types$1.ParseError({
      message: "Unknown body type '".concat(responseType, "'"),
      name: 'Error'
    }, response);
  } catch (error) {
    throw new types$1.ParseError(error, response);
  }
};

var _default$5 = parseBody;
var parseBody_1 = /*#__PURE__*/Object.defineProperty({
  default: _default$5
}, '__esModule', {
  value: true
});

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var asPromise_1 = createCommonjsModule(function (module, exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) {
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];

  function asPromise(normalizedOptions) {
    var globalRequest;
    var globalResponse;
    var emitter = new EventEmitter.EventEmitter();
    var promise = new pCancelable(function (resolve, reject, onCancel) {
      var makeRequest = function makeRequest(retryCount) {
        var request = new core.default(undefined, normalizedOptions);
        request.retryCount = retryCount;
        request._noPipe = true;
        onCancel(function () {
          return request.destroy();
        });
        onCancel.shouldReject = false;
        onCancel(function () {
          return reject(new types$1.CancelError(request));
        });
        globalRequest = request;
        request.once('response', /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(response) {
            var _a, rawBody, contentEncoding, isCompressed, options, _iterator, _step, _loop;

            return regenerator.wrap(function _callee2$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    response.retryCount = retryCount;

                    if (!response.request.aborted) {
                      _context3.next = 3;
                      break;
                    }

                    return _context3.abrupt("return");

                  case 3:
                    _context3.prev = 3;
                    _context3.next = 6;
                    return getBuffer_1.default(request);

                  case 6:
                    rawBody = _context3.sent;
                    response.rawBody = rawBody;
                    _context3.next = 13;
                    break;

                  case 10:
                    _context3.prev = 10;
                    _context3.t0 = _context3["catch"](3);
                    return _context3.abrupt("return");

                  case 13:
                    if (!request._isAboutToError) {
                      _context3.next = 15;
                      break;
                    }

                    return _context3.abrupt("return");

                  case 15:
                    // Parse body
                    contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();
                    isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);
                    options = request.options;

                    if (!(isCompressed && !options.decompress)) {
                      _context3.next = 22;
                      break;
                    }

                    response.body = rawBody;
                    _context3.next = 32;
                    break;

                  case 22:
                    _context3.prev = 22;
                    response.body = parseBody_1.default(response, options.responseType, options.parseJson, options.encoding);
                    _context3.next = 32;
                    break;

                  case 26:
                    _context3.prev = 26;
                    _context3.t1 = _context3["catch"](22);
                    // Fallback to `utf8`
                    response.body = rawBody.toString();

                    if (!isResponseOk.isResponseOk(response)) {
                      _context3.next = 32;
                      break;
                    }

                    request._beforeError(_context3.t1);

                    return _context3.abrupt("return");

                  case 32:
                    _context3.prev = 32;
                    _iterator = _createForOfIteratorHelper$3(options.hooks.afterResponse.entries());
                    _context3.prev = 34;
                    _loop = /*#__PURE__*/regenerator.mark(function _loop() {
                      var _step$value, index, hook;

                      return regenerator.wrap(function _loop$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], hook = _step$value[1];
                              _context2.next = 3;
                              return hook(response, /*#__PURE__*/function () {
                                var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(updatedOptions) {
                                  var typedOptions, _iterator2, _step2, _hook, promise;

                                  return regenerator.wrap(function _callee$(_context) {
                                    while (1) {
                                      switch (_context.prev = _context.next) {
                                        case 0:
                                          typedOptions = core.default.normalizeArguments(undefined, _objectSpread$1(_objectSpread$1({}, updatedOptions), {}, {
                                            retry: {
                                              calculateDelay: function calculateDelay() {
                                                return 0;
                                              }
                                            },
                                            throwHttpErrors: false,
                                            resolveBodyOnly: false
                                          }), options); // Remove any further hooks for that request, because we'll call them anyway.
                                          // The loop continues. We don't want duplicates (asPromise recursion).

                                          // Remove any further hooks for that request, because we'll call them anyway.
                                          // The loop continues. We don't want duplicates (asPromise recursion).
                                          typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
                                          _iterator2 = _createForOfIteratorHelper$3(typedOptions.hooks.beforeRetry);
                                          _context.prev = 3;

                                          _iterator2.s();

                                        case 5:
                                          if ((_step2 = _iterator2.n()).done) {
                                            _context.next = 11;
                                            break;
                                          }

                                          _hook = _step2.value;
                                          _context.next = 9;
                                          return _hook(typedOptions);

                                        case 9:
                                          _context.next = 5;
                                          break;

                                        case 11:
                                          _context.next = 16;
                                          break;

                                        case 13:
                                          _context.prev = 13;
                                          _context.t0 = _context["catch"](3);

                                          _iterator2.e(_context.t0);

                                        case 16:
                                          _context.prev = 16;

                                          _iterator2.f();

                                          return _context.finish(16);

                                        case 19:
                                          promise = asPromise(typedOptions);
                                          onCancel(function () {
                                            promise.catch(function () {});
                                            promise.cancel();
                                          });
                                          return _context.abrupt("return", promise);

                                        case 22:
                                        case "end":
                                          return _context.stop();
                                      }
                                    }
                                  }, _callee, null, [[3, 13, 16, 19]]);
                                }));

                                return function (_x2) {
                                  return _ref2.apply(this, arguments);
                                };
                              }());

                            case 3:
                              response = _context2.sent;

                            case 4:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _loop);
                    });

                    _iterator.s();

                  case 37:
                    if ((_step = _iterator.n()).done) {
                      _context3.next = 41;
                      break;
                    }

                    return _context3.delegateYield(_loop(), "t2", 39);

                  case 39:
                    _context3.next = 37;
                    break;

                  case 41:
                    _context3.next = 46;
                    break;

                  case 43:
                    _context3.prev = 43;
                    _context3.t3 = _context3["catch"](34);

                    _iterator.e(_context3.t3);

                  case 46:
                    _context3.prev = 46;

                    _iterator.f();

                    return _context3.finish(46);

                  case 49:
                    _context3.next = 55;
                    break;

                  case 51:
                    _context3.prev = 51;
                    _context3.t4 = _context3["catch"](32);

                    request._beforeError(new types$1.RequestError(_context3.t4.message, _context3.t4, request));

                    return _context3.abrupt("return");

                  case 55:
                    if (isResponseOk.isResponseOk(response)) {
                      _context3.next = 58;
                      break;
                    }

                    request._beforeError(new types$1.HTTPError(response));

                    return _context3.abrupt("return");

                  case 58:
                    globalResponse = response;
                    resolve(request.options.resolveBodyOnly ? response.body : response);

                  case 60:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2, null, [[3, 10], [22, 26], [32, 51], [34, 43, 46, 49]]);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }());

        var onError = function onError(error) {
          if (promise.isCanceled) {
            return;
          }

          var options = request.options;

          if (error instanceof types$1.HTTPError && !options.throwHttpErrors) {
            var response = error.response;
            resolve(request.options.resolveBodyOnly ? response.body : response);
            return;
          }

          reject(error);
        };

        request.once('error', onError);
        var previousBody = request.options.body;
        request.once('retry', function (newRetryCount, error) {
          var _a, _b;

          if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && dist$1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {
            onError(error);
            return;
          }

          makeRequest(newRetryCount);
        });
        proxyEvents.default(request, emitter, proxiedRequestEvents);
      };

      makeRequest(0);
    });

    promise.on = function (event, fn) {
      emitter.on(event, fn);
      return promise;
    };

    var shortcut = function shortcut(responseType) {
      var newPromise = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
        var options;
        return regenerator.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return promise;

              case 2:
                options = globalResponse.request.options;
                return _context4.abrupt("return", parseBody_1.default(globalResponse, responseType, options.parseJson, options.encoding));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3);
      }))();

      Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
      return newPromise;
    };

    promise.json = function () {
      var headers = globalRequest.options.headers;

      if (!globalRequest.writableFinished && headers.accept === undefined) {
        headers.accept = 'application/json';
      }

      return shortcut('json');
    };

    promise.buffer = function () {
      return shortcut('buffer');
    };

    promise.text = function () {
      return shortcut('text');
    };

    return promise;
  }

  exports.default = asPromise;

  __exportStar(types$1, exports);
});

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function createRejection(error) {
  for (var _len = arguments.length, beforeErrorGroups = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    beforeErrorGroups[_key - 1] = arguments[_key];
  }

  var promise = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
    var _iterator, _step, hooks, _iterator2, _step2, hook;

    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(error instanceof types$1.RequestError)) {
              _context.next = 41;
              break;
            }

            _context.prev = 1;
            _iterator = _createForOfIteratorHelper$2(beforeErrorGroups);
            _context.prev = 3;

            _iterator.s();

          case 5:
            if ((_step = _iterator.n()).done) {
              _context.next = 28;
              break;
            }

            hooks = _step.value;

            if (!hooks) {
              _context.next = 26;
              break;
            }

            _iterator2 = _createForOfIteratorHelper$2(hooks);
            _context.prev = 9;

            _iterator2.s();

          case 11:
            if ((_step2 = _iterator2.n()).done) {
              _context.next = 18;
              break;
            }

            hook = _step2.value;
            _context.next = 15;
            return hook(error);

          case 15:
            error = _context.sent;

          case 16:
            _context.next = 11;
            break;

          case 18:
            _context.next = 23;
            break;

          case 20:
            _context.prev = 20;
            _context.t0 = _context["catch"](9);

            _iterator2.e(_context.t0);

          case 23:
            _context.prev = 23;

            _iterator2.f();

            return _context.finish(23);

          case 26:
            _context.next = 5;
            break;

          case 28:
            _context.next = 33;
            break;

          case 30:
            _context.prev = 30;
            _context.t1 = _context["catch"](3);

            _iterator.e(_context.t1);

          case 33:
            _context.prev = 33;

            _iterator.f();

            return _context.finish(33);

          case 36:
            _context.next = 41;
            break;

          case 38:
            _context.prev = 38;
            _context.t2 = _context["catch"](1);
            error = _context.t2;

          case 41:
            throw error;

          case 42:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 38], [3, 30, 33, 36], [9, 20, 23, 26]]);
  }))();

  var returnPromise = function returnPromise() {
    return promise;
  };

  promise.json = returnPromise;
  promise.text = returnPromise;
  promise.buffer = returnPromise;
  promise.on = returnPromise;
  return promise;
}

var _default$4 = createRejection;
var createRejection_1 = /*#__PURE__*/Object.defineProperty({
  default: _default$4
}, '__esModule', {
  value: true
});

function deepFreeze(object) {
  for (var _i = 0, _Object$values = Object.values(object); _i < _Object$values.length; _i++) {
    var value = _Object$values[_i];

    if (dist$1.default.plainObject(value) || dist$1.default.array(value)) {
      deepFreeze(value);
    }
  }

  return Object.freeze(object);
}

var _default$3 = deepFreeze;
var deepFreeze_1 = /*#__PURE__*/Object.defineProperty({
  default: _default$3
}, '__esModule', {
  value: true
});

Object.defineProperty(exports, "__esModule", {
  value: true
});

var types = /*#__PURE__*/Object.freeze({
	__proto__: null
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(types);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var create_1 = createCommonjsModule(function (module, exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) {
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.defaultHandler = void 0;
  var errors = {
    RequestError: asPromise_1.RequestError,
    CacheError: asPromise_1.CacheError,
    ReadError: asPromise_1.ReadError,
    HTTPError: asPromise_1.HTTPError,
    MaxRedirectsError: asPromise_1.MaxRedirectsError,
    TimeoutError: asPromise_1.TimeoutError,
    ParseError: asPromise_1.ParseError,
    CancelError: asPromise_1.CancelError,
    UnsupportedProtocolError: asPromise_1.UnsupportedProtocolError,
    UploadError: asPromise_1.UploadError
  }; // The `delay` package weighs 10KB (!)

  var delay = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ms) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve) {
                setTimeout(resolve, ms);
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function delay(_x3) {
      return _ref2.apply(this, arguments);
    };
  }();

  var normalizeArguments = core.default.normalizeArguments;

  var mergeOptions = function mergeOptions() {
    var mergedOptions;

    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }

    for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
      var source = _sources[_i];
      mergedOptions = normalizeArguments(undefined, source, mergedOptions);
    }

    return mergedOptions;
  };

  var getPromiseOrStream = function getPromiseOrStream(options) {
    return options.isStream ? new core.default(undefined, options) : asPromise_1.default(options);
  };

  var isGotInstance = function isGotInstance(value) {
    return 'defaults' in value && 'options' in value.defaults;
  };

  var aliases = ['get', 'post', 'put', 'patch', 'head', 'delete'];

  exports.defaultHandler = function (options, next) {
    return next(options);
  };

  var callInitHooks = function callInitHooks(hooks, options) {
    if (hooks) {
      var _iterator2 = _createForOfIteratorHelper$1(hooks),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var hook = _step2.value;
          hook(options);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  };

  var create = function create(defaults) {
    // Proxy properties from next handlers
    defaults._rawHandlers = defaults.handlers;
    defaults.handlers = defaults.handlers.map(function (fn) {
      return function (options, next) {
        // This will be assigned by assigning result
        var root;
        var result = fn(options, function (newOptions) {
          root = next(newOptions);
          return root;
        });

        if (result !== root && !options.isStream && root) {
          var typedResult = result;
          var promiseThen = typedResult.then,
              promiseCatch = typedResult.catch,
              promiseFianlly = typedResult.finally;
          Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
          Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root)); // These should point to the new promise
          // eslint-disable-next-line promise/prefer-await-to-then

          typedResult.then = promiseThen;
          typedResult.catch = promiseCatch;
          typedResult.finally = promiseFianlly;
        }

        return result;
      };
    }); // Got interface

    var got = function got(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _defaults = arguments.length > 2 ? arguments[2] : undefined;

      var _a, _b;

      var iteration = 0;

      var iterateHandlers = function iterateHandlers(newOptions) {
        return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
      }; // TODO: Remove this in Got 12.


      if (dist$1.default.plainObject(url)) {
        var mergedOptions = _objectSpread(_objectSpread({}, url), options);

        core.setNonEnumerableProperties([url, options], mergedOptions);
        options = mergedOptions;
        url = undefined;
      }

      try {
        // Call `init` hooks
        var initHookError;

        try {
          callInitHooks(defaults.options.hooks.init, options);
          callInitHooks((_a = options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);
        } catch (error) {
          initHookError = error;
        } // Normalize options & call handlers


        var normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);
        normalizedOptions[core.kIsNormalizedAlready] = true;

        if (initHookError) {
          throw new asPromise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
        }

        return iterateHandlers(normalizedOptions);
      } catch (error) {
        if (options.isStream) {
          throw error;
        } else {
          return createRejection_1.default(error, defaults.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
        }
      }
    };

    got.extend = function () {
      var optionsArray = [defaults.options];

      var handlers = _toConsumableArray(defaults._rawHandlers);

      var isMutableDefaults;

      for (var _len2 = arguments.length, instancesOrOptions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        instancesOrOptions[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _instancesOrOptions = instancesOrOptions; _i2 < _instancesOrOptions.length; _i2++) {
        var value = _instancesOrOptions[_i2];

        if (isGotInstance(value)) {
          var _handlers;

          optionsArray.push(value.defaults.options);

          (_handlers = handlers).push.apply(_handlers, _toConsumableArray(value.defaults._rawHandlers));

          isMutableDefaults = value.defaults.mutableDefaults;
        } else {
          optionsArray.push(value);

          if ('handlers' in value) {
            var _handlers2;

            (_handlers2 = handlers).push.apply(_handlers2, _toConsumableArray(value.handlers));
          }

          isMutableDefaults = value.mutableDefaults;
        }
      }

      handlers = handlers.filter(function (handler) {
        return handler !== exports.defaultHandler;
      });

      if (handlers.length === 0) {
        handlers.push(exports.defaultHandler);
      }

      return create({
        options: mergeOptions.apply(void 0, optionsArray),
        handlers: handlers,
        mutableDefaults: Boolean(isMutableDefaults)
      });
    }; // Pagination


    var paginateEach = /*#__PURE__*/function () {
      var _ref = _wrapAsyncGenerator( /*#__PURE__*/regenerator.mark(function _callee2(url, options) {
        var normalizedOptions, pagination, all, countLimit, numberOfRequests, result, parsed, current, _iterator3, _step3, item, optionsToMerge;

        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // TODO: Remove this `@ts-expect-error` when upgrading to TypeScript 4.
                // Error: Argument of type 'Merge<Options, PaginationOptions<T, R>> | undefined' is not assignable to parameter of type 'Options | undefined'.
                // @ts-expect-error
                normalizedOptions = normalizeArguments(url, options, defaults.options);
                normalizedOptions.resolveBodyOnly = false;
                pagination = normalizedOptions.pagination;

                if (dist$1.default.object(pagination)) {
                  _context2.next = 5;
                  break;
                }

                throw new TypeError('`options.pagination` must be implemented');

              case 5:
                all = [];
                countLimit = pagination.countLimit;
                numberOfRequests = 0;

              case 8:
                if (!(numberOfRequests < pagination.requestLimit)) {
                  _context2.next = 50;
                  break;
                }

                if (!(numberOfRequests !== 0)) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 12;
                return _awaitAsyncGenerator(delay(pagination.backoff));

              case 12:
                _context2.next = 14;
                return _awaitAsyncGenerator(got(undefined, undefined, normalizedOptions));

              case 14:
                result = _context2.sent;
                _context2.next = 17;
                return _awaitAsyncGenerator(pagination.transform(result));

              case 17:
                parsed = _context2.sent;
                current = [];
                _iterator3 = _createForOfIteratorHelper$1(parsed);
                _context2.prev = 20;

                _iterator3.s();

              case 22:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 35;
                  break;
                }

                item = _step3.value;

                if (!pagination.filter(item, all, current)) {
                  _context2.next = 33;
                  break;
                }

                if (pagination.shouldContinue(item, all, current)) {
                  _context2.next = 27;
                  break;
                }

                return _context2.abrupt("return");

              case 27:
                _context2.next = 29;
                return item;

              case 29:
                if (pagination.stackAllItems) {
                  all.push(item);
                }

                current.push(item);

                if (!(--countLimit <= 0)) {
                  _context2.next = 33;
                  break;
                }

                return _context2.abrupt("return");

              case 33:
                _context2.next = 22;
                break;

              case 35:
                _context2.next = 40;
                break;

              case 37:
                _context2.prev = 37;
                _context2.t0 = _context2["catch"](20);

                _iterator3.e(_context2.t0);

              case 40:
                _context2.prev = 40;

                _iterator3.f();

                return _context2.finish(40);

              case 43:
                optionsToMerge = pagination.paginate(result, all, current);

                if (!(optionsToMerge === false)) {
                  _context2.next = 46;
                  break;
                }

                return _context2.abrupt("return");

              case 46:
                if (optionsToMerge === result.request.options) {
                  normalizedOptions = result.request.options;
                } else if (optionsToMerge !== undefined) {
                  normalizedOptions = normalizeArguments(undefined, optionsToMerge, normalizedOptions);
                }

                numberOfRequests++;
                _context2.next = 8;
                break;

              case 50:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[20, 37, 40, 43]]);
      }));

      return function paginateEach(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();

    got.paginate = paginateEach;

    got.paginate.all = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(url, options) {
        var results, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, item;

        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                results = [];
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _context3.prev = 3;
                _iterator = _asyncIterator(paginateEach(url, options));

              case 5:
                _context3.next = 7;
                return _iterator.next();

              case 7:
                _step = _context3.sent;
                _iteratorNormalCompletion = _step.done;
                _context3.next = 11;
                return _step.value;

              case 11:
                _value = _context3.sent;

                if (_iteratorNormalCompletion) {
                  _context3.next = 18;
                  break;
                }

                item = _value;
                results.push(item);

              case 15:
                _iteratorNormalCompletion = true;
                _context3.next = 5;
                break;

              case 18:
                _context3.next = 24;
                break;

              case 20:
                _context3.prev = 20;
                _context3.t0 = _context3["catch"](3);
                _didIteratorError = true;
                _iteratorError = _context3.t0;

              case 24:
                _context3.prev = 24;
                _context3.prev = 25;

                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                  _context3.next = 29;
                  break;
                }

                _context3.next = 29;
                return _iterator.return();

              case 29:
                _context3.prev = 29;

                if (!_didIteratorError) {
                  _context3.next = 32;
                  break;
                }

                throw _iteratorError;

              case 32:
                return _context3.finish(29);

              case 33:
                return _context3.finish(24);

              case 34:
                return _context3.abrupt("return", results);

              case 35:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[3, 20, 24, 34], [25,, 29, 33]]);
      }));

      return function (_x4, _x5) {
        return _ref3.apply(this, arguments);
      };
    }(); // For those who like very descriptive names


    got.paginate.each = paginateEach; // Stream API

    got.stream = function (url, options) {
      return got(url, _objectSpread(_objectSpread({}, options), {}, {
        isStream: true
      }));
    }; // Shortcuts


    var _iterator4 = _createForOfIteratorHelper$1(aliases),
        _step4;

    try {
      var _loop = function _loop() {
        var method = _step4.value;

        got[method] = function (url, options) {
          return got(url, _objectSpread(_objectSpread({}, options), {}, {
            method: method
          }));
        };

        got.stream[method] = function (url, options) {
          return got(url, _objectSpread(_objectSpread({}, options), {}, {
            method: method,
            isStream: true
          }));
        };
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    Object.assign(got, errors);
    Object.defineProperty(got, 'defaults', {
      value: defaults.mutableDefaults ? defaults : deepFreeze_1.default(defaults),
      writable: defaults.mutableDefaults,
      configurable: defaults.mutableDefaults,
      enumerable: true
    });
    got.mergeOptions = mergeOptions;
    return got;
  };

  exports.default = create;

  __exportStar(require$$0$2, exports);
});

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var source = createCommonjsModule(function (module, exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) {
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var defaults = {
    options: {
      method: 'GET',
      retry: {
        limit: 2,
        methods: ['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE'],
        statusCodes: [408, 413, 429, 500, 502, 503, 504, 521, 522, 524],
        errorCodes: ['ETIMEDOUT', 'ECONNRESET', 'EADDRINUSE', 'ECONNREFUSED', 'EPIPE', 'ENOTFOUND', 'ENETUNREACH', 'EAI_AGAIN'],
        maxRetryAfter: undefined,
        calculateDelay: function calculateDelay(_ref) {
          var computedValue = _ref.computedValue;
          return computedValue;
        }
      },
      timeout: {},
      headers: {
        'user-agent': 'got (https://github.com/sindresorhus/got)'
      },
      hooks: {
        init: [],
        beforeRequest: [],
        beforeRedirect: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      },
      cache: undefined,
      dnsCache: undefined,
      decompress: true,
      throwHttpErrors: true,
      followRedirect: true,
      isStream: false,
      responseType: 'text',
      resolveBodyOnly: false,
      maxRedirects: 10,
      prefixUrl: '',
      methodRewriting: true,
      ignoreInvalidCookies: false,
      context: {},
      // TODO: Set this to `true` when Got 12 gets released
      http2: false,
      allowGetBody: false,
      https: undefined,
      pagination: {
        transform: function transform(response) {
          if (response.request.options.responseType === 'json') {
            return response.body;
          }

          return JSON.parse(response.body);
        },
        paginate: function paginate(response) {
          if (!Reflect.has(response.headers, 'link')) {
            return false;
          }

          var items = response.headers.link.split(',');
          var next;

          var _iterator = _createForOfIteratorHelper(items),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              var parsed = item.split(';');

              if (parsed[1].includes('next')) {
                next = parsed[0].trimStart().trim();
                next = next.slice(1, -1);
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          if (next) {
            var options = {
              url: new url_1.URL(next)
            };
            return options;
          }

          return false;
        },
        filter: function filter() {
          return true;
        },
        shouldContinue: function shouldContinue() {
          return true;
        },
        countLimit: Infinity,
        backoff: 0,
        requestLimit: 10000,
        stackAllItems: true
      },
      parseJson: function parseJson(text) {
        return JSON.parse(text);
      },
      stringifyJson: function stringifyJson(object) {
        return JSON.stringify(object);
      },
      cacheOptions: {}
    },
    handlers: [create_1.defaultHandler],
    mutableDefaults: false
  };
  var got = create_1.default(defaults);
  exports.default = got; // For CommonJS default export support

  module.exports = got;
  module.exports.default = got;
  module.exports.__esModule = true; // Workaround for TS issue: https://github.com/sindresorhus/got/pull/1267

  __exportStar(create_1, exports);

  __exportStar(asPromise_1, exports);
});

var utils = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.extend = extend;
  exports.indexOf = indexOf;
  exports.escapeExpression = escapeExpression;
  exports.isEmpty = isEmpty;
  exports.createFrame = createFrame;
  exports.blockParams = blockParams;
  exports.appendContextPath = appendContextPath;
  var escape = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };
  var badChars = /[&<>"'`=]/g,
      possible = /[&<>"'`=]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj
  /* , ...source */
  ) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  var toString = Object.prototype.toString;
  exports.toString = toString; // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt

  /* eslint-disable func-style */

  var isFunction = function isFunction(value) {
    return typeof value === 'function';
  }; // fallback for older versions of Chrome and Safari

  /* istanbul ignore next */


  if (isFunction(/x/)) {
    exports.isFunction = isFunction = function isFunction(value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }

  exports.isFunction = isFunction;
  /* eslint-enable func-style */

  /* istanbul ignore next */

  var isArray = Array.isArray || function (value) {
    return value && _typeof(value) === 'object' ? toString.call(value) === '[object Array]' : false;
  };

  exports.isArray = isArray; // Older IE versions do not directly support indexOf so we must implement our own, sadly.

  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }

    return -1;
  }

  function escapeExpression(string) {
    if (typeof string !== 'string') {
      // don't escape SafeStrings, since they're already safe
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return '';
      } else if (!string) {
        return string + '';
      } // Force a string conversion as this will be done by the append regardless and
      // the regex test will do this transparently behind the scenes, causing issues if
      // an object's to string has escaped characters in it.


      string = '' + string;
    }

    if (!possible.test(string)) {
      return string;
    }

    return string.replace(badChars, escapeChar);
  }

  function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  function createFrame(object) {
    var frame = extend({}, object);
    frame._parent = object;
    return frame;
  }

  function blockParams(params, ids) {
    params.path = ids;
    return params;
  }

  function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }
});

var exception = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var loc = node && node.loc,
        line = undefined,
        endLineNumber = undefined,
        column = undefined,
        endColumn = undefined;

    if (loc) {
      line = loc.start.line;
      endLineNumber = loc.end.line;
      column = loc.start.column;
      endColumn = loc.end.column;
      message += ' - ' + line + ':' + column;
    }

    var tmp = Error.prototype.constructor.call(this, message); // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.

    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }
    /* istanbul ignore else */


    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }

    try {
      if (loc) {
        this.lineNumber = line;
        this.endLineNumber = endLineNumber; // Work around issue under safari where we can't directly set the column value

        /* istanbul ignore next */

        if (Object.defineProperty) {
          Object.defineProperty(this, 'column', {
            value: column,
            enumerable: true
          });
          Object.defineProperty(this, 'endColumn', {
            value: endColumn,
            enumerable: true
          });
        } else {
          this.column = column;
          this.endColumn = endColumn;
        }
      }
    } catch (nop) {
      /* Ignore if the browser is very particular */
    }
  }

  Exception.prototype = new Error();
  exports['default'] = Exception;
  module.exports = exports['default'];
});

var blockHelperMissing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerHelper('blockHelperMissing', function (context, options) {
      var inverse = options.inverse,
          fn = options.fn;

      if (context === true) {
        return fn(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (utils.isArray(context)) {
        if (context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }

          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = utils.createFrame(options.data);

          data.contextPath = utils.appendContextPath(options.data.contextPath, options.name);
          options = {
            data: data
          };
        }

        return fn(context, options);
      }
    });
  };

  module.exports = exports['default'];
});

var each = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('each', function (context, options) {
      if (!options) {
        throw new _exception2['default']('Must pass iterator to #each');
      }

      var fn = options.fn,
          inverse = options.inverse,
          i = 0,
          ret = '',
          data = undefined,
          contextPath = undefined;

      if (options.data && options.ids) {
        contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }

      if (utils.isFunction(context)) {
        context = context.call(this);
      }

      if (options.data) {
        data = utils.createFrame(options.data);
      }

      function execIteration(field, index, last) {
        if (data) {
          data.key = field;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;

          if (contextPath) {
            data.contextPath = contextPath + field;
          }
        }

        ret = ret + fn(context[field], {
          data: data,
          blockParams: utils.blockParams([context[field], field], [contextPath + field, null])
        });
      }

      if (context && _typeof(context) === 'object') {
        if (utils.isArray(context)) {
          for (var j = context.length; i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (commonjsGlobal.Symbol && context[commonjsGlobal.Symbol.iterator]) {
          var newContext = [];
          var iterator = context[commonjsGlobal.Symbol.iterator]();

          for (var it = iterator.next(); !it.done; it = iterator.next()) {
            newContext.push(it.value);
          }

          context = newContext;

          for (var j = context.length; i < j; i++) {
            execIteration(i, i, i === context.length - 1);
          }
        } else {
          (function () {
            var priorKey = undefined;
            Object.keys(context).forEach(function (key) {
              // We're running the iterations one step out of sync so we can detect
              // the last iteration without have to scan the object twice and create
              // an itermediate keys array.
              if (priorKey !== undefined) {
                execIteration(priorKey, i - 1);
              }

              priorKey = key;
              i++;
            });

            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1, true);
            }
          })();
        }
      }

      if (i === 0) {
        ret = inverse(this);
      }

      return ret;
    });
  };

  module.exports = exports['default'];
});

var helperMissing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('helperMissing', function ()
    /* [args, ]options */
    {
      if (arguments.length === 1) {
        // A missing field in a {{foo}} construct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };

  module.exports = exports['default'];
});

var _if = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('if', function (conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#if requires exactly one argument');
      }

      if (utils.isFunction(conditional)) {
        conditional = conditional.call(this);
      } // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.


      if (!options.hash.includeZero && !conditional || utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });
    instance.registerHelper('unless', function (conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#unless requires exactly one argument');
      }

      return instance.helpers['if'].call(this, conditional, {
        fn: options.inverse,
        inverse: options.fn,
        hash: options.hash
      });
    });
  };

  module.exports = exports['default'];
});

var log$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerHelper('log', function ()
    /* message, options */
    {
      var args = [undefined],
          options = arguments[arguments.length - 1];

      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }

      var level = 1;

      if (options.hash.level != null) {
        level = options.hash.level;
      } else if (options.data && options.data.level != null) {
        level = options.data.level;
      }

      args[0] = level;
      instance.log.apply(instance, args);
    });
  };

  module.exports = exports['default'];
});

var lookup = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerHelper('lookup', function (obj, field, options) {
      if (!obj) {
        // Note for 5.0: Change to "obj == null" in 5.0
        return obj;
      }

      return options.lookupProperty(obj, field);
    });
  };

  module.exports = exports['default'];
});

var _with = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('with', function (context, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#with requires exactly one argument');
      }

      if (utils.isFunction(context)) {
        context = context.call(this);
      }

      var fn = options.fn;

      if (!utils.isEmpty(context)) {
        var data = options.data;

        if (options.data && options.ids) {
          data = utils.createFrame(options.data);
          data.contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]);
        }

        return fn(context, {
          data: data,
          blockParams: utils.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options.inverse(this);
      }
    });
  };

  module.exports = exports['default'];
});

var registerDefaultHelpers_1 = registerDefaultHelpers;
var moveHelperToHooks_1 = moveHelperToHooks; // istanbul ignore next

function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _helpersBlockHelperMissing2 = _interopRequireDefault$7(blockHelperMissing);

var _helpersEach2 = _interopRequireDefault$7(each);

var _helpersHelperMissing2 = _interopRequireDefault$7(helperMissing);

var _helpersIf2 = _interopRequireDefault$7(_if);

var _helpersLog2 = _interopRequireDefault$7(log$1);

var _helpersLookup2 = _interopRequireDefault$7(lookup);

var _helpersWith2 = _interopRequireDefault$7(_with);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);

  _helpersEach2['default'](instance);

  _helpersHelperMissing2['default'](instance);

  _helpersIf2['default'](instance);

  _helpersLog2['default'](instance);

  _helpersLookup2['default'](instance);

  _helpersWith2['default'](instance);
}

function moveHelperToHooks(instance, helperName, keepHelper) {
  if (instance.helpers[helperName]) {
    instance.hooks[helperName] = instance.helpers[helperName];

    if (!keepHelper) {
      delete instance.helpers[helperName];
    }
  }
}

var helpers$1 = /*#__PURE__*/Object.defineProperty({
  registerDefaultHelpers: registerDefaultHelpers_1,
  moveHelperToHooks: moveHelperToHooks_1
}, '__esModule', {
  value: true
});

var inline = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerDecorator('inline', function (fn, props, container, options) {
      var ret = fn;

      if (!props.partials) {
        props.partials = {};

        ret = function ret(context, options) {
          // Create a new partials stack frame prior to exec.
          var original = container.partials;
          container.partials = utils.extend({}, original, props.partials);
          var ret = fn(context, options);
          container.partials = original;
          return ret;
        };
      }

      props.partials[options.args[0]] = options.fn;
      return ret;
    });
  };

  module.exports = exports['default'];
});

var registerDefaultDecorators_1 = registerDefaultDecorators; // istanbul ignore next

function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _decoratorsInline2 = _interopRequireDefault$6(inline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}

var decorators = /*#__PURE__*/Object.defineProperty({
  registerDefaultDecorators: registerDefaultDecorators_1
}, '__esModule', {
  value: true
});

var logger_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var logger = {
    methodMap: ['debug', 'info', 'warn', 'error'],
    level: 'info',
    // Maps a given level value to the `methodMap` indexes above.
    lookupLevel: function lookupLevel(level) {
      if (typeof level === 'string') {
        var levelMap = utils.indexOf(logger.methodMap, level.toLowerCase());

        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }

      return level;
    },
    // Can be overridden in the host environment
    log: function log(level) {
      level = logger.lookupLevel(level);

      if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
        var method = logger.methodMap[level]; // eslint-disable-next-line no-console

        if (!console[method]) {
          method = 'log';
        }

        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }

        console[method].apply(console, message); // eslint-disable-line no-console
      }
    }
  };
  exports['default'] = logger;
  module.exports = exports['default'];
});

var createNewLookupObject_2 = createNewLookupObject;
/**
 * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
 * The resulting object can be used with "object[property]" to check if a property exists
 * @param {...object} sources a varargs parameter of source objects that will be merged
 * @returns {object}
 */

function createNewLookupObject() {
  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  return utils.extend.apply(undefined, [Object.create(null)].concat(sources));
}

var createNewLookupObject_1 = /*#__PURE__*/Object.defineProperty({
  createNewLookupObject: createNewLookupObject_2
}, '__esModule', {
  value: true
});

var createProtoAccessControl_1 = createProtoAccessControl;
var resultIsAllowed_1 = resultIsAllowed;
var resetLoggedProperties_1 = resetLoggedProperties; // istanbul ignore next

function _interopRequireWildcard$2(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj['default'] = obj;
    return newObj;
  }
}

var logger$1 = _interopRequireWildcard$2(logger_1);

var loggedProperties = Object.create(null);

function createProtoAccessControl(runtimeOptions) {
  var defaultMethodWhiteList = Object.create(null);
  defaultMethodWhiteList['constructor'] = false;
  defaultMethodWhiteList['__defineGetter__'] = false;
  defaultMethodWhiteList['__defineSetter__'] = false;
  defaultMethodWhiteList['__lookupGetter__'] = false;
  var defaultPropertyWhiteList = Object.create(null); // eslint-disable-next-line no-proto

  defaultPropertyWhiteList['__proto__'] = false;
  return {
    properties: {
      whitelist: createNewLookupObject_1.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: createNewLookupObject_1.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
      defaultValue: runtimeOptions.allowProtoMethodsByDefault
    }
  };
}

function resultIsAllowed(result, protoAccessControl, propertyName) {
  if (typeof result === 'function') {
    return checkWhiteList(protoAccessControl.methods, propertyName);
  } else {
    return checkWhiteList(protoAccessControl.properties, propertyName);
  }
}

function checkWhiteList(protoAccessControlForType, propertyName) {
  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
    return protoAccessControlForType.whitelist[propertyName] === true;
  }

  if (protoAccessControlForType.defaultValue !== undefined) {
    return protoAccessControlForType.defaultValue;
  }

  logUnexpecedPropertyAccessOnce(propertyName);
  return false;
}

function logUnexpecedPropertyAccessOnce(propertyName) {
  if (loggedProperties[propertyName] !== true) {
    loggedProperties[propertyName] = true;
    logger$1.log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
  }
}

function resetLoggedProperties() {
  Object.keys(loggedProperties).forEach(function (propertyName) {
    delete loggedProperties[propertyName];
  });
}

var protoAccess = /*#__PURE__*/Object.defineProperty({
  createProtoAccessControl: createProtoAccessControl_1,
  resultIsAllowed: resultIsAllowed_1,
  resetLoggedProperties: resetLoggedProperties_1
}, '__esModule', {
  value: true
});

var HandlebarsEnvironment_1 = HandlebarsEnvironment; // istanbul ignore next

function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _exception2$3 = _interopRequireDefault$5(exception);

var _logger2 = _interopRequireDefault$5(logger_1);

var VERSION = '4.7.7';
var VERSION_1 = VERSION;
var COMPILER_REVISION = 8;
var COMPILER_REVISION_1 = COMPILER_REVISION;
var LAST_COMPATIBLE_COMPILER_REVISION = 7;
var LAST_COMPATIBLE_COMPILER_REVISION_1 = LAST_COMPATIBLE_COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2',
  // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0 <4.3.0',
  8: '>= 4.3.0'
};
var REVISION_CHANGES_1 = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators$1) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators$1 || {};

  helpers$1.registerDefaultHelpers(this);

  decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,
  logger: _logger2['default'],
  log: _logger2['default'].log,
  registerHelper: function registerHelper(name, fn) {
    if (utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2$3['default']('Arg not supported with multiple helpers');
      }

      utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },
  registerPartial: function registerPartial(name, partial) {
    if (utils.toString.call(name) === objectType) {
      utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2$3['default']('Attempting to register a partial called "' + name + '" as undefined');
      }

      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },
  registerDecorator: function registerDecorator(name, fn) {
    if (utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2$3['default']('Arg not supported with multiple decorators');
      }

      utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  },

  /**
   * Reset the memory of illegal property accesses that have already been logged.
   * @deprecated should only be used in handlebars test-cases
   */
  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
    protoAccess.resetLoggedProperties();
  }
};
var log = _logger2['default'].log;
var log_1 = log;
var createFrame = utils.createFrame;
var logger = _logger2['default'];
var base$1 = /*#__PURE__*/Object.defineProperty({
  HandlebarsEnvironment: HandlebarsEnvironment_1,
  VERSION: VERSION_1,
  COMPILER_REVISION: COMPILER_REVISION_1,
  LAST_COMPATIBLE_COMPILER_REVISION: LAST_COMPATIBLE_COMPILER_REVISION_1,
  REVISION_CHANGES: REVISION_CHANGES_1,
  log: log_1,
  createFrame: createFrame,
  logger: logger
}, '__esModule', {
  value: true
});

var safeString = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
    return '' + this.string;
  };

  exports['default'] = SafeString;
  module.exports = exports['default'];
});

var wrapHelper_2 = wrapHelper;

function wrapHelper(helper, transformOptionsFn) {
  if (typeof helper !== 'function') {
    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
    return helper;
  }

  var wrapper = function wrapper()
  /* dynamic arguments */
  {
    var options = arguments[arguments.length - 1];
    arguments[arguments.length - 1] = transformOptionsFn(options);
    return helper.apply(this, arguments);
  };

  return wrapper;
}

var wrapHelper_1 = /*#__PURE__*/Object.defineProperty({
  wrapHelper: wrapHelper_2
}, '__esModule', {
  value: true
});

var checkRevision_1 = checkRevision;
var template_1$1 = template;
var wrapProgram_1 = wrapProgram;
var resolvePartial_1 = resolvePartial;
var invokePartial_1 = invokePartial;
var noop_1 = noop; // istanbul ignore next

function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
} // istanbul ignore next


function _interopRequireWildcard$1(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj['default'] = obj;
    return newObj;
  }
}

var Utils = _interopRequireWildcard$1(utils);

var _exception2$2 = _interopRequireDefault$4(exception);

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = base$1.COMPILER_REVISION;

  if (compilerRevision >= base$1.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= base$1.COMPILER_REVISION) {
    return;
  }

  if (compilerRevision < base$1.LAST_COMPATIBLE_COMPILER_REVISION) {
    var runtimeVersions = base$1.REVISION_CHANGES[currentRevision],
        compilerVersions = base$1.REVISION_CHANGES[compilerRevision];
    throw new _exception2$2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
  } else {
    // Use the embedded version info since the runtime doesn't know about this revision yet
    throw new _exception2$2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2$2['default']('No environment passed to template');
  }

  if (!templateSpec || !templateSpec.main) {
    throw new _exception2$2['default']('Unknown template object: ' + _typeof(templateSpec));
  }

  templateSpec.main.decorator = templateSpec.main_d; // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as pseudo-supported APIs.

  env.VM.checkRevision(templateSpec.compiler); // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)

  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);

      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var extendedOptions = Utils.extend({}, options, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    });
    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, extendedOptions);
    }

    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');

        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }

        result = lines.join('\n');
      }

      return result;
    } else {
      throw new _exception2$2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  } // Just add water


  var container = {
    strict: function strict(obj, name, loc) {
      if (!obj || !(name in obj)) {
        throw new _exception2$2['default']('"' + name + '" not defined in ' + obj, {
          loc: loc
        });
      }

      return container.lookupProperty(obj, name);
    },
    lookupProperty: function lookupProperty(parent, propertyName) {
      var result = parent[propertyName];

      if (result == null) {
        return result;
      }

      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return result;
      }

      if (protoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
        return result;
      }

      return undefined;
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;

      for (var i = 0; i < len; i++) {
        var result = depths[i] && container.lookupProperty(depths[i], name);

        if (result != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },
    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);

      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }

      return programWrapper;
    },
    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }

      return value;
    },
    mergeIfNeeded: function mergeIfNeeded(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),
    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var data = options.data;

    ret._setup(options);

    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }

    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;

    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context
    /*, options*/
    ) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }

    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }

  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
      wrapHelpersToPassLookupProperty(mergedHelpers, container);
      container.helpers = mergedHelpers;

      if (templateSpec.usePartial) {
        // Use mergeIfNeeded here to prevent compiling global partials multiple times
        container.partials = container.mergeIfNeeded(options.partials, env.partials);
      }

      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = Utils.extend({}, env.decorators, options.decorators);
      }

      container.hooks = {};
      container.protoAccessControl = protoAccess.createProtoAccessControl(options);
      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;

      helpers$1.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);

      helpers$1.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
    } else {
      container.protoAccessControl = options.protoAccessControl; // internal option

      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
      container.hooks = options.hooks;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2$2['default']('must pass block params');
    }

    if (templateSpec.useDepths && !depths) {
      throw new _exception2$2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };

  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var currentDepths = depths;

    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);
  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}
/**
 * This is currently part of the official API, therefore implementation details should not be changed.
 */


function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }

  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;

  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;

  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = base$1.createFrame(options.data); // Wrapper function to get access to currentPartialBlock from the closure

      var fn = options.fn;

      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1]; // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.

        options.data = base$1.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };

      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2$2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? base$1.createFrame(data) : {};
    data.root = context;
  }

  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }

  return prog;
}

function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
  Object.keys(mergedHelpers).forEach(function (helperName) {
    var helper = mergedHelpers[helperName];
    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
  });
}

function passLookupPropertyOption(helper, container) {
  var lookupProperty = container.lookupProperty;
  return wrapHelper_1.wrapHelper(helper, function (options) {
    return Utils.extend({
      lookupProperty: lookupProperty
    }, options);
  });
}

var runtime = /*#__PURE__*/Object.defineProperty({
  checkRevision: checkRevision_1,
  template: template_1$1,
  wrapProgram: wrapProgram_1,
  resolvePartial: resolvePartial_1,
  invokePartial: invokePartial_1,
  noop: noop_1
}, '__esModule', {
  value: true
});

var noConflict = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (Handlebars) {
    /* istanbul ignore next */
    var root = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : window,
        $Handlebars = root.Handlebars;
    /* istanbul ignore next */

    Handlebars.noConflict = function () {
      if (root.Handlebars === Handlebars) {
        root.Handlebars = $Handlebars;
      }

      return Handlebars;
    };
  };

  module.exports = exports['default'];
});

var handlebars_runtime = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  } // istanbul ignore next


  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj['default'] = obj;
      return newObj;
    }
  }

  var base = _interopRequireWildcard(base$1); // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)


  var _handlebarsSafeString2 = _interopRequireDefault(safeString);

  var _handlebarsException2 = _interopRequireDefault(exception);

  var Utils = _interopRequireWildcard(utils);

  var runtime$1 = _interopRequireWildcard(runtime);

  var _handlebarsNoConflict2 = _interopRequireDefault(noConflict); // For compatibility and usage outside of module systems, make the Handlebars object a namespace


  function create() {
    var hb = new base.HandlebarsEnvironment();
    Utils.extend(hb, base);
    hb.SafeString = _handlebarsSafeString2['default'];
    hb.Exception = _handlebarsException2['default'];
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;
    hb.VM = runtime$1;

    hb.template = function (spec) {
      return runtime$1.template(spec, hb);
    };

    return hb;
  }

  var inst = create();
  inst.create = create;

  _handlebarsNoConflict2['default'](inst);

  inst['default'] = inst;
  exports['default'] = inst;
  module.exports = exports['default'];
});

var ast$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var AST = {
    // Public API used to evaluate derived attributes regarding AST nodes
    helpers: {
      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      helperExpression: function helperExpression(node) {
        return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
      },
      scopedId: function scopedId(path) {
        return /^\.|this\b/.test(path.original);
      },
      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      simpleId: function simpleId(path) {
        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
      }
    }
  }; // Must be exported as an object rather than the root of the module as the jison lexer
  // must modify the object to operate properly.

  exports['default'] = AST;
  module.exports = exports['default'];
});

var parser$2 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  var handlebars = function () {
    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "root": 3,
        "program": 4,
        "EOF": 5,
        "program_repetition0": 6,
        "statement": 7,
        "mustache": 8,
        "block": 9,
        "rawBlock": 10,
        "partial": 11,
        "partialBlock": 12,
        "content": 13,
        "COMMENT": 14,
        "CONTENT": 15,
        "openRawBlock": 16,
        "rawBlock_repetition0": 17,
        "END_RAW_BLOCK": 18,
        "OPEN_RAW_BLOCK": 19,
        "helperName": 20,
        "openRawBlock_repetition0": 21,
        "openRawBlock_option0": 22,
        "CLOSE_RAW_BLOCK": 23,
        "openBlock": 24,
        "block_option0": 25,
        "closeBlock": 26,
        "openInverse": 27,
        "block_option1": 28,
        "OPEN_BLOCK": 29,
        "openBlock_repetition0": 30,
        "openBlock_option0": 31,
        "openBlock_option1": 32,
        "CLOSE": 33,
        "OPEN_INVERSE": 34,
        "openInverse_repetition0": 35,
        "openInverse_option0": 36,
        "openInverse_option1": 37,
        "openInverseChain": 38,
        "OPEN_INVERSE_CHAIN": 39,
        "openInverseChain_repetition0": 40,
        "openInverseChain_option0": 41,
        "openInverseChain_option1": 42,
        "inverseAndProgram": 43,
        "INVERSE": 44,
        "inverseChain": 45,
        "inverseChain_option0": 46,
        "OPEN_ENDBLOCK": 47,
        "OPEN": 48,
        "mustache_repetition0": 49,
        "mustache_option0": 50,
        "OPEN_UNESCAPED": 51,
        "mustache_repetition1": 52,
        "mustache_option1": 53,
        "CLOSE_UNESCAPED": 54,
        "OPEN_PARTIAL": 55,
        "partialName": 56,
        "partial_repetition0": 57,
        "partial_option0": 58,
        "openPartialBlock": 59,
        "OPEN_PARTIAL_BLOCK": 60,
        "openPartialBlock_repetition0": 61,
        "openPartialBlock_option0": 62,
        "param": 63,
        "sexpr": 64,
        "OPEN_SEXPR": 65,
        "sexpr_repetition0": 66,
        "sexpr_option0": 67,
        "CLOSE_SEXPR": 68,
        "hash": 69,
        "hash_repetition_plus0": 70,
        "hashSegment": 71,
        "ID": 72,
        "EQUALS": 73,
        "blockParams": 74,
        "OPEN_BLOCK_PARAMS": 75,
        "blockParams_repetition_plus0": 76,
        "CLOSE_BLOCK_PARAMS": 77,
        "path": 78,
        "dataName": 79,
        "STRING": 80,
        "NUMBER": 81,
        "BOOLEAN": 82,
        "UNDEFINED": 83,
        "NULL": 84,
        "DATA": 85,
        "pathSegments": 86,
        "SEP": 87,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        5: "EOF",
        14: "COMMENT",
        15: "CONTENT",
        18: "END_RAW_BLOCK",
        19: "OPEN_RAW_BLOCK",
        23: "CLOSE_RAW_BLOCK",
        29: "OPEN_BLOCK",
        33: "CLOSE",
        34: "OPEN_INVERSE",
        39: "OPEN_INVERSE_CHAIN",
        44: "INVERSE",
        47: "OPEN_ENDBLOCK",
        48: "OPEN",
        51: "OPEN_UNESCAPED",
        54: "CLOSE_UNESCAPED",
        55: "OPEN_PARTIAL",
        60: "OPEN_PARTIAL_BLOCK",
        65: "OPEN_SEXPR",
        68: "CLOSE_SEXPR",
        72: "ID",
        73: "EQUALS",
        75: "OPEN_BLOCK_PARAMS",
        77: "CLOSE_BLOCK_PARAMS",
        80: "STRING",
        81: "NUMBER",
        82: "BOOLEAN",
        83: "UNDEFINED",
        84: "NULL",
        85: "DATA",
        87: "SEP"
      },
      productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
            return $$[$0 - 1];

          case 2:
            this.$ = yy.prepareProgram($$[$0]);
            break;

          case 3:
            this.$ = $$[$0];
            break;

          case 4:
            this.$ = $$[$0];
            break;

          case 5:
            this.$ = $$[$0];
            break;

          case 6:
            this.$ = $$[$0];
            break;

          case 7:
            this.$ = $$[$0];
            break;

          case 8:
            this.$ = $$[$0];
            break;

          case 9:
            this.$ = {
              type: 'CommentStatement',
              value: yy.stripComment($$[$0]),
              strip: yy.stripFlags($$[$0], $$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;

          case 10:
            this.$ = {
              type: 'ContentStatement',
              original: $$[$0],
              value: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;

          case 11:
            this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;

          case 12:
            this.$ = {
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1]
            };
            break;

          case 13:
            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
            break;

          case 14:
            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
            break;

          case 15:
            this.$ = {
              open: $$[$0 - 5],
              path: $$[$0 - 4],
              params: $$[$0 - 3],
              hash: $$[$0 - 2],
              blockParams: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 5], $$[$0])
            };
            break;

          case 16:
            this.$ = {
              path: $$[$0 - 4],
              params: $$[$0 - 3],
              hash: $$[$0 - 2],
              blockParams: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 5], $$[$0])
            };
            break;

          case 17:
            this.$ = {
              path: $$[$0 - 4],
              params: $$[$0 - 3],
              hash: $$[$0 - 2],
              blockParams: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 5], $$[$0])
            };
            break;

          case 18:
            this.$ = {
              strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]),
              program: $$[$0]
            };
            break;

          case 19:
            var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
            program.chained = true;
            this.$ = {
              strip: $$[$0 - 2].strip,
              program: program,
              chain: true
            };
            break;

          case 20:
            this.$ = $$[$0];
            break;

          case 21:
            this.$ = {
              path: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 2], $$[$0])
            };
            break;

          case 22:
            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;

          case 23:
            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;

          case 24:
            this.$ = {
              type: 'PartialStatement',
              name: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              indent: '',
              strip: yy.stripFlags($$[$0 - 4], $$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;

          case 25:
            this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;

          case 26:
            this.$ = {
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 4], $$[$0])
            };
            break;

          case 27:
            this.$ = $$[$0];
            break;

          case 28:
            this.$ = $$[$0];
            break;

          case 29:
            this.$ = {
              type: 'SubExpression',
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              loc: yy.locInfo(this._$)
            };
            break;

          case 30:
            this.$ = {
              type: 'Hash',
              pairs: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;

          case 31:
            this.$ = {
              type: 'HashPair',
              key: yy.id($$[$0 - 2]),
              value: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;

          case 32:
            this.$ = yy.id($$[$0 - 1]);
            break;

          case 33:
            this.$ = $$[$0];
            break;

          case 34:
            this.$ = $$[$0];
            break;

          case 35:
            this.$ = {
              type: 'StringLiteral',
              value: $$[$0],
              original: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;

          case 36:
            this.$ = {
              type: 'NumberLiteral',
              value: Number($$[$0]),
              original: Number($$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;

          case 37:
            this.$ = {
              type: 'BooleanLiteral',
              value: $$[$0] === 'true',
              original: $$[$0] === 'true',
              loc: yy.locInfo(this._$)
            };
            break;

          case 38:
            this.$ = {
              type: 'UndefinedLiteral',
              original: undefined,
              value: undefined,
              loc: yy.locInfo(this._$)
            };
            break;

          case 39:
            this.$ = {
              type: 'NullLiteral',
              original: null,
              value: null,
              loc: yy.locInfo(this._$)
            };
            break;

          case 40:
            this.$ = $$[$0];
            break;

          case 41:
            this.$ = $$[$0];
            break;

          case 42:
            this.$ = yy.preparePath(true, $$[$0], this._$);
            break;

          case 43:
            this.$ = yy.preparePath(false, $$[$0], this._$);
            break;

          case 44:
            $$[$0 - 2].push({
              part: yy.id($$[$0]),
              original: $$[$0],
              separator: $$[$0 - 1]
            });
            this.$ = $$[$0 - 2];
            break;

          case 45:
            this.$ = [{
              part: yy.id($$[$0]),
              original: $$[$0]
            }];
            break;

          case 46:
            this.$ = [];
            break;

          case 47:
            $$[$0 - 1].push($$[$0]);
            break;

          case 48:
            this.$ = [];
            break;

          case 49:
            $$[$0 - 1].push($$[$0]);
            break;

          case 50:
            this.$ = [];
            break;

          case 51:
            $$[$0 - 1].push($$[$0]);
            break;

          case 58:
            this.$ = [];
            break;

          case 59:
            $$[$0 - 1].push($$[$0]);
            break;

          case 64:
            this.$ = [];
            break;

          case 65:
            $$[$0 - 1].push($$[$0]);
            break;

          case 70:
            this.$ = [];
            break;

          case 71:
            $$[$0 - 1].push($$[$0]);
            break;

          case 78:
            this.$ = [];
            break;

          case 79:
            $$[$0 - 1].push($$[$0]);
            break;

          case 82:
            this.$ = [];
            break;

          case 83:
            $$[$0 - 1].push($$[$0]);
            break;

          case 86:
            this.$ = [];
            break;

          case 87:
            $$[$0 - 1].push($$[$0]);
            break;

          case 90:
            this.$ = [];
            break;

          case 91:
            $$[$0 - 1].push($$[$0]);
            break;

          case 94:
            this.$ = [];
            break;

          case 95:
            $$[$0 - 1].push($$[$0]);
            break;

          case 98:
            this.$ = [$$[$0]];
            break;

          case 99:
            $$[$0 - 1].push($$[$0]);
            break;

          case 100:
            this.$ = [$$[$0]];
            break;

          case 101:
            $$[$0 - 1].push($$[$0]);
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        5: [2, 46],
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        1: [3]
      }, {
        5: [1, 4]
      }, {
        5: [2, 2],
        7: 5,
        8: 6,
        9: 7,
        10: 8,
        11: 9,
        12: 10,
        13: 11,
        14: [1, 12],
        15: [1, 20],
        16: 17,
        19: [1, 23],
        24: 15,
        27: 16,
        29: [1, 21],
        34: [1, 22],
        39: [2, 2],
        44: [2, 2],
        47: [2, 2],
        48: [1, 13],
        51: [1, 14],
        55: [1, 18],
        59: 19,
        60: [1, 24]
      }, {
        1: [2, 1]
      }, {
        5: [2, 47],
        14: [2, 47],
        15: [2, 47],
        19: [2, 47],
        29: [2, 47],
        34: [2, 47],
        39: [2, 47],
        44: [2, 47],
        47: [2, 47],
        48: [2, 47],
        51: [2, 47],
        55: [2, 47],
        60: [2, 47]
      }, {
        5: [2, 3],
        14: [2, 3],
        15: [2, 3],
        19: [2, 3],
        29: [2, 3],
        34: [2, 3],
        39: [2, 3],
        44: [2, 3],
        47: [2, 3],
        48: [2, 3],
        51: [2, 3],
        55: [2, 3],
        60: [2, 3]
      }, {
        5: [2, 4],
        14: [2, 4],
        15: [2, 4],
        19: [2, 4],
        29: [2, 4],
        34: [2, 4],
        39: [2, 4],
        44: [2, 4],
        47: [2, 4],
        48: [2, 4],
        51: [2, 4],
        55: [2, 4],
        60: [2, 4]
      }, {
        5: [2, 5],
        14: [2, 5],
        15: [2, 5],
        19: [2, 5],
        29: [2, 5],
        34: [2, 5],
        39: [2, 5],
        44: [2, 5],
        47: [2, 5],
        48: [2, 5],
        51: [2, 5],
        55: [2, 5],
        60: [2, 5]
      }, {
        5: [2, 6],
        14: [2, 6],
        15: [2, 6],
        19: [2, 6],
        29: [2, 6],
        34: [2, 6],
        39: [2, 6],
        44: [2, 6],
        47: [2, 6],
        48: [2, 6],
        51: [2, 6],
        55: [2, 6],
        60: [2, 6]
      }, {
        5: [2, 7],
        14: [2, 7],
        15: [2, 7],
        19: [2, 7],
        29: [2, 7],
        34: [2, 7],
        39: [2, 7],
        44: [2, 7],
        47: [2, 7],
        48: [2, 7],
        51: [2, 7],
        55: [2, 7],
        60: [2, 7]
      }, {
        5: [2, 8],
        14: [2, 8],
        15: [2, 8],
        19: [2, 8],
        29: [2, 8],
        34: [2, 8],
        39: [2, 8],
        44: [2, 8],
        47: [2, 8],
        48: [2, 8],
        51: [2, 8],
        55: [2, 8],
        60: [2, 8]
      }, {
        5: [2, 9],
        14: [2, 9],
        15: [2, 9],
        19: [2, 9],
        29: [2, 9],
        34: [2, 9],
        39: [2, 9],
        44: [2, 9],
        47: [2, 9],
        48: [2, 9],
        51: [2, 9],
        55: [2, 9],
        60: [2, 9]
      }, {
        20: 25,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 36,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        4: 37,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        39: [2, 46],
        44: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        4: 38,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        44: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        15: [2, 48],
        17: 39,
        18: [2, 48]
      }, {
        20: 41,
        56: 40,
        64: 42,
        65: [1, 43],
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        4: 44,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        5: [2, 10],
        14: [2, 10],
        15: [2, 10],
        18: [2, 10],
        19: [2, 10],
        29: [2, 10],
        34: [2, 10],
        39: [2, 10],
        44: [2, 10],
        47: [2, 10],
        48: [2, 10],
        51: [2, 10],
        55: [2, 10],
        60: [2, 10]
      }, {
        20: 45,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 46,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 47,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 41,
        56: 48,
        64: 42,
        65: [1, 43],
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        33: [2, 78],
        49: 49,
        65: [2, 78],
        72: [2, 78],
        80: [2, 78],
        81: [2, 78],
        82: [2, 78],
        83: [2, 78],
        84: [2, 78],
        85: [2, 78]
      }, {
        23: [2, 33],
        33: [2, 33],
        54: [2, 33],
        65: [2, 33],
        68: [2, 33],
        72: [2, 33],
        75: [2, 33],
        80: [2, 33],
        81: [2, 33],
        82: [2, 33],
        83: [2, 33],
        84: [2, 33],
        85: [2, 33]
      }, {
        23: [2, 34],
        33: [2, 34],
        54: [2, 34],
        65: [2, 34],
        68: [2, 34],
        72: [2, 34],
        75: [2, 34],
        80: [2, 34],
        81: [2, 34],
        82: [2, 34],
        83: [2, 34],
        84: [2, 34],
        85: [2, 34]
      }, {
        23: [2, 35],
        33: [2, 35],
        54: [2, 35],
        65: [2, 35],
        68: [2, 35],
        72: [2, 35],
        75: [2, 35],
        80: [2, 35],
        81: [2, 35],
        82: [2, 35],
        83: [2, 35],
        84: [2, 35],
        85: [2, 35]
      }, {
        23: [2, 36],
        33: [2, 36],
        54: [2, 36],
        65: [2, 36],
        68: [2, 36],
        72: [2, 36],
        75: [2, 36],
        80: [2, 36],
        81: [2, 36],
        82: [2, 36],
        83: [2, 36],
        84: [2, 36],
        85: [2, 36]
      }, {
        23: [2, 37],
        33: [2, 37],
        54: [2, 37],
        65: [2, 37],
        68: [2, 37],
        72: [2, 37],
        75: [2, 37],
        80: [2, 37],
        81: [2, 37],
        82: [2, 37],
        83: [2, 37],
        84: [2, 37],
        85: [2, 37]
      }, {
        23: [2, 38],
        33: [2, 38],
        54: [2, 38],
        65: [2, 38],
        68: [2, 38],
        72: [2, 38],
        75: [2, 38],
        80: [2, 38],
        81: [2, 38],
        82: [2, 38],
        83: [2, 38],
        84: [2, 38],
        85: [2, 38]
      }, {
        23: [2, 39],
        33: [2, 39],
        54: [2, 39],
        65: [2, 39],
        68: [2, 39],
        72: [2, 39],
        75: [2, 39],
        80: [2, 39],
        81: [2, 39],
        82: [2, 39],
        83: [2, 39],
        84: [2, 39],
        85: [2, 39]
      }, {
        23: [2, 43],
        33: [2, 43],
        54: [2, 43],
        65: [2, 43],
        68: [2, 43],
        72: [2, 43],
        75: [2, 43],
        80: [2, 43],
        81: [2, 43],
        82: [2, 43],
        83: [2, 43],
        84: [2, 43],
        85: [2, 43],
        87: [1, 50]
      }, {
        72: [1, 35],
        86: 51
      }, {
        23: [2, 45],
        33: [2, 45],
        54: [2, 45],
        65: [2, 45],
        68: [2, 45],
        72: [2, 45],
        75: [2, 45],
        80: [2, 45],
        81: [2, 45],
        82: [2, 45],
        83: [2, 45],
        84: [2, 45],
        85: [2, 45],
        87: [2, 45]
      }, {
        52: 52,
        54: [2, 82],
        65: [2, 82],
        72: [2, 82],
        80: [2, 82],
        81: [2, 82],
        82: [2, 82],
        83: [2, 82],
        84: [2, 82],
        85: [2, 82]
      }, {
        25: 53,
        38: 55,
        39: [1, 57],
        43: 56,
        44: [1, 58],
        45: 54,
        47: [2, 54]
      }, {
        28: 59,
        43: 60,
        44: [1, 58],
        47: [2, 56]
      }, {
        13: 62,
        15: [1, 20],
        18: [1, 61]
      }, {
        33: [2, 86],
        57: 63,
        65: [2, 86],
        72: [2, 86],
        80: [2, 86],
        81: [2, 86],
        82: [2, 86],
        83: [2, 86],
        84: [2, 86],
        85: [2, 86]
      }, {
        33: [2, 40],
        65: [2, 40],
        72: [2, 40],
        80: [2, 40],
        81: [2, 40],
        82: [2, 40],
        83: [2, 40],
        84: [2, 40],
        85: [2, 40]
      }, {
        33: [2, 41],
        65: [2, 41],
        72: [2, 41],
        80: [2, 41],
        81: [2, 41],
        82: [2, 41],
        83: [2, 41],
        84: [2, 41],
        85: [2, 41]
      }, {
        20: 64,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        26: 65,
        47: [1, 66]
      }, {
        30: 67,
        33: [2, 58],
        65: [2, 58],
        72: [2, 58],
        75: [2, 58],
        80: [2, 58],
        81: [2, 58],
        82: [2, 58],
        83: [2, 58],
        84: [2, 58],
        85: [2, 58]
      }, {
        33: [2, 64],
        35: 68,
        65: [2, 64],
        72: [2, 64],
        75: [2, 64],
        80: [2, 64],
        81: [2, 64],
        82: [2, 64],
        83: [2, 64],
        84: [2, 64],
        85: [2, 64]
      }, {
        21: 69,
        23: [2, 50],
        65: [2, 50],
        72: [2, 50],
        80: [2, 50],
        81: [2, 50],
        82: [2, 50],
        83: [2, 50],
        84: [2, 50],
        85: [2, 50]
      }, {
        33: [2, 90],
        61: 70,
        65: [2, 90],
        72: [2, 90],
        80: [2, 90],
        81: [2, 90],
        82: [2, 90],
        83: [2, 90],
        84: [2, 90],
        85: [2, 90]
      }, {
        20: 74,
        33: [2, 80],
        50: 71,
        63: 72,
        64: 75,
        65: [1, 43],
        69: 73,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        72: [1, 79]
      }, {
        23: [2, 42],
        33: [2, 42],
        54: [2, 42],
        65: [2, 42],
        68: [2, 42],
        72: [2, 42],
        75: [2, 42],
        80: [2, 42],
        81: [2, 42],
        82: [2, 42],
        83: [2, 42],
        84: [2, 42],
        85: [2, 42],
        87: [1, 50]
      }, {
        20: 74,
        53: 80,
        54: [2, 84],
        63: 81,
        64: 75,
        65: [1, 43],
        69: 82,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        26: 83,
        47: [1, 66]
      }, {
        47: [2, 55]
      }, {
        4: 84,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        39: [2, 46],
        44: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        47: [2, 20]
      }, {
        20: 85,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        4: 86,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        26: 87,
        47: [1, 66]
      }, {
        47: [2, 57]
      }, {
        5: [2, 11],
        14: [2, 11],
        15: [2, 11],
        19: [2, 11],
        29: [2, 11],
        34: [2, 11],
        39: [2, 11],
        44: [2, 11],
        47: [2, 11],
        48: [2, 11],
        51: [2, 11],
        55: [2, 11],
        60: [2, 11]
      }, {
        15: [2, 49],
        18: [2, 49]
      }, {
        20: 74,
        33: [2, 88],
        58: 88,
        63: 89,
        64: 75,
        65: [1, 43],
        69: 90,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        65: [2, 94],
        66: 91,
        68: [2, 94],
        72: [2, 94],
        80: [2, 94],
        81: [2, 94],
        82: [2, 94],
        83: [2, 94],
        84: [2, 94],
        85: [2, 94]
      }, {
        5: [2, 25],
        14: [2, 25],
        15: [2, 25],
        19: [2, 25],
        29: [2, 25],
        34: [2, 25],
        39: [2, 25],
        44: [2, 25],
        47: [2, 25],
        48: [2, 25],
        51: [2, 25],
        55: [2, 25],
        60: [2, 25]
      }, {
        20: 92,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        31: 93,
        33: [2, 60],
        63: 94,
        64: 75,
        65: [1, 43],
        69: 95,
        70: 76,
        71: 77,
        72: [1, 78],
        75: [2, 60],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        33: [2, 66],
        36: 96,
        63: 97,
        64: 75,
        65: [1, 43],
        69: 98,
        70: 76,
        71: 77,
        72: [1, 78],
        75: [2, 66],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        22: 99,
        23: [2, 52],
        63: 100,
        64: 75,
        65: [1, 43],
        69: 101,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        33: [2, 92],
        62: 102,
        63: 103,
        64: 75,
        65: [1, 43],
        69: 104,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        33: [1, 105]
      }, {
        33: [2, 79],
        65: [2, 79],
        72: [2, 79],
        80: [2, 79],
        81: [2, 79],
        82: [2, 79],
        83: [2, 79],
        84: [2, 79],
        85: [2, 79]
      }, {
        33: [2, 81]
      }, {
        23: [2, 27],
        33: [2, 27],
        54: [2, 27],
        65: [2, 27],
        68: [2, 27],
        72: [2, 27],
        75: [2, 27],
        80: [2, 27],
        81: [2, 27],
        82: [2, 27],
        83: [2, 27],
        84: [2, 27],
        85: [2, 27]
      }, {
        23: [2, 28],
        33: [2, 28],
        54: [2, 28],
        65: [2, 28],
        68: [2, 28],
        72: [2, 28],
        75: [2, 28],
        80: [2, 28],
        81: [2, 28],
        82: [2, 28],
        83: [2, 28],
        84: [2, 28],
        85: [2, 28]
      }, {
        23: [2, 30],
        33: [2, 30],
        54: [2, 30],
        68: [2, 30],
        71: 106,
        72: [1, 107],
        75: [2, 30]
      }, {
        23: [2, 98],
        33: [2, 98],
        54: [2, 98],
        68: [2, 98],
        72: [2, 98],
        75: [2, 98]
      }, {
        23: [2, 45],
        33: [2, 45],
        54: [2, 45],
        65: [2, 45],
        68: [2, 45],
        72: [2, 45],
        73: [1, 108],
        75: [2, 45],
        80: [2, 45],
        81: [2, 45],
        82: [2, 45],
        83: [2, 45],
        84: [2, 45],
        85: [2, 45],
        87: [2, 45]
      }, {
        23: [2, 44],
        33: [2, 44],
        54: [2, 44],
        65: [2, 44],
        68: [2, 44],
        72: [2, 44],
        75: [2, 44],
        80: [2, 44],
        81: [2, 44],
        82: [2, 44],
        83: [2, 44],
        84: [2, 44],
        85: [2, 44],
        87: [2, 44]
      }, {
        54: [1, 109]
      }, {
        54: [2, 83],
        65: [2, 83],
        72: [2, 83],
        80: [2, 83],
        81: [2, 83],
        82: [2, 83],
        83: [2, 83],
        84: [2, 83],
        85: [2, 83]
      }, {
        54: [2, 85]
      }, {
        5: [2, 13],
        14: [2, 13],
        15: [2, 13],
        19: [2, 13],
        29: [2, 13],
        34: [2, 13],
        39: [2, 13],
        44: [2, 13],
        47: [2, 13],
        48: [2, 13],
        51: [2, 13],
        55: [2, 13],
        60: [2, 13]
      }, {
        38: 55,
        39: [1, 57],
        43: 56,
        44: [1, 58],
        45: 111,
        46: 110,
        47: [2, 76]
      }, {
        33: [2, 70],
        40: 112,
        65: [2, 70],
        72: [2, 70],
        75: [2, 70],
        80: [2, 70],
        81: [2, 70],
        82: [2, 70],
        83: [2, 70],
        84: [2, 70],
        85: [2, 70]
      }, {
        47: [2, 18]
      }, {
        5: [2, 14],
        14: [2, 14],
        15: [2, 14],
        19: [2, 14],
        29: [2, 14],
        34: [2, 14],
        39: [2, 14],
        44: [2, 14],
        47: [2, 14],
        48: [2, 14],
        51: [2, 14],
        55: [2, 14],
        60: [2, 14]
      }, {
        33: [1, 113]
      }, {
        33: [2, 87],
        65: [2, 87],
        72: [2, 87],
        80: [2, 87],
        81: [2, 87],
        82: [2, 87],
        83: [2, 87],
        84: [2, 87],
        85: [2, 87]
      }, {
        33: [2, 89]
      }, {
        20: 74,
        63: 115,
        64: 75,
        65: [1, 43],
        67: 114,
        68: [2, 96],
        69: 116,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        33: [1, 117]
      }, {
        32: 118,
        33: [2, 62],
        74: 119,
        75: [1, 120]
      }, {
        33: [2, 59],
        65: [2, 59],
        72: [2, 59],
        75: [2, 59],
        80: [2, 59],
        81: [2, 59],
        82: [2, 59],
        83: [2, 59],
        84: [2, 59],
        85: [2, 59]
      }, {
        33: [2, 61],
        75: [2, 61]
      }, {
        33: [2, 68],
        37: 121,
        74: 122,
        75: [1, 120]
      }, {
        33: [2, 65],
        65: [2, 65],
        72: [2, 65],
        75: [2, 65],
        80: [2, 65],
        81: [2, 65],
        82: [2, 65],
        83: [2, 65],
        84: [2, 65],
        85: [2, 65]
      }, {
        33: [2, 67],
        75: [2, 67]
      }, {
        23: [1, 123]
      }, {
        23: [2, 51],
        65: [2, 51],
        72: [2, 51],
        80: [2, 51],
        81: [2, 51],
        82: [2, 51],
        83: [2, 51],
        84: [2, 51],
        85: [2, 51]
      }, {
        23: [2, 53]
      }, {
        33: [1, 124]
      }, {
        33: [2, 91],
        65: [2, 91],
        72: [2, 91],
        80: [2, 91],
        81: [2, 91],
        82: [2, 91],
        83: [2, 91],
        84: [2, 91],
        85: [2, 91]
      }, {
        33: [2, 93]
      }, {
        5: [2, 22],
        14: [2, 22],
        15: [2, 22],
        19: [2, 22],
        29: [2, 22],
        34: [2, 22],
        39: [2, 22],
        44: [2, 22],
        47: [2, 22],
        48: [2, 22],
        51: [2, 22],
        55: [2, 22],
        60: [2, 22]
      }, {
        23: [2, 99],
        33: [2, 99],
        54: [2, 99],
        68: [2, 99],
        72: [2, 99],
        75: [2, 99]
      }, {
        73: [1, 108]
      }, {
        20: 74,
        63: 125,
        64: 75,
        65: [1, 43],
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        5: [2, 23],
        14: [2, 23],
        15: [2, 23],
        19: [2, 23],
        29: [2, 23],
        34: [2, 23],
        39: [2, 23],
        44: [2, 23],
        47: [2, 23],
        48: [2, 23],
        51: [2, 23],
        55: [2, 23],
        60: [2, 23]
      }, {
        47: [2, 19]
      }, {
        47: [2, 77]
      }, {
        20: 74,
        33: [2, 72],
        41: 126,
        63: 127,
        64: 75,
        65: [1, 43],
        69: 128,
        70: 76,
        71: 77,
        72: [1, 78],
        75: [2, 72],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        5: [2, 24],
        14: [2, 24],
        15: [2, 24],
        19: [2, 24],
        29: [2, 24],
        34: [2, 24],
        39: [2, 24],
        44: [2, 24],
        47: [2, 24],
        48: [2, 24],
        51: [2, 24],
        55: [2, 24],
        60: [2, 24]
      }, {
        68: [1, 129]
      }, {
        65: [2, 95],
        68: [2, 95],
        72: [2, 95],
        80: [2, 95],
        81: [2, 95],
        82: [2, 95],
        83: [2, 95],
        84: [2, 95],
        85: [2, 95]
      }, {
        68: [2, 97]
      }, {
        5: [2, 21],
        14: [2, 21],
        15: [2, 21],
        19: [2, 21],
        29: [2, 21],
        34: [2, 21],
        39: [2, 21],
        44: [2, 21],
        47: [2, 21],
        48: [2, 21],
        51: [2, 21],
        55: [2, 21],
        60: [2, 21]
      }, {
        33: [1, 130]
      }, {
        33: [2, 63]
      }, {
        72: [1, 132],
        76: 131
      }, {
        33: [1, 133]
      }, {
        33: [2, 69]
      }, {
        15: [2, 12],
        18: [2, 12]
      }, {
        14: [2, 26],
        15: [2, 26],
        19: [2, 26],
        29: [2, 26],
        34: [2, 26],
        47: [2, 26],
        48: [2, 26],
        51: [2, 26],
        55: [2, 26],
        60: [2, 26]
      }, {
        23: [2, 31],
        33: [2, 31],
        54: [2, 31],
        68: [2, 31],
        72: [2, 31],
        75: [2, 31]
      }, {
        33: [2, 74],
        42: 134,
        74: 135,
        75: [1, 120]
      }, {
        33: [2, 71],
        65: [2, 71],
        72: [2, 71],
        75: [2, 71],
        80: [2, 71],
        81: [2, 71],
        82: [2, 71],
        83: [2, 71],
        84: [2, 71],
        85: [2, 71]
      }, {
        33: [2, 73],
        75: [2, 73]
      }, {
        23: [2, 29],
        33: [2, 29],
        54: [2, 29],
        65: [2, 29],
        68: [2, 29],
        72: [2, 29],
        75: [2, 29],
        80: [2, 29],
        81: [2, 29],
        82: [2, 29],
        83: [2, 29],
        84: [2, 29],
        85: [2, 29]
      }, {
        14: [2, 15],
        15: [2, 15],
        19: [2, 15],
        29: [2, 15],
        34: [2, 15],
        39: [2, 15],
        44: [2, 15],
        47: [2, 15],
        48: [2, 15],
        51: [2, 15],
        55: [2, 15],
        60: [2, 15]
      }, {
        72: [1, 137],
        77: [1, 136]
      }, {
        72: [2, 100],
        77: [2, 100]
      }, {
        14: [2, 16],
        15: [2, 16],
        19: [2, 16],
        29: [2, 16],
        34: [2, 16],
        44: [2, 16],
        47: [2, 16],
        48: [2, 16],
        51: [2, 16],
        55: [2, 16],
        60: [2, 16]
      }, {
        33: [1, 138]
      }, {
        33: [2, 75]
      }, {
        33: [2, 32]
      }, {
        72: [2, 101],
        77: [2, 101]
      }, {
        14: [2, 17],
        15: [2, 17],
        19: [2, 17],
        29: [2, 17],
        34: [2, 17],
        39: [2, 17],
        44: [2, 17],
        47: [2, 17],
        48: [2, 17],
        51: [2, 17],
        55: [2, 17],
        60: [2, 17]
      }],
      defaultActions: {
        4: [2, 1],
        54: [2, 55],
        56: [2, 20],
        60: [2, 57],
        73: [2, 81],
        82: [2, 85],
        86: [2, 18],
        90: [2, 89],
        101: [2, 53],
        104: [2, 93],
        110: [2, 19],
        111: [2, 77],
        116: [2, 97],
        119: [2, 63],
        122: [2, 69],
        135: [2, 75],
        136: [2, 32]
      },
      parseError: function parseError(str, hash) {
        throw new Error(str);
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = "",
            yylineno = 0,
            yyleng = 0,
            recovering = 0;
        this.lexer.setInput(input);
        this.lexer.yy = this.yy;
        this.yy.lexer = this.lexer;
        this.yy.parser = this;
        if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
        var yyloc = this.lexer.yylloc;
        lstack.push(yyloc);
        var ranges = this.lexer.options && this.lexer.options.ranges;
        if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;

        function lex() {
          var token;
          token = self.lexer.lex() || 1;

          if (typeof token !== "number") {
            token = self.symbols_[token] || token;
          }

          return token;
        }

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";

            if (!recovering) {
              expected = [];

              for (p in table[state]) {
                if (this.terminals_[p] && p > 2) {
                  expected.push("'" + this.terminals_[p] + "'");
                }
              }

              if (this.lexer.showPosition) {
                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
              } else {
                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
              }

              this.parseError(errStr, {
                text: this.lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: this.lexer.yylineno,
                loc: yyloc,
                expected: expected
              });
            }
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;

              {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0) recovering--;
              }

              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

              if (typeof r !== "undefined") {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* Jison generated lexer */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function setInput(input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) this.yylloc.range = [0, 0];
          this.offset = 0;
          return this;
        },
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) this.yylloc.range[1]++;
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len - 1); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) this.yylineno -= lines.length - 1;
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          return this;
        },
        more: function more() {
          this._more = true;
          return this;
        },
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) this.done = true;
          var token, match, tempMatch, index, lines;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;
              if (!this.options.flex) break;
            }
          }

          if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) this.yylineno += lines.length;
            this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
            };
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;

            if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }

            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input) this.done = false;
            if (token) return token;else return;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();

          if (typeof r !== 'undefined') {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          return this.conditionStack.pop();
        },
        _currentRules: function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        },
        topState: function topState() {
          return this.conditionStack[this.conditionStack.length - 2];
        },
        pushState: function begin(condition) {
          this.begin(condition);
        }
      };
      lexer.options = {};

      lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        function strip(start, end) {
          return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
        }

        switch ($avoiding_name_collisions) {
          case 0:
            if (yy_.yytext.slice(-2) === "\\\\") {
              strip(0, 1);
              this.begin("mu");
            } else if (yy_.yytext.slice(-1) === "\\") {
              strip(0, 1);
              this.begin("emu");
            } else {
              this.begin("mu");
            }

            if (yy_.yytext) return 15;
            break;

          case 1:
            return 15;

          case 2:
            this.popState();
            return 15;

          case 3:
            this.begin('raw');
            return 15;

          case 4:
            this.popState(); // Should be using `this.topState()` below, but it currently
            // returns the second top instead of the first top. Opened an
            // issue about it at https://github.com/zaach/jison/issues/291

            if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
              return 15;
            } else {
              strip(5, 9);
              return 'END_RAW_BLOCK';
            }

          case 5:
            return 15;

          case 6:
            this.popState();
            return 14;

          case 7:
            return 65;

          case 8:
            return 68;

          case 9:
            return 19;

          case 10:
            this.popState();
            this.begin('raw');
            return 23;

          case 11:
            return 55;

          case 12:
            return 60;

          case 13:
            return 29;

          case 14:
            return 47;

          case 15:
            this.popState();
            return 44;

          case 16:
            this.popState();
            return 44;

          case 17:
            return 34;

          case 18:
            return 39;

          case 19:
            return 51;

          case 20:
            return 48;

          case 21:
            this.unput(yy_.yytext);
            this.popState();
            this.begin('com');
            break;

          case 22:
            this.popState();
            return 14;

          case 23:
            return 48;

          case 24:
            return 73;

          case 25:
            return 72;

          case 26:
            return 72;

          case 27:
            return 87;

          case 28:
            // ignore whitespace
            break;

          case 29:
            this.popState();
            return 54;

          case 30:
            this.popState();
            return 33;

          case 31:
            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
            return 80;

          case 32:
            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
            return 80;

          case 33:
            return 85;

          case 34:
            return 82;

          case 35:
            return 82;

          case 36:
            return 83;

          case 37:
            return 84;

          case 38:
            return 81;

          case 39:
            return 75;

          case 40:
            return 77;

          case 41:
            return 72;

          case 42:
            yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');
            return 72;

          case 43:
            return 'INVALID';

          case 44:
            return 5;
        }
      };

      lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
      lexer.conditions = {
        "mu": {
          "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
          "inclusive": false
        },
        "emu": {
          "rules": [2],
          "inclusive": false
        },
        "com": {
          "rules": [6],
          "inclusive": false
        },
        "raw": {
          "rules": [3, 4, 5],
          "inclusive": false
        },
        "INITIAL": {
          "rules": [0, 1, 44],
          "inclusive": true
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  exports["default"] = handlebars;
  module.exports = exports["default"];
});

var visitor = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _exception2 = _interopRequireDefault(exception);

  function Visitor() {
    this.parents = [];
  }

  Visitor.prototype = {
    constructor: Visitor,
    mutating: false,
    // Visits a given value. If mutating, will replace the value if necessary.
    acceptKey: function acceptKey(node, name) {
      var value = this.accept(node[name]);

      if (this.mutating) {
        // Hacky sanity check: This may have a few false positives for type for the helper
        // methods but will generally do the right thing without a lot of overhead.
        if (value && !Visitor.prototype[value.type]) {
          throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
        }

        node[name] = value;
      }
    },
    // Performs an accept operation with added sanity check to ensure
    // required keys are not removed.
    acceptRequired: function acceptRequired(node, name) {
      this.acceptKey(node, name);

      if (!node[name]) {
        throw new _exception2['default'](node.type + ' requires ' + name);
      }
    },
    // Traverses a given array. If mutating, empty respnses will be removed
    // for child elements.
    acceptArray: function acceptArray(array) {
      for (var i = 0, l = array.length; i < l; i++) {
        this.acceptKey(array, i);

        if (!array[i]) {
          array.splice(i, 1);
          i--;
          l--;
        }
      }
    },
    accept: function accept(object) {
      if (!object) {
        return;
      }
      /* istanbul ignore next: Sanity code */


      if (!this[object.type]) {
        throw new _exception2['default']('Unknown type: ' + object.type, object);
      }

      if (this.current) {
        this.parents.unshift(this.current);
      }

      this.current = object;
      var ret = this[object.type](object);
      this.current = this.parents.shift();

      if (!this.mutating || ret) {
        return ret;
      } else if (ret !== false) {
        return object;
      }
    },
    Program: function Program(program) {
      this.acceptArray(program.body);
    },
    MustacheStatement: visitSubExpression,
    Decorator: visitSubExpression,
    BlockStatement: visitBlock,
    DecoratorBlock: visitBlock,
    PartialStatement: visitPartial,
    PartialBlockStatement: function PartialBlockStatement(partial) {
      visitPartial.call(this, partial);
      this.acceptKey(partial, 'program');
    },
    ContentStatement: function ContentStatement()
    /* content */
    {},
    CommentStatement: function CommentStatement()
    /* comment */
    {},
    SubExpression: visitSubExpression,
    PathExpression: function PathExpression()
    /* path */
    {},
    StringLiteral: function StringLiteral()
    /* string */
    {},
    NumberLiteral: function NumberLiteral()
    /* number */
    {},
    BooleanLiteral: function BooleanLiteral()
    /* bool */
    {},
    UndefinedLiteral: function UndefinedLiteral()
    /* literal */
    {},
    NullLiteral: function NullLiteral()
    /* literal */
    {},
    Hash: function Hash(hash) {
      this.acceptArray(hash.pairs);
    },
    HashPair: function HashPair(pair) {
      this.acceptRequired(pair, 'value');
    }
  };

  function visitSubExpression(mustache) {
    this.acceptRequired(mustache, 'path');
    this.acceptArray(mustache.params);
    this.acceptKey(mustache, 'hash');
  }

  function visitBlock(block) {
    visitSubExpression.call(this, block);
    this.acceptKey(block, 'program');
    this.acceptKey(block, 'inverse');
  }

  function visitPartial(partial) {
    this.acceptRequired(partial, 'name');
    this.acceptArray(partial.params);
    this.acceptKey(partial, 'hash');
  }

  exports['default'] = Visitor;
  module.exports = exports['default'];
});

var whitespaceControl = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _visitor2 = _interopRequireDefault(visitor);

  function WhitespaceControl() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    this.options = options;
  }

  WhitespaceControl.prototype = new _visitor2['default']();

  WhitespaceControl.prototype.Program = function (program) {
    var doStandalone = !this.options.ignoreStandalone;
    var isRoot = !this.isRootSeen;
    this.isRootSeen = true;
    var body = program.body;

    for (var i = 0, l = body.length; i < l; i++) {
      var current = body[i],
          strip = this.accept(current);

      if (!strip) {
        continue;
      }

      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
          _isNextWhitespace = isNextWhitespace(body, i, isRoot),
          openStandalone = strip.openStandalone && _isPrevWhitespace,
          closeStandalone = strip.closeStandalone && _isNextWhitespace,
          inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

      if (strip.close) {
        omitRight(body, i, true);
      }

      if (strip.open) {
        omitLeft(body, i, true);
      }

      if (doStandalone && inlineStandalone) {
        omitRight(body, i);

        if (omitLeft(body, i)) {
          // If we are on a standalone node, save the indent info for partials
          if (current.type === 'PartialStatement') {
            // Pull out the whitespace from the final line
            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
          }
        }
      }

      if (doStandalone && openStandalone) {
        omitRight((current.program || current.inverse).body); // Strip out the previous content node if it's whitespace only

        omitLeft(body, i);
      }

      if (doStandalone && closeStandalone) {
        // Always strip the next node
        omitRight(body, i);
        omitLeft((current.inverse || current.program).body);
      }
    }

    return program;
  };

  WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
    this.accept(block.program);
    this.accept(block.inverse); // Find the inverse program that is involed with whitespace stripping.

    var program = block.program || block.inverse,
        inverse = block.program && block.inverse,
        firstInverse = inverse,
        lastInverse = inverse;

    if (inverse && inverse.chained) {
      firstInverse = inverse.body[0].program; // Walk the inverse chain to find the last inverse that is actually in the chain.

      while (lastInverse.chained) {
        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
      }
    }

    var strip = {
      open: block.openStrip.open,
      close: block.closeStrip.close,
      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
      // so our parent can determine if we actually are standalone
      openStandalone: isNextWhitespace(program.body),
      closeStandalone: isPrevWhitespace((firstInverse || program).body)
    };

    if (block.openStrip.close) {
      omitRight(program.body, null, true);
    }

    if (inverse) {
      var inverseStrip = block.inverseStrip;

      if (inverseStrip.open) {
        omitLeft(program.body, null, true);
      }

      if (inverseStrip.close) {
        omitRight(firstInverse.body, null, true);
      }

      if (block.closeStrip.open) {
        omitLeft(lastInverse.body, null, true);
      } // Find standalone else statments


      if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
        omitLeft(program.body);
        omitRight(firstInverse.body);
      }
    } else if (block.closeStrip.open) {
      omitLeft(program.body, null, true);
    }

    return strip;
  };

  WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
    return mustache.strip;
  };

  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
    /* istanbul ignore next */
    var strip = node.strip || {};
    return {
      inlineStandalone: true,
      open: strip.open,
      close: strip.close
    };
  };

  function isPrevWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = body.length;
    } // Nodes that end with newlines are considered whitespace (but are special
    // cased for strip operations)


    var prev = body[i - 1],
        sibling = body[i - 2];

    if (!prev) {
      return isRoot;
    }

    if (prev.type === 'ContentStatement') {
      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    }
  }

  function isNextWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = -1;
    }

    var next = body[i + 1],
        sibling = body[i + 2];

    if (!next) {
      return isRoot;
    }

    if (next.type === 'ContentStatement') {
      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    }
  } // Marks the node to the right of the position as omitted.
  // I.e. {{foo}}' ' will mark the ' ' node as omitted.
  //
  // If i is undefined, then the first child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.


  function omitRight(body, i, multiple) {
    var current = body[i == null ? 0 : i + 1];

    if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
      return;
    }

    var original = current.value;
    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
    current.rightStripped = current.value !== original;
  } // Marks the node to the left of the position as omitted.
  // I.e. ' '{{foo}} will mark the ' ' node as omitted.
  //
  // If i is undefined then the last child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.


  function omitLeft(body, i, multiple) {
    var current = body[i == null ? body.length - 1 : i - 1];

    if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
      return;
    } // We omit the last node if it's whitespace only and not preceded by a non-content node.


    var original = current.value;
    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
    current.leftStripped = current.value !== original;
    return current.leftStripped;
  }

  exports['default'] = WhitespaceControl;
  module.exports = exports['default'];
});

var SourceLocation_1 = SourceLocation;
var id_1 = id;
var stripFlags_1 = stripFlags;
var stripComment_1 = stripComment;
var preparePath_1 = preparePath;
var prepareMustache_1 = prepareMustache;
var prepareRawBlock_1 = prepareRawBlock;
var prepareBlock_1 = prepareBlock;
var prepareProgram_1 = prepareProgram;
var preparePartialBlock_1 = preparePartialBlock; // istanbul ignore next

function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _exception2$1 = _interopRequireDefault$3(exception);

function validateClose(open, close) {
  close = close.path ? close.path.original : close;

  if (open.path.original !== close) {
    var errorNode = {
      loc: open.path.loc
    };
    throw new _exception2$1['default'](open.path.original + " doesn't match " + close, errorNode);
  }
}

function SourceLocation(source, locInfo) {
  this.source = source;
  this.start = {
    line: locInfo.first_line,
    column: locInfo.first_column
  };
  this.end = {
    line: locInfo.last_line,
    column: locInfo.last_column
  };
}

function id(token) {
  if (/^\[.*\]$/.test(token)) {
    return token.substring(1, token.length - 1);
  } else {
    return token;
  }
}

function stripFlags(open, close) {
  return {
    open: open.charAt(2) === '~',
    close: close.charAt(close.length - 3) === '~'
  };
}

function stripComment(comment) {
  return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
}

function preparePath(data, parts, loc) {
  loc = this.locInfo(loc);
  var original = data ? '@' : '',
      dig = [],
      depth = 0;

  for (var i = 0, l = parts.length; i < l; i++) {
    var part = parts[i].part,
        // If we have [] syntax then we do not treat path references as operators,
    // i.e. foo.[this] resolves to approximately context.foo['this']
    isLiteral = parts[i].original !== part;
    original += (parts[i].separator || '') + part;

    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
      if (dig.length > 0) {
        throw new _exception2$1['default']('Invalid path: ' + original, {
          loc: loc
        });
      } else if (part === '..') {
        depth++;
      }
    } else {
      dig.push(part);
    }
  }

  return {
    type: 'PathExpression',
    data: data,
    depth: depth,
    parts: dig,
    original: original,
    loc: loc
  };
}

function prepareMustache(path, params, hash, open, strip, locInfo) {
  // Must use charAt to support IE pre-10
  var escapeFlag = open.charAt(3) || open.charAt(2),
      escaped = escapeFlag !== '{' && escapeFlag !== '&';
  var decorator = /\*/.test(open);
  return {
    type: decorator ? 'Decorator' : 'MustacheStatement',
    path: path,
    params: params,
    hash: hash,
    escaped: escaped,
    strip: strip,
    loc: this.locInfo(locInfo)
  };
}

function prepareRawBlock(openRawBlock, contents, close, locInfo) {
  validateClose(openRawBlock, close);
  locInfo = this.locInfo(locInfo);
  var program = {
    type: 'Program',
    body: contents,
    strip: {},
    loc: locInfo
  };
  return {
    type: 'BlockStatement',
    path: openRawBlock.path,
    params: openRawBlock.params,
    hash: openRawBlock.hash,
    program: program,
    openStrip: {},
    inverseStrip: {},
    closeStrip: {},
    loc: locInfo
  };
}

function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
  if (close && close.path) {
    validateClose(openBlock, close);
  }

  var decorator = /\*/.test(openBlock.open);
  program.blockParams = openBlock.blockParams;
  var inverse = undefined,
      inverseStrip = undefined;

  if (inverseAndProgram) {
    if (decorator) {
      throw new _exception2$1['default']('Unexpected inverse block on decorator', inverseAndProgram);
    }

    if (inverseAndProgram.chain) {
      inverseAndProgram.program.body[0].closeStrip = close.strip;
    }

    inverseStrip = inverseAndProgram.strip;
    inverse = inverseAndProgram.program;
  }

  if (inverted) {
    inverted = inverse;
    inverse = program;
    program = inverted;
  }

  return {
    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
    path: openBlock.path,
    params: openBlock.params,
    hash: openBlock.hash,
    program: program,
    inverse: inverse,
    openStrip: openBlock.strip,
    inverseStrip: inverseStrip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}

function prepareProgram(statements, loc) {
  if (!loc && statements.length) {
    var firstLoc = statements[0].loc,
        lastLoc = statements[statements.length - 1].loc;
    /* istanbul ignore else */

    if (firstLoc && lastLoc) {
      loc = {
        source: firstLoc.source,
        start: {
          line: firstLoc.start.line,
          column: firstLoc.start.column
        },
        end: {
          line: lastLoc.end.line,
          column: lastLoc.end.column
        }
      };
    }
  }

  return {
    type: 'Program',
    body: statements,
    strip: {},
    loc: loc
  };
}

function preparePartialBlock(open, program, close, locInfo) {
  validateClose(open, close);
  return {
    type: 'PartialBlockStatement',
    name: open.path,
    params: open.params,
    hash: open.hash,
    program: program,
    openStrip: open.strip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}

var helpers = /*#__PURE__*/Object.defineProperty({
  SourceLocation: SourceLocation_1,
  id: id_1,
  stripFlags: stripFlags_1,
  stripComment: stripComment_1,
  preparePath: preparePath_1,
  prepareMustache: prepareMustache_1,
  prepareRawBlock: prepareRawBlock_1,
  prepareBlock: prepareBlock_1,
  prepareProgram: prepareProgram_1,
  preparePartialBlock: preparePartialBlock_1
}, '__esModule', {
  value: true
});

var parseWithoutProcessing_1 = parseWithoutProcessing;
var parse_1 = parse; // istanbul ignore next

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj['default'] = obj;
    return newObj;
  }
} // istanbul ignore next


function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _parser2 = _interopRequireDefault$2(parser$2);

var _whitespaceControl2 = _interopRequireDefault$2(whitespaceControl);

var Helpers = _interopRequireWildcard(helpers);

var parser$1 = _parser2['default'];
var yy = {};

utils.extend(yy, Helpers);

function parseWithoutProcessing(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy; // Altering the shared object here, but this is ok as parser is a sync operation

  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var ast = _parser2['default'].parse(input);

  return ast;
}

function parse(input, options) {
  var ast = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2['default'](options);
  return strip.accept(ast);
}

var base = /*#__PURE__*/Object.defineProperty({
  parseWithoutProcessing: parseWithoutProcessing_1,
  parse: parse_1,
  parser: parser$1
}, '__esModule', {
  value: true
});

/* eslint-disable new-cap */

var Compiler_1 = Compiler;
var precompile_1 = precompile;
var compile_1 = compile; // istanbul ignore next

function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _exception2 = _interopRequireDefault$1(exception);

var _ast2 = _interopRequireDefault$1(ast$1);

var slice = [].slice;

function Compiler() {} // the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.


Compiler.prototype = {
  compiler: Compiler,
  equals: function equals(other) {
    var len = this.opcodes.length;

    if (other.opcodes.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      var opcode = this.opcodes[i],
          otherOpcode = other.opcodes[i];

      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
        return false;
      }
    } // We know that length is the same between the two arrays because they are directly tied
    // to the opcode behavior above.


    len = this.children.length;

    for (var i = 0; i < len; i++) {
      if (!this.children[i].equals(other.children[i])) {
        return false;
      }
    }

    return true;
  },
  guid: 0,
  compile: function compile(program, options) {
    this.sourceNode = [];
    this.opcodes = [];
    this.children = [];
    this.options = options;
    this.stringParams = options.stringParams;
    this.trackIds = options.trackIds;
    options.blockParams = options.blockParams || [];
    options.knownHelpers = utils.extend(Object.create(null), {
      helperMissing: true,
      blockHelperMissing: true,
      each: true,
      'if': true,
      unless: true,
      'with': true,
      log: true,
      lookup: true
    }, options.knownHelpers);
    return this.accept(program);
  },
  compileProgram: function compileProgram(program) {
    var childCompiler = new this.compiler(),
        // eslint-disable-line new-cap
    result = childCompiler.compile(program, this.options),
        guid = this.guid++;
    this.usePartial = this.usePartial || result.usePartial;
    this.children[guid] = result;
    this.useDepths = this.useDepths || result.useDepths;
    return guid;
  },
  accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
      throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
  },
  Program: function Program(program) {
    this.options.blockParams.unshift(program.blockParams);
    var body = program.body,
        bodyLength = body.length;

    for (var i = 0; i < bodyLength; i++) {
      this.accept(body[i]);
    }

    this.options.blockParams.shift();
    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;
    return this;
  },
  BlockStatement: function BlockStatement(block) {
    transformLiteralToPath(block);
    var program = block.program,
        inverse = block.inverse;
    program = program && this.compileProgram(program);
    inverse = inverse && this.compileProgram(inverse);
    var type = this.classifySexpr(block);

    if (type === 'helper') {
      this.helperSexpr(block, program, inverse);
    } else if (type === 'simple') {
      this.simpleSexpr(block); // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('blockValue', block.path.original);
    } else {
      this.ambiguousSexpr(block, program, inverse); // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('ambiguousBlockValue');
    }

    this.opcode('append');
  },
  DecoratorBlock: function DecoratorBlock(decorator) {
    var program = decorator.program && this.compileProgram(decorator.program);
    var params = this.setupFullMustacheParams(decorator, program, undefined),
        path = decorator.path;
    this.useDecorators = true;
    this.opcode('registerDecorator', params.length, path.original);
  },
  PartialStatement: function PartialStatement(partial) {
    this.usePartial = true;
    var program = partial.program;

    if (program) {
      program = this.compileProgram(partial.program);
    }

    var params = partial.params;

    if (params.length > 1) {
      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
    } else if (!params.length) {
      if (this.options.explicitPartialContext) {
        this.opcode('pushLiteral', 'undefined');
      } else {
        params.push({
          type: 'PathExpression',
          parts: [],
          depth: 0
        });
      }
    }

    var partialName = partial.name.original,
        isDynamic = partial.name.type === 'SubExpression';

    if (isDynamic) {
      this.accept(partial.name);
    }

    this.setupFullMustacheParams(partial, program, undefined, true);
    var indent = partial.indent || '';

    if (this.options.preventIndent && indent) {
      this.opcode('appendContent', indent);
      indent = '';
    }

    this.opcode('invokePartial', isDynamic, partialName, indent);
    this.opcode('append');
  },
  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
    this.PartialStatement(partialBlock);
  },
  MustacheStatement: function MustacheStatement(mustache) {
    this.SubExpression(mustache);

    if (mustache.escaped && !this.options.noEscape) {
      this.opcode('appendEscaped');
    } else {
      this.opcode('append');
    }
  },
  Decorator: function Decorator(decorator) {
    this.DecoratorBlock(decorator);
  },
  ContentStatement: function ContentStatement(content) {
    if (content.value) {
      this.opcode('appendContent', content.value);
    }
  },
  CommentStatement: function CommentStatement() {},
  SubExpression: function SubExpression(sexpr) {
    transformLiteralToPath(sexpr);
    var type = this.classifySexpr(sexpr);

    if (type === 'simple') {
      this.simpleSexpr(sexpr);
    } else if (type === 'helper') {
      this.helperSexpr(sexpr);
    } else {
      this.ambiguousSexpr(sexpr);
    }
  },
  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
    var path = sexpr.path,
        name = path.parts[0],
        isBlock = program != null || inverse != null;
    this.opcode('getContext', path.depth);
    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);
    path.strict = true;
    this.accept(path);
    this.opcode('invokeAmbiguous', name, isBlock);
  },
  simpleSexpr: function simpleSexpr(sexpr) {
    var path = sexpr.path;
    path.strict = true;
    this.accept(path);
    this.opcode('resolvePossibleLambda');
  },
  helperSexpr: function helperSexpr(sexpr, program, inverse) {
    var params = this.setupFullMustacheParams(sexpr, program, inverse),
        path = sexpr.path,
        name = path.parts[0];

    if (this.options.knownHelpers[name]) {
      this.opcode('invokeKnownHelper', params.length, name);
    } else if (this.options.knownHelpersOnly) {
      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
    } else {
      path.strict = true;
      path.falsy = true;
      this.accept(path);
      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
    }
  },
  PathExpression: function PathExpression(path) {
    this.addDepth(path.depth);
    this.opcode('getContext', path.depth);

    var name = path.parts[0],
        scoped = _ast2['default'].helpers.scopedId(path),
        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

    if (blockParamId) {
      this.opcode('lookupBlockParam', blockParamId, path.parts);
    } else if (!name) {
      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
      this.opcode('pushContext');
    } else if (path.data) {
      this.options.data = true;
      this.opcode('lookupData', path.depth, path.parts, path.strict);
    } else {
      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
    }
  },
  StringLiteral: function StringLiteral(string) {
    this.opcode('pushString', string.value);
  },
  NumberLiteral: function NumberLiteral(number) {
    this.opcode('pushLiteral', number.value);
  },
  BooleanLiteral: function BooleanLiteral(bool) {
    this.opcode('pushLiteral', bool.value);
  },
  UndefinedLiteral: function UndefinedLiteral() {
    this.opcode('pushLiteral', 'undefined');
  },
  NullLiteral: function NullLiteral() {
    this.opcode('pushLiteral', 'null');
  },
  Hash: function Hash(hash) {
    var pairs = hash.pairs,
        i = 0,
        l = pairs.length;
    this.opcode('pushHash');

    for (; i < l; i++) {
      this.pushParam(pairs[i].value);
    }

    while (i--) {
      this.opcode('assignToHash', pairs[i].key);
    }

    this.opcode('popHash');
  },
  // HELPERS
  opcode: function opcode(name) {
    this.opcodes.push({
      opcode: name,
      args: slice.call(arguments, 1),
      loc: this.sourceNode[0].loc
    });
  },
  addDepth: function addDepth(depth) {
    if (!depth) {
      return;
    }

    this.useDepths = true;
  },
  classifySexpr: function classifySexpr(sexpr) {
    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]); // a mustache is an eligible helper if:
    // * its id is simple (a single part, not `this` or `..`)

    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr); // if a mustache is an eligible helper but not a definite
    // helper, it is ambiguous, and will be resolved in a later
    // pass or at runtime.


    var isEligible = !isBlockParam && (isHelper || isSimple); // if ambiguous, we can possibly resolve the ambiguity now
    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.

    if (isEligible && !isHelper) {
      var _name = sexpr.path.parts[0],
          options = this.options;

      if (options.knownHelpers[_name]) {
        isHelper = true;
      } else if (options.knownHelpersOnly) {
        isEligible = false;
      }
    }

    if (isHelper) {
      return 'helper';
    } else if (isEligible) {
      return 'ambiguous';
    } else {
      return 'simple';
    }
  },
  pushParams: function pushParams(params) {
    for (var i = 0, l = params.length; i < l; i++) {
      this.pushParam(params[i]);
    }
  },
  pushParam: function pushParam(val) {
    var value = val.value != null ? val.value : val.original || '';

    if (this.stringParams) {
      if (value.replace) {
        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
      }

      if (val.depth) {
        this.addDepth(val.depth);
      }

      this.opcode('getContext', val.depth || 0);
      this.opcode('pushStringParam', value, val.type);

      if (val.type === 'SubExpression') {
        // SubExpressions get evaluated and passed in
        // in string params mode.
        this.accept(val);
      }
    } else {
      if (this.trackIds) {
        var blockParamIndex = undefined;

        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
          blockParamIndex = this.blockParamIndex(val.parts[0]);
        }

        if (blockParamIndex) {
          var blockParamChild = val.parts.slice(1).join('.');
          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
        } else {
          value = val.original || value;

          if (value.replace) {
            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
          }

          this.opcode('pushId', val.type, value);
        }
      }

      this.accept(val);
    }
  },
  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
    var params = sexpr.params;
    this.pushParams(params);
    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    if (sexpr.hash) {
      this.accept(sexpr.hash);
    } else {
      this.opcode('emptyHash', omitEmpty);
    }

    return params;
  },
  blockParamIndex: function blockParamIndex(name) {
    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
      var blockParams = this.options.blockParams[depth],
          param = blockParams && utils.indexOf(blockParams, name);

      if (blockParams && param >= 0) {
        return [depth, param];
      }
    }
  }
};

function precompile(input, options, env) {
  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
  }

  options = options || {};

  if (!('data' in options)) {
    options.data = true;
  }

  if (options.compat) {
    options.useDepths = true;
  }

  var ast = env.parse(input, options),
      environment = new env.Compiler().compile(ast, options);
  return new env.JavaScriptCompiler().compile(environment, options);
}

function compile(input, options, env) {
  if (options === undefined) options = {};

  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
  }

  options = utils.extend({}, options);

  if (!('data' in options)) {
    options.data = true;
  }

  if (options.compat) {
    options.useDepths = true;
  }

  var compiled = undefined;

  function compileInput() {
    var ast = env.parse(input, options),
        environment = new env.Compiler().compile(ast, options),
        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
    return env.template(templateSpec);
  } // Template is only compiled on first use and cached after that point.


  function ret(context, execOptions) {
    if (!compiled) {
      compiled = compileInput();
    }

    return compiled.call(this, context, execOptions);
  }

  ret._setup = function (setupOptions) {
    if (!compiled) {
      compiled = compileInput();
    }

    return compiled._setup(setupOptions);
  };

  ret._child = function (i, data, blockParams, depths) {
    if (!compiled) {
      compiled = compileInput();
    }

    return compiled._child(i, data, blockParams, depths);
  };

  return ret;
}

function argEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (utils.isArray(a) && utils.isArray(b) && a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (!argEquals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }
}

function transformLiteralToPath(sexpr) {
  if (!sexpr.path.parts) {
    var literal = sexpr.path; // Casting to string here to make false and 0 literal values play nicely with the rest
    // of the system.

    sexpr.path = {
      type: 'PathExpression',
      data: false,
      depth: 0,
      parts: [literal.original + ''],
      original: literal.original + '',
      loc: literal.loc
    };
  }
}

var compiler = /*#__PURE__*/Object.defineProperty({
  Compiler: Compiler_1,
  precompile: precompile_1,
  compile: compile_1
}, '__esModule', {
  value: true
});

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */

var encode$2 = function encode(number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }

  throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */


var decode$2 = function decode(charCode) {
  var bigA = 65; // 'A'

  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'

  var littleZ = 122; // 'z'

  var zero = 48; // '0'

  var nine = 57; // '9'

  var plus = 43; // '+'

  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  } // 26 - 51: abcdefghijklmnopqrstuvwxyz


  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  } // 52 - 61: 0123456789


  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  } // 62: +


  if (charCode == plus) {
    return 62;
  } // 63: /


  if (charCode == slash) {
    return 63;
  } // Invalid base64 digit.


  return -1;
};

var base64 = {
  encode: encode$2,
  decode: decode$2
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5; // binary: 100000

var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */

function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */


function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */


var encode$1 = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;

    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }

    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */


var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));

    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var base64Vlq = {
  encode: encode$1,
  decode: decode$1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
var util = createCommonjsModule(function (module, exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }

  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);

    if (!match) {
      return null;
    }

    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }

  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';

    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }

    url += '//';

    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }

    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }

    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }

    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }

    return url;
  }

  exports.urlGenerate = urlGenerate;
  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */

  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);

    if (url) {
      if (!url.path) {
        return aPath;
      }

      path = url.path;
    }

    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);

    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];

      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }

    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }

    return path;
  }

  exports.normalize = normalize;
  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */

  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    if (aPath === "") {
      aPath = ".";
    }

    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);

    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    } // `join(foo, '//www.example.org')`


    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }

      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    } // `join('http://', 'www.example.com')`


    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }

    return joined;
  }

  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
  };
  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */


  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.

    var level = 0;

    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");

      if (index < 0) {
        return aPath;
      } // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.


      aRoot = aRoot.slice(0, index);

      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    } // Make sure we add a "../" for each component we removed from the root.


    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }

  exports.relative = relative;

  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }();

  function identity(s) {
    return s;
  }
  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */


  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }

  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }

  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9
    /* "__proto__".length */
    ) {
        return false;
      }

    if (s.charCodeAt(length - 1) !== 95
    /* '_' */
    || s.charCodeAt(length - 2) !== 95
    /* '_' */
    || s.charCodeAt(length - 3) !== 111
    /* 'o' */
    || s.charCodeAt(length - 4) !== 116
    /* 't' */
    || s.charCodeAt(length - 5) !== 111
    /* 'o' */
    || s.charCodeAt(length - 6) !== 114
    /* 'r' */
    || s.charCodeAt(length - 7) !== 112
    /* 'p' */
    || s.charCodeAt(length - 8) !== 95
    /* '_' */
    || s.charCodeAt(length - 9) !== 95
    /* '_' */
    ) {
        return false;
      }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36
      /* '$' */
      ) {
          return false;
        }
    }

    return true;
  }
  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */


  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByOriginalPositions = compareByOriginalPositions;
  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */

  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 === null) {
      return 1; // aStr2 !== null
    }

    if (aStr2 === null) {
      return -1; // aStr1 !== null
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }
  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */


  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  /**
   * Strip any JSON XSSI avoidance prefix from the string (as documented
   * in the source maps specification), and then parse the string as
   * JSON.
   */

  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
  }

  exports.parseSourceMapInput = parseSourceMapInput;
  /**
   * Compute the URL of a source given the the source root, the source's
   * URL, and the source map's URL.
   */

  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';

    if (sourceRoot) {
      // This follows what Chrome does.
      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
        sourceRoot += '/';
      } // The spec says:
      //   Line 4: An optional source root, useful for relocating source
      //   files on a server or removing repeated values in the
      //   “sources” entry.  This value is prepended to the individual
      //   entries in the “source” field.


      sourceURL = sourceRoot + sourceURL;
    } // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).


    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);

      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }

      if (parsed.path) {
        // Strip the last path component, but keep the "/".
        var index = parsed.path.lastIndexOf('/');

        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }

      sourceURL = join(urlGenerate(parsed), sourceURL);
    }

    return normalize(sourceURL);
  }

  exports.computeSourceURL = computeSourceURL;
});

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */

function ArraySet$2() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */


ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$2();

  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }

  return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */


ArraySet$2.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */


ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;

  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }

  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */


ArraySet$2.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */


ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);

    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);

    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */


ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }

  throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */


ArraySet$2.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

var ArraySet_1 = ArraySet$2;
var arraySet = {
  ArraySet: ArraySet_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */

function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */


function MappingList$1() {
  this._array = [];
  this._sorted = true; // Serves as infimum

  this._last = {
    generatedLine: -1,
    generatedColumn: 0
  };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */


MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */


MappingList$1.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;

    this._array.push(aMapping);
  } else {
    this._sorted = false;

    this._array.push(aMapping);
  }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */


MappingList$1.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);

    this._sorted = true;
  }

  return this._array;
};

var MappingList_1 = MappingList$1;
var mappingList = {
  MappingList: MappingList_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var ArraySet$1 = arraySet.ArraySet;
var MappingList = mappingList.MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */

function SourceMapGenerator$2(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }

  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet$1();
  this._names = new ArraySet$1();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator$2.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */

SourceMapGenerator$2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator$2({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;

      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;

    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */


SourceMapGenerator$2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);

    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);

    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};
/**
 * Set the source content for a source file.
 */


SourceMapGenerator$2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;

  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }

    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];

    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */


SourceMapGenerator$2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }

    sourceFile = aSourceMapConsumer.file;
  }

  var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  } // Applying the SourceMap can add and remove items from the sources and
  // the names array.


  var newSources = new ArraySet$1();
  var newNames = new ArraySet$1(); // Find mappings for the "sourceFile"

  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });

      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;

        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }

        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }

        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;

        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;

    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;

    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);

  this._sources = newSources;
  this._names = newNames; // Copy sourcesContents of applied map.

  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }

      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }

      this.setSourceContent(sourceFile, content);
    }
  }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */


SourceMapGenerator$2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */


SourceMapGenerator$2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();

  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;

      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }

        next += ',';
      }
    }

    next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64Vlq.encode(sourceIdx - previousSource);
      previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

      next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64Vlq.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator$2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }

    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }

    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
/**
 * Externalize the source map.
 */


SourceMapGenerator$2.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };

  if (this._file != null) {
    map.file = this._file;
  }

  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }

  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};
/**
 * Render the source map being generated to a string.
 */


SourceMapGenerator$2.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

var SourceMapGenerator_1 = SourceMapGenerator$2;
var sourceMapGenerator = {
  SourceMapGenerator: SourceMapGenerator_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
var binarySearch = createCommonjsModule(function (module, exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */

  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);

    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    } else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      } // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.


      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      } // we are in termination case (3) or (2) and return the appropriate thing.


      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */


  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

    if (index < 0) {
      return -1;
    } // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.


    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }

      --index;
    }

    return index;
  };
});

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}
/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */


function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}
/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */


function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.
  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.
    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;
    swap(ary, pivotIndex, r);
    var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1; // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */


var quickSort_1 = function quickSort_1(ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

var quickSort$1 = {
  quickSort: quickSort_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var ArraySet = arraySet.ArraySet;
var quickSort = quickSort$1.quickSort;

function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer$1.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */


SourceMapConsumer$1.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer$1.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function get() {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});
SourceMapConsumer$1.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function get() {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer$1.GENERATED_ORDER = 1;
SourceMapConsumer$1.ORIGINAL_ORDER = 2;
SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */

SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
  var mappings;

  switch (order) {
    case SourceMapConsumer$1.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;

    case SourceMapConsumer$1.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;

    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */


SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.

  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };
  needle.source = this._findSourceIndex(needle.source);

  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.

      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.

      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

var SourceMapConsumer_1 = SourceMapConsumer$1;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */

function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.

  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  }); // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.

  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */

BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  } // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.


  var i;

  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */


BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  }); // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();

  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */


BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function get() {
    return this._absoluteSources.slice();
  }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */

function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.

      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }

      str = aStr.slice(index, end);
      segment = cachedSegments[str];

      if (segment) {
        index += str.length;
      } else {
        segment = [];

        while (index < end) {
          base64Vlq.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      } // Generated column.


      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1]; // Original line.

        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

        mapping.originalLine += 1; // Original column.

        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);

      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;
  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */


BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }

  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */


BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).

    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    } // The last mapping for each line spans the entire line.


    mapping.lastGeneratedColumn = Infinity;
  }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */


BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);

      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }

      var name = util.getArg(mapping, 'name', null);

      if (name !== null) {
        name = this._names.at(name);
      }

      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }

  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);

  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;

  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  } // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.


  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);

  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */

function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }

    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }

    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer$1(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
/**
 * The version of the source mapping spec that we are consuming.
 */

IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function get() {
    var sources = [];

    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }

    return sources;
  }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */

IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  }; // Find the section containing the generated position we're trying to map
  // to an original position.

  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);

    if (content) {
      return content;
    }
  }

  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i]; // Only consider this section if the requested source is in the list of
    // sources of the consumer.

    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }

    var generatedPosition = section.consumer.generatedPositionFor(aArgs);

    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];

  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;

    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);

      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

      this._sources.add(source);

      source = this._sources.indexOf(source);
      var name = null;

      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
      } // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.


      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);

      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;
var sourceMapConsumer = {
  SourceMapConsumer: SourceMapConsumer_1,
  BasicSourceMapConsumer: BasicSourceMapConsumer_1,
  IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator; // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).

var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!

var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */

function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */


SourceNode$1.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode$1(); // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.

  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;

  var shiftNextLine = function shiftNextLine() {
    var lineContents = getNextLine(); // The last line of a file might not have a newline.

    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  }; // We need to remember the position of "remainingLines"


  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.

  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0; // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code); // No more remaining code, continue

        lastMapping = mapping;
        return;
      }
    } // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.


    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }

    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }

    lastMapping = mapping;
  }, this); // We have processed all mappings.

  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    } // and add the remaining lines without any mapping


    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  } // Copy sourcesContent into SourceNode


  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }

      node.setSourceContent(sourceFile, content);
    }
  });
  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode$1(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */


SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;

  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];

    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */


SourceNode$1.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;

  if (len > 0) {
    newChildren = [];

    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }

    newChildren.push(this.children[i]);
    this.children = newChildren;
  }

  return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */


SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];

  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }

  return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */


SourceNode$1.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */


SourceNode$1.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);

  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */


SourceNode$1.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */


SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator$1(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;

    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }

      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }

    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0; // Mappings end at eol

        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });
  return {
    code: generated.code,
    map: map
  };
};

var SourceNode_1 = SourceNode$1;
var sourceNode = {
  SourceNode: SourceNode_1
};

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
var SourceNode = sourceNode.SourceNode;
var sourceMap = {
  SourceMapGenerator: SourceMapGenerator,
  SourceMapConsumer: SourceMapConsumer,
  SourceNode: SourceNode
};

/* global define */
var codeGen = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var SourceNode = undefined;

  try {
    /* istanbul ignore next */
    if (typeof undefined !== 'function' || !undefined.amd) {
      // We don't support this in AMD environments. For these environments, we asusme that
      // they are running on the browser and thus have no need for the source-map library.
      var SourceMap = sourceMap;
      SourceNode = SourceMap.SourceNode;
    }
  } catch (err) {}
  /* NOP */

  /* istanbul ignore if: tested but not covered in istanbul due to dist build  */


  if (!SourceNode) {
    SourceNode = function SourceNode(line, column, srcFile, chunks) {
      this.src = '';

      if (chunks) {
        this.add(chunks);
      }
    };
    /* istanbul ignore next */


    SourceNode.prototype = {
      add: function add(chunks) {
        if (utils.isArray(chunks)) {
          chunks = chunks.join('');
        }

        this.src += chunks;
      },
      prepend: function prepend(chunks) {
        if (utils.isArray(chunks)) {
          chunks = chunks.join('');
        }

        this.src = chunks + this.src;
      },
      toStringWithSourceMap: function toStringWithSourceMap() {
        return {
          code: this.toString()
        };
      },
      toString: function toString() {
        return this.src;
      }
    };
  }

  function castChunk(chunk, codeGen, loc) {
    if (utils.isArray(chunk)) {
      var ret = [];

      for (var i = 0, len = chunk.length; i < len; i++) {
        ret.push(codeGen.wrap(chunk[i], loc));
      }

      return ret;
    } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
      // Handle primitives that the SourceNode will throw up on
      return chunk + '';
    }

    return chunk;
  }

  function CodeGen(srcFile) {
    this.srcFile = srcFile;
    this.source = [];
  }

  CodeGen.prototype = {
    isEmpty: function isEmpty() {
      return !this.source.length;
    },
    prepend: function prepend(source, loc) {
      this.source.unshift(this.wrap(source, loc));
    },
    push: function push(source, loc) {
      this.source.push(this.wrap(source, loc));
    },
    merge: function merge() {
      var source = this.empty();
      this.each(function (line) {
        source.add(['  ', line, '\n']);
      });
      return source;
    },
    each: function each(iter) {
      for (var i = 0, len = this.source.length; i < len; i++) {
        iter(this.source[i]);
      }
    },
    empty: function empty() {
      var loc = this.currentLocation || {
        start: {}
      };
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
    },
    wrap: function wrap(chunk) {
      var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || {
        start: {}
      } : arguments[1];

      if (chunk instanceof SourceNode) {
        return chunk;
      }

      chunk = castChunk(chunk, this, loc);
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
    },
    functionCall: function functionCall(fn, type, params) {
      params = this.generateList(params);
      return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
    },
    quotedString: function quotedString(str) {
      return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, "\\u2028") // Per Ecma-262 7.3 + 7.8.4
      .replace(/\u2029/g, "\\u2029") + '"';
    },
    objectLiteral: function objectLiteral(obj) {
      // istanbul ignore next
      var _this = this;

      var pairs = [];
      Object.keys(obj).forEach(function (key) {
        var value = castChunk(obj[key], _this);

        if (value !== 'undefined') {
          pairs.push([_this.quotedString(key), ':', value]);
        }
      });
      var ret = this.generateList(pairs);
      ret.prepend('{');
      ret.add('}');
      return ret;
    },
    generateList: function generateList(entries) {
      var ret = this.empty();

      for (var i = 0, len = entries.length; i < len; i++) {
        if (i) {
          ret.add(',');
        }

        ret.add(castChunk(entries[i], this));
      }

      return ret;
    },
    generateArray: function generateArray(entries) {
      var ret = this.generateList(entries);
      ret.prepend('[');
      ret.add(']');
      return ret;
    }
  };
  exports['default'] = CodeGen;
  module.exports = exports['default'];
});

var javascriptCompiler = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _exception2 = _interopRequireDefault(exception);

  var _codeGen2 = _interopRequireDefault(codeGen);

  function Literal(value) {
    this.value = value;
  }

  function JavaScriptCompiler() {}

  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function nameLookup(parent, name
    /*,  type */
    ) {
      return this.internalNameLookup(parent, name);
    },
    depthedLookup: function depthedLookup(name) {
      return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];
    },
    compilerInfo: function compilerInfo() {
      var revision = base$1.COMPILER_REVISION,
          versions = base$1.REVISION_CHANGES[revision];
      return [revision, versions];
    },
    appendToBuffer: function appendToBuffer(source, location, explicit) {
      // Force a source as this simplifies the merge logic.
      if (!utils.isArray(source)) {
        source = [source];
      }

      source = this.source.wrap(source, location);

      if (this.environment.isSimple) {
        return ['return ', source, ';'];
      } else if (explicit) {
        // This is a case where the buffer operation occurs as a child of another
        // construct, generally braces. We have to explicitly output these buffer
        // operations to ensure that the emitted code goes in the correct location.
        return ['buffer += ', source, ';'];
      } else {
        source.appendToBuffer = true;
        return source;
      }
    },
    initializeBuffer: function initializeBuffer() {
      return this.quotedString('');
    },
    // END PUBLIC API
    internalNameLookup: function internalNameLookup(parent, name) {
      this.lookupPropertyFunctionIsUsed = true;
      return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];
    },
    lookupPropertyFunctionIsUsed: false,
    compile: function compile(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;
      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        decorators: [],
        programs: [],
        environments: []
      };
      this.preamble();
      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = {
        list: []
      };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];
      this.blockParams = [];
      this.compileChildren(environment, options);
      this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
      this.useBlockParams = this.useBlockParams || environment.useBlockParams;
      var opcodes = environment.opcodes,
          opcode = undefined,
          firstLoc = undefined,
          i = undefined,
          l = undefined;

      for (i = 0, l = opcodes.length; i < l; i++) {
        opcode = opcodes[i];
        this.source.currentLocation = opcode.loc;
        firstLoc = firstLoc || opcode.loc;
        this[opcode.opcode].apply(this, opcode.args);
      } // Flush any trailing content that might be pending.


      this.source.currentLocation = firstLoc;
      this.pushSource('');
      /* istanbul ignore next */

      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new _exception2['default']('Compile completed with content left on stack');
      }

      if (!this.decorators.isEmpty()) {
        this.useDecorators = true;
        this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\n']);
        this.decorators.push('return fn;');

        if (asObject) {
          this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
        } else {
          this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
          this.decorators.push('}\n');
          this.decorators = this.decorators.merge();
        }
      } else {
        this.decorators = undefined;
      }

      var fn = this.createFunctionContext(asObject);

      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };

        if (this.decorators) {
          ret.main_d = this.decorators; // eslint-disable-line camelcase

          ret.useDecorators = true;
        }

        var _context = this.context;
        var programs = _context.programs;
        var decorators = _context.decorators;

        for (i = 0, l = programs.length; i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];

            if (decorators[i]) {
              ret[i + '_d'] = decorators[i];
              ret.useDecorators = true;
            }
          }
        }

        if (this.environment.usePartial) {
          ret.usePartial = true;
        }

        if (this.options.data) {
          ret.useData = true;
        }

        if (this.useDepths) {
          ret.useDepths = true;
        }

        if (this.useBlockParams) {
          ret.useBlockParams = true;
        }

        if (this.options.compat) {
          ret.compat = true;
        }

        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);
          this.source.currentLocation = {
            start: {
              line: 1,
              column: 0
            }
          };
          ret = this.objectLiteral(ret);

          if (options.srcName) {
            ret = ret.toStringWithSourceMap({
              file: options.destName
            });
            ret.map = ret.map && ret.map.toString();
          } else {
            ret = ret.toString();
          }
        } else {
          ret.compilerOptions = this.options;
        }

        return ret;
      } else {
        return fn;
      }
    },
    preamble: function preamble() {
      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = new _codeGen2['default'](this.options.srcName);
      this.decorators = new _codeGen2['default'](this.options.srcName);
    },
    createFunctionContext: function createFunctionContext(asObject) {
      // istanbul ignore next
      var _this = this;

      var varDeclarations = '';
      var locals = this.stackVars.concat(this.registers.list);

      if (locals.length > 0) {
        varDeclarations += ', ' + locals.join(', ');
      } // Generate minimizer alias mappings
      //
      // When using true SourceNodes, this will update all references to the given alias
      // as the source nodes are reused in situ. For the non-source node compilation mode,
      // aliases will not be used, but this case is already being run on the client and
      // we aren't concern about minimizing the template size.


      var aliasCount = 0;
      Object.keys(this.aliases).forEach(function (alias) {
        var node = _this.aliases[alias];

        if (node.children && node.referenceCount > 1) {
          varDeclarations += ', alias' + ++aliasCount + '=' + alias;
          node.children[0] = 'alias' + aliasCount;
        }
      });

      if (this.lookupPropertyFunctionIsUsed) {
        varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();
      }

      var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

      if (this.useBlockParams || this.useDepths) {
        params.push('blockParams');
      }

      if (this.useDepths) {
        params.push('depths');
      } // Perform a second pass over the output to merge content when possible


      var source = this.mergeSource(varDeclarations);

      if (asObject) {
        params.push(source);
        return Function.apply(this, params);
      } else {
        return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
      }
    },
    mergeSource: function mergeSource(varDeclarations) {
      var isSimple = this.environment.isSimple,
          appendOnly = !this.forceBuffer,
          appendFirst = undefined,
          sourceSeen = undefined,
          bufferStart = undefined,
          bufferEnd = undefined;
      this.source.each(function (line) {
        if (line.appendToBuffer) {
          if (bufferStart) {
            line.prepend('  + ');
          } else {
            bufferStart = line;
          }

          bufferEnd = line;
        } else {
          if (bufferStart) {
            if (!sourceSeen) {
              appendFirst = true;
            } else {
              bufferStart.prepend('buffer += ');
            }

            bufferEnd.add(';');
            bufferStart = bufferEnd = undefined;
          }

          sourceSeen = true;

          if (!isSimple) {
            appendOnly = false;
          }
        }
      });

      if (appendOnly) {
        if (bufferStart) {
          bufferStart.prepend('return ');
          bufferEnd.add(';');
        } else if (!sourceSeen) {
          this.source.push('return "";');
        }
      } else {
        varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

        if (bufferStart) {
          bufferStart.prepend('return buffer + ');
          bufferEnd.add(';');
        } else {
          this.source.push('return buffer;');
        }
      }

      if (varDeclarations) {
        this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
      }

      return this.source.merge();
    },
    lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
      return '\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    '.trim();
    },
    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function blockValue(name) {
      var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
          params = [this.contextName(0)];
      this.setupHelperArgs(name, 0, params);
      var blockName = this.popStack();
      params.splice(1, 0, blockName);
      this.push(this.source.functionCall(blockHelperMissing, 'call', params));
    },
    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function ambiguousBlockValue() {
      // We're being a bit cheeky and reusing the options value from the prior exec
      var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
          params = [this.contextName(0)];
      this.setupHelperArgs('', 0, params, true);
      this.flushInline();
      var current = this.topStack();
      params.splice(1, 0, current);
      this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
    },
    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function appendContent(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      } else {
        this.pendingLocation = this.source.currentLocation;
      }

      this.pendingContent = content;
    },
    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function append() {
      if (this.isInline()) {
        this.replaceStack(function (current) {
          return [' != null ? ', current, ' : ""'];
        });
        this.pushSource(this.appendToBuffer(this.popStack()));
      } else {
        var local = this.popStack();
        this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);

        if (this.environment.isSimple) {
          this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
        }
      }
    },
    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function appendEscaped() {
      this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
    },
    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function getContext(depth) {
      this.lastContext = depth;
    },
    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function pushContext() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },
    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
      var i = 0;

      if (!scoped && this.options.compat && !this.lastContext) {
        // The depthed query is expected to handle the undefined logic for the root level that
        // is implemented below, so we evaluate that directly in compat mode
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }

      this.resolvePath('context', parts, i, falsy, strict);
    },
    // [lookupBlockParam]
    //
    // On stack, before: ...
    // On stack, after: blockParam[name], ...
    //
    // Looks up the value of `parts` on the given block param and pushes
    // it onto the stack.
    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
      this.useBlockParams = true;
      this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
      this.resolvePath('context', parts, 1);
    },
    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function lookupData(depth, parts, strict) {
      if (!depth) {
        this.pushStackLiteral('data');
      } else {
        this.pushStackLiteral('container.data(data, ' + depth + ')');
      }

      this.resolvePath('data', parts, 0, true, strict);
    },
    resolvePath: function resolvePath(type, parts, i, falsy, strict) {
      // istanbul ignore next
      var _this2 = this;

      if (this.options.strict || this.options.assumeObjects) {
        this.push(strictLookup(this.options.strict && strict, this, parts, type));
        return;
      }

      var len = parts.length;

      for (; i < len; i++) {
        /* eslint-disable no-loop-func */
        this.replaceStack(function (current) {
          var lookup = _this2.nameLookup(current, parts[i], type); // We want to ensure that zero and false are handled properly if the context (falsy flag)
          // needs to have the special handling for these values.


          if (!falsy) {
            return [' != null ? ', lookup, ' : ', current];
          } else {
            // Otherwise we can use generic falsy handling
            return [' && ', lookup];
          }
        });
        /* eslint-enable no-loop-func */
      }
    },
    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function resolvePossibleLambda() {
      this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
    },
    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function pushStringParam(string, type) {
      this.pushContext();
      this.pushString(type); // If it's a subexpression, the string result
      // will be pushed after this opcode.

      if (type !== 'SubExpression') {
        if (typeof string === 'string') {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },
    emptyHash: function emptyHash(omitEmpty) {
      if (this.trackIds) {
        this.push('{}'); // hashIds
      }

      if (this.stringParams) {
        this.push('{}'); // hashContexts

        this.push('{}'); // hashTypes
      }

      this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
    },
    pushHash: function pushHash() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }

      this.hash = {
        values: {},
        types: [],
        contexts: [],
        ids: []
      };
    },
    popHash: function popHash() {
      var hash = this.hash;
      this.hash = this.hashes.pop();

      if (this.trackIds) {
        this.push(this.objectLiteral(hash.ids));
      }

      if (this.stringParams) {
        this.push(this.objectLiteral(hash.contexts));
        this.push(this.objectLiteral(hash.types));
      }

      this.push(this.objectLiteral(hash.values));
    },
    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function pushString(string) {
      this.pushStackLiteral(this.quotedString(string));
    },
    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function pushLiteral(value) {
      this.pushStackLiteral(value);
    },
    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function pushProgram(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },
    // [registerDecorator]
    //
    // On stack, before: hash, program, params..., ...
    // On stack, after: ...
    //
    // Pops off the decorator's parameters, invokes the decorator,
    // and inserts the decorator into the decorators list.
    registerDecorator: function registerDecorator(paramSize, name) {
      var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
          options = this.setupHelperArgs(name, paramSize);
      this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
    },
    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function invokeHelper(paramSize, name, isSimple) {
      var nonHelper = this.popStack(),
          helper = this.setupHelper(paramSize, name);
      var possibleFunctionCalls = [];

      if (isSimple) {
        // direct call to helper
        possibleFunctionCalls.push(helper.name);
      } // call a function from the input object


      possibleFunctionCalls.push(nonHelper);

      if (!this.options.strict) {
        possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));
      }

      var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];
      var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);
      this.push(functionCall);
    },
    itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
      var result = [];
      result.push(items[0]);

      for (var i = 1; i < items.length; i++) {
        result.push(separator, items[i]);
      }

      return result;
    },
    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
    },
    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
      this.useRegister('helper');
      var nonHelper = this.popStack();
      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);
      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
      var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];

      if (!this.options.strict) {
        lookup[0] = '(helper = ';
        lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));
      }

      this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
    },
    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function invokePartial(isDynamic, name, indent) {
      var params = [],
          options = this.setupParams(name, 1, params);

      if (isDynamic) {
        name = this.popStack();
        delete options.name;
      }

      if (indent) {
        options.indent = JSON.stringify(indent);
      }

      options.helpers = 'helpers';
      options.partials = 'partials';
      options.decorators = 'container.decorators';

      if (!isDynamic) {
        params.unshift(this.nameLookup('partials', name, 'partial'));
      } else {
        params.unshift(name);
      }

      if (this.options.compat) {
        options.depths = 'depths';
      }

      options = this.objectLiteral(options);
      params.push(options);
      this.push(this.source.functionCall('container.invokePartial', '', params));
    },
    // [assignToHash]
    //
    // On stack, before: value, ..., hash, ...
    // On stack, after: ..., hash, ...
    //
    // Pops a value off the stack and assigns it to the current hash
    assignToHash: function assignToHash(key) {
      var value = this.popStack(),
          context = undefined,
          type = undefined,
          id = undefined;

      if (this.trackIds) {
        id = this.popStack();
      }

      if (this.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }

      var hash = this.hash;

      if (context) {
        hash.contexts[key] = context;
      }

      if (type) {
        hash.types[key] = type;
      }

      if (id) {
        hash.ids[key] = id;
      }

      hash.values[key] = value;
    },
    pushId: function pushId(type, name, child) {
      if (type === 'BlockParam') {
        this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
      } else if (type === 'PathExpression') {
        this.pushString(name);
      } else if (type === 'SubExpression') {
        this.pushStackLiteral('true');
      } else {
        this.pushStackLiteral('null');
      }
    },
    // HELPERS
    compiler: JavaScriptCompiler,
    compileChildren: function compileChildren(environment, options) {
      var children = environment.children,
          child = undefined,
          compiler = undefined;

      for (var i = 0, l = children.length; i < l; i++) {
        child = children[i];
        compiler = new this.compiler(); // eslint-disable-line new-cap

        var existing = this.matchExistingProgram(child);

        if (existing == null) {
          this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children

          var index = this.context.programs.length;
          child.index = index;
          child.name = 'program' + index;
          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
          this.context.decorators[index] = compiler.decorators;
          this.context.environments[index] = child;
          this.useDepths = this.useDepths || compiler.useDepths;
          this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
          child.useDepths = this.useDepths;
          child.useBlockParams = this.useBlockParams;
        } else {
          child.index = existing.index;
          child.name = 'program' + existing.index;
          this.useDepths = this.useDepths || existing.useDepths;
          this.useBlockParams = this.useBlockParams || existing.useBlockParams;
        }
      }
    },
    matchExistingProgram: function matchExistingProgram(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];

        if (environment && environment.equals(child)) {
          return environment;
        }
      }
    },
    programExpression: function programExpression(guid) {
      var child = this.environment.children[guid],
          programParams = [child.index, 'data', child.blockParams];

      if (this.useBlockParams || this.useDepths) {
        programParams.push('blockParams');
      }

      if (this.useDepths) {
        programParams.push('depths');
      }

      return 'container.program(' + programParams.join(', ') + ')';
    },
    useRegister: function useRegister(name) {
      if (!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },
    push: function push(expr) {
      if (!(expr instanceof Literal)) {
        expr = this.source.wrap(expr);
      }

      this.inlineStack.push(expr);
      return expr;
    },
    pushStackLiteral: function pushStackLiteral(item) {
      this.push(new Literal(item));
    },
    pushSource: function pushSource(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
        this.pendingContent = undefined;
      }

      if (source) {
        this.source.push(source);
      }
    },
    replaceStack: function replaceStack(callback) {
      var prefix = ['('],
          stack = undefined,
          createdStack = undefined,
          usedLiteral = undefined;
      /* istanbul ignore next */

      if (!this.isInline()) {
        throw new _exception2['default']('replaceStack on non-inline');
      } // We want to merge the inline statement into the replacement statement via ','


      var top = this.popStack(true);

      if (top instanceof Literal) {
        // Literals do not need to be inlined
        stack = [top.value];
        prefix = ['(', stack];
        usedLiteral = true;
      } else {
        // Get or create the current stack name for use by the inline
        createdStack = true;

        var _name = this.incrStack();

        prefix = ['((', this.push(_name), ' = ', top, ')'];
        stack = this.topStack();
      }

      var item = callback.call(this, stack);

      if (!usedLiteral) {
        this.popStack();
      }

      if (createdStack) {
        this.stackSlot--;
      }

      this.push(prefix.concat(item, ')'));
    },
    incrStack: function incrStack() {
      this.stackSlot++;

      if (this.stackSlot > this.stackVars.length) {
        this.stackVars.push('stack' + this.stackSlot);
      }

      return this.topStackName();
    },
    topStackName: function topStackName() {
      return 'stack' + this.stackSlot;
    },
    flushInline: function flushInline() {
      var inlineStack = this.inlineStack;
      this.inlineStack = [];

      for (var i = 0, len = inlineStack.length; i < len; i++) {
        var entry = inlineStack[i];
        /* istanbul ignore if */

        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          var stack = this.incrStack();
          this.pushSource([stack, ' = ', entry, ';']);
          this.compileStack.push(stack);
        }
      }
    },
    isInline: function isInline() {
      return this.inlineStack.length;
    },
    popStack: function popStack(wrapped) {
      var inline = this.isInline(),
          item = (inline ? this.inlineStack : this.compileStack).pop();

      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        if (!inline) {
          /* istanbul ignore next */
          if (!this.stackSlot) {
            throw new _exception2['default']('Invalid stack pop');
          }

          this.stackSlot--;
        }

        return item;
      }
    },
    topStack: function topStack() {
      var stack = this.isInline() ? this.inlineStack : this.compileStack,
          item = stack[stack.length - 1];
      /* istanbul ignore if */

      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },
    contextName: function contextName(context) {
      if (this.useDepths && context) {
        return 'depths[' + context + ']';
      } else {
        return 'depth' + context;
      }
    },
    quotedString: function quotedString(str) {
      return this.source.quotedString(str);
    },
    objectLiteral: function objectLiteral(obj) {
      return this.source.objectLiteral(obj);
    },
    aliasable: function aliasable(name) {
      var ret = this.aliases[name];

      if (ret) {
        ret.referenceCount++;
        return ret;
      }

      ret = this.aliases[name] = this.source.wrap(name);
      ret.aliasable = true;
      ret.referenceCount = 1;
      return ret;
    },
    setupHelper: function setupHelper(paramSize, name, blockHelper) {
      var params = [],
          paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
      var foundHelper = this.nameLookup('helpers', name, 'helper'),
          callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');
      return {
        params: params,
        paramsInit: paramsInit,
        name: foundHelper,
        callParams: [callContext].concat(params)
      };
    },
    setupParams: function setupParams(helper, paramSize, params) {
      var options = {},
          contexts = [],
          types = [],
          ids = [],
          objectArgs = !params,
          param = undefined;

      if (objectArgs) {
        params = [];
      }

      options.name = this.quotedString(helper);
      options.hash = this.popStack();

      if (this.trackIds) {
        options.hashIds = this.popStack();
      }

      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }

      var inverse = this.popStack(),
          program = this.popStack(); // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`

      if (program || inverse) {
        options.fn = program || 'container.noop';
        options.inverse = inverse || 'container.noop';
      } // The parameters go on to the stack in order (making sure that they are evaluated in order)
      // so we need to pop them off the stack in reverse order


      var i = paramSize;

      while (i--) {
        param = this.popStack();
        params[i] = param;

        if (this.trackIds) {
          ids[i] = this.popStack();
        }

        if (this.stringParams) {
          types[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }

      if (objectArgs) {
        options.args = this.source.generateArray(params);
      }

      if (this.trackIds) {
        options.ids = this.source.generateArray(ids);
      }

      if (this.stringParams) {
        options.types = this.source.generateArray(types);
        options.contexts = this.source.generateArray(contexts);
      }

      if (this.options.data) {
        options.data = 'data';
      }

      if (this.useBlockParams) {
        options.blockParams = 'blockParams';
      }

      return options;
    },
    setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
      var options = this.setupParams(helper, paramSize, params);
      options.loc = JSON.stringify(this.source.currentLocation);
      options = this.objectLiteral(options);

      if (useRegister) {
        this.useRegister('options');
        params.push('options');
        return ['options=', options];
      } else if (params) {
        params.push(options);
        return '';
      } else {
        return options;
      }
    }
  };

  (function () {
    var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

    for (var i = 0, l = reservedWords.length; i < l; i++) {
      compilerWords[reservedWords[i]] = true;
    }
  })();
  /**
   * @deprecated May be removed in the next major version
   */


  JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  };

  function strictLookup(requireTerminal, compiler, parts, type) {
    var stack = compiler.popStack(),
        i = 0,
        len = parts.length;

    if (requireTerminal) {
      len--;
    }

    for (; i < len; i++) {
      stack = compiler.nameLookup(stack, parts[i], type);
    }

    if (requireTerminal) {
      return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];
    } else {
      return stack;
    }
  }

  exports['default'] = JavaScriptCompiler;
  module.exports = exports['default'];
});

var handlebars$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true; // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _handlebarsRuntime2 = _interopRequireDefault(handlebars_runtime); // Compiler imports


  var _handlebarsCompilerAst2 = _interopRequireDefault(ast$1);

  var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(javascriptCompiler);

  var _handlebarsCompilerVisitor2 = _interopRequireDefault(visitor);

  var _handlebarsNoConflict2 = _interopRequireDefault(noConflict);

  var _create = _handlebarsRuntime2['default'].create;

  function create() {
    var hb = _create();

    hb.compile = function (input, options) {
      return compiler.compile(input, options, hb);
    };

    hb.precompile = function (input, options) {
      return compiler.precompile(input, options, hb);
    };

    hb.AST = _handlebarsCompilerAst2['default'];
    hb.Compiler = compiler.Compiler;
    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
    hb.Parser = base.parser;
    hb.parse = base.parse;
    hb.parseWithoutProcessing = base.parseWithoutProcessing;
    return hb;
  }

  var inst = create();
  inst.create = create;

  _handlebarsNoConflict2['default'](inst);

  inst.Visitor = _handlebarsCompilerVisitor2['default'];
  inst['default'] = inst;
  exports['default'] = inst;
  module.exports = exports['default'];
});

/* eslint-disable new-cap */

var print_1 = print;
var PrintVisitor_1 = PrintVisitor; // istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _visitor2 = _interopRequireDefault(visitor);

function print(ast) {
  return new PrintVisitor().accept(ast);
}

function PrintVisitor() {
  this.padding = 0;
}

PrintVisitor.prototype = new _visitor2['default']();

PrintVisitor.prototype.pad = function (string) {
  var out = '';

  for (var i = 0, l = this.padding; i < l; i++) {
    out += '  ';
  }

  out += string + '\n';
  return out;
};

PrintVisitor.prototype.Program = function (program) {
  var out = '',
      body = program.body,
      i = undefined,
      l = undefined;

  if (program.blockParams) {
    var blockParams = 'BLOCK PARAMS: [';

    for (i = 0, l = program.blockParams.length; i < l; i++) {
      blockParams += ' ' + program.blockParams[i];
    }

    blockParams += ' ]';
    out += this.pad(blockParams);
  }

  for (i = 0, l = body.length; i < l; i++) {
    out += this.accept(body[i]);
  }

  this.padding--;
  return out;
};

PrintVisitor.prototype.MustacheStatement = function (mustache) {
  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
};

PrintVisitor.prototype.Decorator = function (mustache) {
  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
};

PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
  var out = '';
  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
  this.padding++;
  out += this.pad(this.SubExpression(block));

  if (block.program) {
    out += this.pad('PROGRAM:');
    this.padding++;
    out += this.accept(block.program);
    this.padding--;
  }

  if (block.inverse) {
    if (block.program) {
      this.padding++;
    }

    out += this.pad('{{^}}');
    this.padding++;
    out += this.accept(block.inverse);
    this.padding--;

    if (block.program) {
      this.padding--;
    }
  }

  this.padding--;
  return out;
};

PrintVisitor.prototype.PartialStatement = function (partial) {
  var content = 'PARTIAL:' + partial.name.original;

  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }

  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }

  return this.pad('{{> ' + content + ' }}');
};

PrintVisitor.prototype.PartialBlockStatement = function (partial) {
  var content = 'PARTIAL BLOCK:' + partial.name.original;

  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }

  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }

  content += ' ' + this.pad('PROGRAM:');
  this.padding++;
  content += this.accept(partial.program);
  this.padding--;
  return this.pad('{{> ' + content + ' }}');
};

PrintVisitor.prototype.ContentStatement = function (content) {
  return this.pad("CONTENT[ '" + content.value + "' ]");
};

PrintVisitor.prototype.CommentStatement = function (comment) {
  return this.pad("{{! '" + comment.value + "' }}");
};

PrintVisitor.prototype.SubExpression = function (sexpr) {
  var params = sexpr.params,
      paramStrings = [],
      hash = undefined;

  for (var i = 0, l = params.length; i < l; i++) {
    paramStrings.push(this.accept(params[i]));
  }

  params = '[' + paramStrings.join(', ') + ']';
  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';
  return this.accept(sexpr.path) + ' ' + params + hash;
};

PrintVisitor.prototype.PathExpression = function (id) {
  var path = id.parts.join('/');
  return (id.data ? '@' : '') + 'PATH:' + path;
};

PrintVisitor.prototype.StringLiteral = function (string) {
  return '"' + string.value + '"';
};

PrintVisitor.prototype.NumberLiteral = function (number) {
  return 'NUMBER{' + number.value + '}';
};

PrintVisitor.prototype.BooleanLiteral = function (bool) {
  return 'BOOLEAN{' + bool.value + '}';
};

PrintVisitor.prototype.UndefinedLiteral = function () {
  return 'UNDEFINED';
};

PrintVisitor.prototype.NullLiteral = function () {
  return 'NULL';
};

PrintVisitor.prototype.Hash = function (hash) {
  var pairs = hash.pairs,
      joinedPairs = [];

  for (var i = 0, l = pairs.length; i < l; i++) {
    joinedPairs.push(this.accept(pairs[i]));
  }

  return 'HASH{' + joinedPairs.join(', ') + '}';
};

PrintVisitor.prototype.HashPair = function (pair) {
  return pair.key + '=' + this.accept(pair.value);
};
/* eslint-enable new-cap */


var printer = /*#__PURE__*/Object.defineProperty({
  print: print_1,
  PrintVisitor: PrintVisitor_1
}, '__esModule', {
  value: true
});

// var handlebars = require('handlebars');

/* eslint-disable no-var */
// var local = handlebars.create();

var handlebars = handlebars$1['default'];
handlebars.PrintVisitor = printer.PrintVisitor;
handlebars.print = printer.print;
var lib$2 = handlebars; // Publish a Node.js require() handler for .handlebars and .hbs files

function extension(module, filename) {
  var fs$1 = fs;
  var templateString = fs$1.readFileSync(filename, 'utf8');
  module.exports = handlebars.compile(templateString);
}
/* istanbul ignore else */


if (typeof commonjsRequire !== 'undefined' && commonjsRequire.extensions) {
  commonjsRequire.extensions['.handlebars'] = extension;
  commonjsRequire.extensions['.hbs'] = extension;
}

var template_1 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.template = void 0;

  var fs_1 = __importDefault(fs);

  var path_1 = __importDefault(require$$1$2);

  var handlebars_1 = __importDefault(lib$2); // import { fileURLToPath } from 'url'
  // const __filename = fileURLToPath(import.meta.url)
  // const __dirname = path.dirname(__filename)


  var templates = new Map();

  function template(_x) {
    return _template.apply(this, arguments);
  }

  function _template() {
    _template = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(name) {
      var params,
          templateSrc,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              params = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};

              if (templates.has(name)) {
                _context.next = 6;
                break;
              }

              _context.next = 4;
              return fs_1.default.promises.readFile(path_1.default.join(__dirname, '..', 'templates', "".concat(name, ".xml")), 'utf8');

            case 4:
              templateSrc = _context.sent;
              templates.set(name, handlebars_1.default.compile(templateSrc));

            case 6:
              return _context.abrupt("return", templates.get(name)(params));

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _template.apply(this, arguments);
  }

  exports.template = template;
});

var Aacute$1 = "Á";
var aacute$1 = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave$1 = "À";
var agrave$1 = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos$1 = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar$1 = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy$1 = "©";
var COPY$1 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute$1 = "É";
var eacute$1 = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave$1 = "È";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt$2 = ">";
var GT$1 = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute$1 = "Í";
var iacute$1 = "í";
var ic = "⁣";
var Icirc$1 = "Î";
var icirc$1 = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest$1 = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo$1 = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt$2 = "<";
var LT$1 = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro$1 = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot$1 = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not$1 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var oast = "⊛";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var osol = "⊘";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para$1 = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound$1 = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot$2 = "\"";
var QUOT$1 = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo$1 = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg$1 = "®";
var REG$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig$1 = "ß";
var Tab = "\t";
var target = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times$1 = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml$1 = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$1$1 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	Acy: Acy,
	acy: acy,
	AElig: AElig$1,
	aelig: aelig$1,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave$1,
	agrave: agrave$1,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$2,
	AMP: AMP$1,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring$1,
	aring: aring$1,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar$1,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil$1,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent$1,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy$1,
	COPY: COPY$1,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg$1,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute$1,
	eacute: eacute$1,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave$1,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$2,
	GT: GT$1,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute$1,
	iacute: iacute$1,
	ic: ic,
	Icirc: Icirc$1,
	icirc: icirc$1,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave$1,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest$1,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml$1,
	iuml: iuml$1,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$2,
	LT: LT$1,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro$1,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot$1,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not$1,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute$1,
	oacute: oacute$1,
	oast: oast,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash$1,
	oslash: oslash$1,
	osol: osol,
	Otilde: Otilde$1,
	otilde: otilde$1,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml$1,
	ouml: ouml$1,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para$1,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound$1,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$2,
	QUOT: QUOT$1,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg$1,
	REG: REG$1,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy$1,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig$1,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN$1,
	thorn: thorn$1,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute$1,
	uacute: uacute$1,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml$1,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml$1,
	uuml: uuml$1,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute$1,
	yacute: yacute$1,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen$1,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml$1,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var Aacute = "Á";
var aacute = "á";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var AElig = "Æ";
var aelig = "æ";
var Agrave = "À";
var agrave = "à";
var amp$1 = "&";
var AMP = "&";
var Aring = "Å";
var aring = "å";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var brvbar = "¦";
var Ccedil = "Ç";
var ccedil = "ç";
var cedil = "¸";
var cent = "¢";
var copy = "©";
var COPY = "©";
var curren = "¤";
var deg = "°";
var divide = "÷";
var Eacute = "É";
var eacute = "é";
var Ecirc = "Ê";
var ecirc = "ê";
var Egrave = "È";
var egrave = "è";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var frac12 = "½";
var frac14 = "¼";
var frac34 = "¾";
var gt$1 = ">";
var GT = ">";
var Iacute = "Í";
var iacute = "í";
var Icirc = "Î";
var icirc = "î";
var iexcl = "¡";
var Igrave = "Ì";
var igrave = "ì";
var iquest = "¿";
var Iuml = "Ï";
var iuml = "ï";
var laquo = "«";
var lt$1 = "<";
var LT = "<";
var macr = "¯";
var micro = "µ";
var middot = "·";
var nbsp = " ";
var not = "¬";
var Ntilde = "Ñ";
var ntilde = "ñ";
var Oacute = "Ó";
var oacute = "ó";
var Ocirc = "Ô";
var ocirc = "ô";
var Ograve = "Ò";
var ograve = "ò";
var ordf = "ª";
var ordm = "º";
var Oslash = "Ø";
var oslash = "ø";
var Otilde = "Õ";
var otilde = "õ";
var Ouml = "Ö";
var ouml = "ö";
var para = "¶";
var plusmn = "±";
var pound = "£";
var quot$1 = "\"";
var QUOT = "\"";
var raquo = "»";
var reg = "®";
var REG = "®";
var sect = "§";
var shy = "­";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var szlig = "ß";
var THORN = "Þ";
var thorn = "þ";
var times = "×";
var Uacute = "Ú";
var uacute = "ú";
var Ucirc = "Û";
var ucirc = "û";
var Ugrave = "Ù";
var ugrave = "ù";
var uml = "¨";
var Uuml = "Ü";
var uuml = "ü";
var Yacute = "Ý";
var yacute = "ý";
var yen = "¥";
var yuml = "ÿ";
var require$$1 = {
	Aacute: Aacute,
	aacute: aacute,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	AElig: AElig,
	aelig: aelig,
	Agrave: Agrave,
	agrave: agrave,
	amp: amp$1,
	AMP: AMP,
	Aring: Aring,
	aring: aring,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	brvbar: brvbar,
	Ccedil: Ccedil,
	ccedil: ccedil,
	cedil: cedil,
	cent: cent,
	copy: copy,
	COPY: COPY,
	curren: curren,
	deg: deg,
	divide: divide,
	Eacute: Eacute,
	eacute: eacute,
	Ecirc: Ecirc,
	ecirc: ecirc,
	Egrave: Egrave,
	egrave: egrave,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	frac12: frac12,
	frac14: frac14,
	frac34: frac34,
	gt: gt$1,
	GT: GT,
	Iacute: Iacute,
	iacute: iacute,
	Icirc: Icirc,
	icirc: icirc,
	iexcl: iexcl,
	Igrave: Igrave,
	igrave: igrave,
	iquest: iquest,
	Iuml: Iuml,
	iuml: iuml,
	laquo: laquo,
	lt: lt$1,
	LT: LT,
	macr: macr,
	micro: micro,
	middot: middot,
	nbsp: nbsp,
	not: not,
	Ntilde: Ntilde,
	ntilde: ntilde,
	Oacute: Oacute,
	oacute: oacute,
	Ocirc: Ocirc,
	ocirc: ocirc,
	Ograve: Ograve,
	ograve: ograve,
	ordf: ordf,
	ordm: ordm,
	Oslash: Oslash,
	oslash: oslash,
	Otilde: Otilde,
	otilde: otilde,
	Ouml: Ouml,
	ouml: ouml,
	para: para,
	plusmn: plusmn,
	pound: pound,
	quot: quot$1,
	QUOT: QUOT,
	raquo: raquo,
	reg: reg,
	REG: REG,
	sect: sect,
	shy: shy,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	szlig: szlig,
	THORN: THORN,
	thorn: thorn,
	times: times,
	Uacute: Uacute,
	uacute: uacute,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uml: uml,
	Uuml: Uuml,
	uuml: uuml,
	Yacute: Yacute,
	yacute: yacute,
	yen: yen,
	yuml: yuml
};

var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = "\"";
var require$$0$1 = {
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot
};

var require$$0 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var decode_json_1 = __importDefault$2(require$$0); // Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119


var fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint || function (codePoint) {
  var output = "";

  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }

  output += String.fromCharCode(codePoint);
  return output;
};

function decodeCodePoint(codePoint) {
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }

  if (codePoint in decode_json_1.default) {
    codePoint = decode_json_1.default[codePoint];
  }

  return fromCodePoint(codePoint);
}

var _default$2 = decodeCodePoint;
var decode_codepoint = /*#__PURE__*/Object.defineProperty({
  default: _default$2
}, '__esModule', {
  value: true
});

var decode = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;

  var entities_json_1 = __importDefault(require$$1$1);

  var legacy_json_1 = __importDefault(require$$1);

  var xml_json_1 = __importDefault(require$$0$1);

  var decode_codepoint_1 = __importDefault(decode_codepoint);

  var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  exports.decodeXML = getStrictDecoder(xml_json_1.default);
  exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);

  function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }

  var sorter = function sorter(a, b) {
    return a < b ? 1 : -1;
  };

  exports.decodeHTML = function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);

    for (var i = 0, j = 0; i < keys.length; i++) {
      if (legacy[j] === keys[i]) {
        keys[i] += ";?";
        j++;
      } else {
        keys[i] += ";";
      }
    }

    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);

    function replacer(str) {
      if (str.substr(-1) !== ";") str += ";";
      return replace(str);
    } // TODO consider creating a merged map


    return function (str) {
      return String(str).replace(re, replacer);
    };
  }();

  function getReplacer(map) {
    return function replace(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);

        if (secondChar === "X" || secondChar === "x") {
          return decode_codepoint_1.default(parseInt(str.substr(3), 16));
        }

        return decode_codepoint_1.default(parseInt(str.substr(2), 10));
      } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing


      return map[str.slice(1, -1)] || str;
    };
  }
});

var encode = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;

  var xml_json_1 = __importDefault(require$$0$1);

  var inverseXML = getInverseObj(xml_json_1.default);
  var xmlReplacer = getInverseReplacer(inverseXML);
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using XML entities.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */

  exports.encodeXML = getASCIIEncoder(inverseXML);

  var entities_json_1 = __importDefault(require$$1$1);

  var inverseHTML = getInverseObj(entities_json_1.default);
  var htmlReplacer = getInverseReplacer(inverseHTML);
  /**
   * Encodes all entities and non-ASCII characters in the input.
   *
   * This includes characters that are valid ASCII characters in HTML documents.
   * For example `#` will be encoded as `&num;`. To get a more compact output,
   * consider using the `encodeNonAsciiHTML` function.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */

  exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in HTML
   * documents using HTML entities.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */

  exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);

  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function (inverse, name) {
      inverse[obj[name]] = "&" + name + ";";
      return inverse;
    }, {});
  }

  function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];

    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
      var k = _a[_i];

      if (k.length === 1) {
        // Add value to single array
        single.push("\\" + k);
      } else {
        // Add value to multiple array
        multiple.push(k);
      }
    } // Add ranges to single characters.


    single.sort();

    for (var start = 0; start < single.length - 1; start++) {
      // Find the end of a run of characters
      var end = start;

      while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
        end += 1;
      }

      var count = 1 + end - start; // We want to replace at least three characters

      if (count < 3) continue;
      single.splice(start, count, single[start] + "-" + single[end]);
    }

    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
  } // /[^\0-\x7F]/gu


  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
  var getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  function (str) {
    return str.codePointAt(0);
  } : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  function (c) {
    return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;
  };

  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }

  function getInverse(inverse, re) {
    return function (data) {
      return data.replace(re, function (name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }

  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using numeric hexadecimal reference (eg. `&#xfc;`).
   *
   * Have a look at `escapeUTF8` if you want a more concise output at the expense
   * of reduced transportability.
   *
   * @param data String to escape.
   */

  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }

  exports.escape = escape;
  /**
   * Encodes all characters not valid in XML documents using numeric hexadecimal
   * reference (eg. `&#xfc;`).
   *
   * Note that the output will be character-set dependent.
   *
   * @param data String to escape.
   */

  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }

  exports.escapeUTF8 = escapeUTF8;

  function getASCIIEncoder(obj) {
    return function (data) {
      return data.replace(reEscapeChars, function (c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
});

var lib$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
  /**
   * Decodes a string with entities.
   *
   * @param data String to decode.
   * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
   * @deprecated Use `decodeXML` or `decodeHTML` directly.
   */

  function decode$1(data, level) {
    return (!level || level <= 0 ? decode.decodeXML : decode.decodeHTML)(data);
  }

  exports.decode = decode$1;
  /**
   * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
   *
   * @param data String to decode.
   * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
   * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
   */

  function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode.decodeXML : decode.decodeHTMLStrict)(data);
  }

  exports.decodeStrict = decodeStrict;
  /**
   * Encodes a string with entities.
   *
   * @param data String to encode.
   * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
   * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
   */

  function encode$1(data, level) {
    return (!level || level <= 0 ? encode.encodeXML : encode.encodeHTML)(data);
  }

  exports.encode = encode$1;
  var encode_2 = encode;
  Object.defineProperty(exports, "encodeXML", {
    enumerable: true,
    get: function get() {
      return encode_2.encodeXML;
    }
  });
  Object.defineProperty(exports, "encodeHTML", {
    enumerable: true,
    get: function get() {
      return encode_2.encodeHTML;
    }
  });
  Object.defineProperty(exports, "encodeNonAsciiHTML", {
    enumerable: true,
    get: function get() {
      return encode_2.encodeNonAsciiHTML;
    }
  });
  Object.defineProperty(exports, "escape", {
    enumerable: true,
    get: function get() {
      return encode_2.escape;
    }
  });
  Object.defineProperty(exports, "escapeUTF8", {
    enumerable: true,
    get: function get() {
      return encode_2.escapeUTF8;
    }
  }); // Legacy aliases (deprecated)

  Object.defineProperty(exports, "encodeHTML4", {
    enumerable: true,
    get: function get() {
      return encode_2.encodeHTML;
    }
  });
  Object.defineProperty(exports, "encodeHTML5", {
    enumerable: true,
    get: function get() {
      return encode_2.encodeHTML;
    }
  });
  var decode_2 = decode;
  Object.defineProperty(exports, "decodeXML", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeXML;
    }
  });
  Object.defineProperty(exports, "decodeHTML", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeHTML;
    }
  });
  Object.defineProperty(exports, "decodeHTMLStrict", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeHTMLStrict;
    }
  }); // Legacy aliases (deprecated)

  Object.defineProperty(exports, "decodeHTML4", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeHTML;
    }
  });
  Object.defineProperty(exports, "decodeHTML5", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeHTML;
    }
  });
  Object.defineProperty(exports, "decodeHTML4Strict", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeHTMLStrict;
    }
  });
  Object.defineProperty(exports, "decodeHTML5Strict", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeHTMLStrict;
    }
  });
  Object.defineProperty(exports, "decodeXMLStrict", {
    enumerable: true,
    get: function get() {
      return decode_2.decodeXML;
    }
  });
});

var defaults = createCommonjsModule(function (module, exports) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    exports.defaults = {
      "0.1": {
        explicitCharkey: false,
        trim: true,
        normalize: true,
        normalizeTags: false,
        attrkey: "@",
        charkey: "#",
        explicitArray: false,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: false,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        childkey: '@@',
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ''
      },
      "0.2": {
        explicitCharkey: false,
        trim: false,
        normalize: false,
        normalizeTags: false,
        attrkey: "$",
        charkey: "_",
        explicitArray: true,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: true,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        preserveChildrenOrder: false,
        childkey: '$$',
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: 'root',
        xmldec: {
          'version': '1.0',
          'encoding': 'UTF-8',
          'standalone': true
        },
        doctype: null,
        renderOpts: {
          'pretty': true,
          'indent': '  ',
          'newline': '\n'
        },
        headless: false,
        chunkSize: 10000,
        emptyTag: '',
        cdata: false
      }
    };
  }).call(commonjsGlobal);
});

var Utility = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var assign,
        getValue,
        isArray,
        isEmpty,
        isFunction,
        isObject,
        isPlainObject,
        slice = [].slice,
        hasProp = {}.hasOwnProperty;

    assign = function assign() {
      var i, key, len, source, sources, target;
      target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];

      if (isFunction(Object.assign)) {
        Object.assign.apply(null, arguments);
      } else {
        for (i = 0, len = sources.length; i < len; i++) {
          source = sources[i];

          if (source != null) {
            for (key in source) {
              if (!hasProp.call(source, key)) continue;
              target[key] = source[key];
            }
          }
        }
      }

      return target;
    };

    isFunction = function isFunction(val) {
      return !!val && Object.prototype.toString.call(val) === '[object Function]';
    };

    isObject = function isObject(val) {
      var ref;
      return !!val && ((ref = _typeof(val)) === 'function' || ref === 'object');
    };

    isArray = function isArray(val) {
      if (isFunction(Array.isArray)) {
        return Array.isArray(val);
      } else {
        return Object.prototype.toString.call(val) === '[object Array]';
      }
    };

    isEmpty = function isEmpty(val) {
      var key;

      if (isArray(val)) {
        return !val.length;
      } else {
        for (key in val) {
          if (!hasProp.call(val, key)) continue;
          return false;
        }

        return true;
      }
    };

    isPlainObject = function isPlainObject(val) {
      var ctor, proto;
      return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === 'function' && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };

    getValue = function getValue(obj) {
      if (isFunction(obj.valueOf)) {
        return obj.valueOf();
      } else {
        return obj;
      }
    };

    module.exports.assign = assign;
    module.exports.isFunction = isFunction;
    module.exports.isObject = isObject;
    module.exports.isArray = isArray;
    module.exports.isEmpty = isEmpty;
    module.exports.isPlainObject = isPlainObject;
    module.exports.getValue = getValue;
  }).call(commonjsGlobal);
});

var XMLDOMImplementation = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    module.exports = function () {
      function XMLDOMImplementation() {}

      XMLDOMImplementation.prototype.hasFeature = function (feature, version) {
        return true;
      };

      XMLDOMImplementation.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {
        throw new Error("This DOM method is not implemented.");
      };

      XMLDOMImplementation.prototype.createDocument = function (namespaceURI, qualifiedName, doctype) {
        throw new Error("This DOM method is not implemented.");
      };

      XMLDOMImplementation.prototype.createHTMLDocument = function (title) {
        throw new Error("This DOM method is not implemented.");
      };

      XMLDOMImplementation.prototype.getFeature = function (feature, version) {
        throw new Error("This DOM method is not implemented.");
      };

      return XMLDOMImplementation;
    }();
  }).call(commonjsGlobal);
});

var XMLDOMErrorHandler = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    module.exports = function () {
      function XMLDOMErrorHandler() {}

      XMLDOMErrorHandler.prototype.handleError = function (error) {
        throw new Error(error);
      };

      return XMLDOMErrorHandler;
    }();
  }).call(commonjsGlobal);
});

var XMLDOMStringList = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    module.exports = function () {
      function XMLDOMStringList(arr) {
        this.arr = arr || [];
      }

      Object.defineProperty(XMLDOMStringList.prototype, 'length', {
        get: function get() {
          return this.arr.length;
        }
      });

      XMLDOMStringList.prototype.item = function (index) {
        return this.arr[index] || null;
      };

      XMLDOMStringList.prototype.contains = function (str) {
        return this.arr.indexOf(str) !== -1;
      };

      return XMLDOMStringList;
    }();
  }).call(commonjsGlobal);
});

var XMLDOMConfiguration = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var XMLDOMErrorHandler$1, XMLDOMStringList$1;
    XMLDOMErrorHandler$1 = XMLDOMErrorHandler;
    XMLDOMStringList$1 = XMLDOMStringList;

    module.exports = function () {
      function XMLDOMConfiguration() {
        this.defaultParams = {
          "canonical-form": false,
          "cdata-sections": false,
          "comments": false,
          "datatype-normalization": false,
          "element-content-whitespace": true,
          "entities": true,
          "error-handler": new XMLDOMErrorHandler$1(),
          "infoset": true,
          "validate-if-schema": false,
          "namespaces": true,
          "namespace-declarations": true,
          "normalize-characters": false,
          "schema-location": '',
          "schema-type": '',
          "split-cdata-sections": true,
          "validate": false,
          "well-formed": true
        };
        this.params = Object.create(this.defaultParams);
      }

      Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
        get: function get() {
          return new XMLDOMStringList$1(Object.keys(this.defaultParams));
        }
      });

      XMLDOMConfiguration.prototype.getParameter = function (name) {
        if (this.params.hasOwnProperty(name)) {
          return this.params[name];
        } else {
          return null;
        }
      };

      XMLDOMConfiguration.prototype.canSetParameter = function (name, value) {
        return true;
      };

      XMLDOMConfiguration.prototype.setParameter = function (name, value) {
        if (value != null) {
          return this.params[name] = value;
        } else {
          return delete this.params[name];
        }
      };

      return XMLDOMConfiguration;
    }();
  }).call(commonjsGlobal);
});

var NodeType = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    module.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }).call(commonjsGlobal);
});

var XMLAttribute = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1;
    NodeType$1 = NodeType;

    module.exports = function () {
      function XMLAttribute(parent, name, value) {
        this.parent = parent;

        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }

        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo(name));
        }

        this.name = this.stringify.name(name);
        this.value = this.stringify.attValue(value);
        this.type = NodeType$1.Attribute;
        this.isId = false;
        this.schemaTypeInfo = null;
      }

      Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
        get: function get() {
          return this.type;
        }
      });
      Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
        get: function get() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLAttribute.prototype, 'textContent', {
        get: function get() {
          return this.value;
        },
        set: function set(value) {
          return this.value = value || '';
        }
      });
      Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
        get: function get() {
          return '';
        }
      });
      Object.defineProperty(XMLAttribute.prototype, 'prefix', {
        get: function get() {
          return '';
        }
      });
      Object.defineProperty(XMLAttribute.prototype, 'localName', {
        get: function get() {
          return this.name;
        }
      });
      Object.defineProperty(XMLAttribute.prototype, 'specified', {
        get: function get() {
          return true;
        }
      });

      XMLAttribute.prototype.clone = function () {
        return Object.create(this);
      };

      XMLAttribute.prototype.toString = function (options) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
      };

      XMLAttribute.prototype.debugInfo = function (name) {
        name = name || this.name;

        if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else {
          return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        }
      };

      XMLAttribute.prototype.isEqualNode = function (node) {
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }

        if (node.prefix !== this.prefix) {
          return false;
        }

        if (node.localName !== this.localName) {
          return false;
        }

        if (node.value !== this.value) {
          return false;
        }

        return true;
      };

      return XMLAttribute;
    }();
  }).call(commonjsGlobal);
});

var XMLNamedNodeMap = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    module.exports = function () {
      function XMLNamedNodeMap(nodes) {
        this.nodes = nodes;
      }

      Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
        get: function get() {
          return Object.keys(this.nodes).length || 0;
        }
      });

      XMLNamedNodeMap.prototype.clone = function () {
        return this.nodes = null;
      };

      XMLNamedNodeMap.prototype.getNamedItem = function (name) {
        return this.nodes[name];
      };

      XMLNamedNodeMap.prototype.setNamedItem = function (node) {
        var oldNode;
        oldNode = this.nodes[node.nodeName];
        this.nodes[node.nodeName] = node;
        return oldNode || null;
      };

      XMLNamedNodeMap.prototype.removeNamedItem = function (name) {
        var oldNode;
        oldNode = this.nodes[name];
        delete this.nodes[name];
        return oldNode || null;
      };

      XMLNamedNodeMap.prototype.item = function (index) {
        return this.nodes[Object.keys(this.nodes)[index]] || null;
      };

      XMLNamedNodeMap.prototype.getNamedItemNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };

      XMLNamedNodeMap.prototype.setNamedItemNS = function (node) {
        throw new Error("This DOM method is not implemented.");
      };

      XMLNamedNodeMap.prototype.removeNamedItemNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };

      return XMLNamedNodeMap;
    }();
  }).call(commonjsGlobal);
});

var XMLElement = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLAttribute$1,
        XMLNamedNodeMap$1,
        XMLNode$1,
        getValue,
        isFunction,
        isObject,
        ref,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    ref = Utility, isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;
    XMLAttribute$1 = XMLAttribute;
    XMLNamedNodeMap$1 = XMLNamedNodeMap;

    module.exports = function (superClass) {
      extend(XMLElement, superClass);

      function XMLElement(parent, name, attributes) {
        var child, j, len, ref1;

        XMLElement.__super__.constructor.call(this, parent);

        if (name == null) {
          throw new Error("Missing element name. " + this.debugInfo());
        }

        this.name = this.stringify.name(name);
        this.type = NodeType$1.Element;
        this.attribs = {};
        this.schemaTypeInfo = null;

        if (attributes != null) {
          this.attribute(attributes);
        }

        if (parent.type === NodeType$1.Document) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;

          if (parent.children) {
            ref1 = parent.children;

            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];

              if (child.type === NodeType$1.DocType) {
                child.name = this.name;
                break;
              }
            }
          }
        }
      }

      Object.defineProperty(XMLElement.prototype, 'tagName', {
        get: function get() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
        get: function get() {
          return '';
        }
      });
      Object.defineProperty(XMLElement.prototype, 'prefix', {
        get: function get() {
          return '';
        }
      });
      Object.defineProperty(XMLElement.prototype, 'localName', {
        get: function get() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement.prototype, 'id', {
        get: function get() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement.prototype, 'className', {
        get: function get() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement.prototype, 'classList', {
        get: function get() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement.prototype, 'attributes', {
        get: function get() {
          if (!this.attributeMap || !this.attributeMap.nodes) {
            this.attributeMap = new XMLNamedNodeMap$1(this.attribs);
          }

          return this.attributeMap;
        }
      });

      XMLElement.prototype.clone = function () {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this);

        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }

        clonedSelf.attribs = {};
        ref1 = this.attribs;

        for (attName in ref1) {
          if (!hasProp.call(ref1, attName)) continue;
          att = ref1[attName];
          clonedSelf.attribs[attName] = att.clone();
        }

        clonedSelf.children = [];
        this.children.forEach(function (child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };

      XMLElement.prototype.attribute = function (name, value) {
        var attName, attValue;

        if (name != null) {
          name = getValue(name);
        }

        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }

          if (this.options.keepNullAttributes && value == null) {
            this.attribs[name] = new XMLAttribute$1(this, name, "");
          } else if (value != null) {
            this.attribs[name] = new XMLAttribute$1(this, name, value);
          }
        }

        return this;
      };

      XMLElement.prototype.removeAttribute = function (name) {
        var attName, j, len;

        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo());
        }

        name = getValue(name);

        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            attName = name[j];
            delete this.attribs[attName];
          }
        } else {
          delete this.attribs[name];
        }

        return this;
      };

      XMLElement.prototype.toString = function (options) {
        return this.options.writer.element(this, this.options.writer.filterOptions(options));
      };

      XMLElement.prototype.att = function (name, value) {
        return this.attribute(name, value);
      };

      XMLElement.prototype.a = function (name, value) {
        return this.attribute(name, value);
      };

      XMLElement.prototype.getAttribute = function (name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].value;
        } else {
          return null;
        }
      };

      XMLElement.prototype.setAttribute = function (name, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getAttributeNode = function (name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name];
        } else {
          return null;
        }
      };

      XMLElement.prototype.setAttributeNode = function (newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.removeAttributeNode = function (oldAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getElementsByTagName = function (name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getAttributeNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.setAttributeNS = function (namespaceURI, qualifiedName, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.removeAttributeNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getAttributeNodeNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.setAttributeNodeNS = function (newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.hasAttribute = function (name) {
        return this.attribs.hasOwnProperty(name);
      };

      XMLElement.prototype.hasAttributeNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.setIdAttribute = function (name, isId) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].isId;
        } else {
          return isId;
        }
      };

      XMLElement.prototype.setIdAttributeNS = function (namespaceURI, localName, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.setIdAttributeNode = function (idAttr, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getElementsByTagName = function (tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.getElementsByClassName = function (classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLElement.prototype.isEqualNode = function (node) {
        var i, j, ref1;

        if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }

        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }

        if (node.prefix !== this.prefix) {
          return false;
        }

        if (node.localName !== this.localName) {
          return false;
        }

        if (node.attribs.length !== this.attribs.length) {
          return false;
        }

        for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
          if (!this.attribs[i].isEqualNode(node.attribs[i])) {
            return false;
          }
        }

        return true;
      };

      return XMLElement;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLCharacterData = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var XMLNode$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    XMLNode$1 = XMLNode;

    module.exports = function (superClass) {
      extend(XMLCharacterData, superClass);

      function XMLCharacterData(parent) {
        XMLCharacterData.__super__.constructor.call(this, parent);

        this.value = '';
      }

      Object.defineProperty(XMLCharacterData.prototype, 'data', {
        get: function get() {
          return this.value;
        },
        set: function set(value) {
          return this.value = value || '';
        }
      });
      Object.defineProperty(XMLCharacterData.prototype, 'length', {
        get: function get() {
          return this.value.length;
        }
      });
      Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
        get: function get() {
          return this.value;
        },
        set: function set(value) {
          return this.value = value || '';
        }
      });

      XMLCharacterData.prototype.clone = function () {
        return Object.create(this);
      };

      XMLCharacterData.prototype.substringData = function (offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLCharacterData.prototype.appendData = function (arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLCharacterData.prototype.insertData = function (offset, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLCharacterData.prototype.deleteData = function (offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLCharacterData.prototype.replaceData = function (offset, count, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLCharacterData.prototype.isEqualNode = function (node) {
        if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }

        if (node.data !== this.data) {
          return false;
        }

        return true;
      };

      return XMLCharacterData;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLCData = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLCharacterData$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    NodeType$1 = NodeType;
    XMLCharacterData$1 = XMLCharacterData;

    module.exports = function (superClass) {
      extend(XMLCData, superClass);

      function XMLCData(parent, text) {
        XMLCData.__super__.constructor.call(this, parent);

        if (text == null) {
          throw new Error("Missing CDATA text. " + this.debugInfo());
        }

        this.name = "#cdata-section";
        this.type = NodeType$1.CData;
        this.value = this.stringify.cdata(text);
      }

      XMLCData.prototype.clone = function () {
        return Object.create(this);
      };

      XMLCData.prototype.toString = function (options) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
      };

      return XMLCData;
    }(XMLCharacterData$1);
  }).call(commonjsGlobal);
});

var XMLComment = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLCharacterData$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    NodeType$1 = NodeType;
    XMLCharacterData$1 = XMLCharacterData;

    module.exports = function (superClass) {
      extend(XMLComment, superClass);

      function XMLComment(parent, text) {
        XMLComment.__super__.constructor.call(this, parent);

        if (text == null) {
          throw new Error("Missing comment text. " + this.debugInfo());
        }

        this.name = "#comment";
        this.type = NodeType$1.Comment;
        this.value = this.stringify.comment(text);
      }

      XMLComment.prototype.clone = function () {
        return Object.create(this);
      };

      XMLComment.prototype.toString = function (options) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(options));
      };

      return XMLComment;
    }(XMLCharacterData$1);
  }).call(commonjsGlobal);
});

var XMLDeclaration = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLNode$1,
        isObject,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    isObject = Utility.isObject;
    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;

    module.exports = function (superClass) {
      extend(XMLDeclaration, superClass);

      function XMLDeclaration(parent, version, encoding, standalone) {
        var ref;

        XMLDeclaration.__super__.constructor.call(this, parent);

        if (isObject(version)) {
          ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
        }

        if (!version) {
          version = '1.0';
        }

        this.type = NodeType$1.Declaration;
        this.version = this.stringify.xmlVersion(version);

        if (encoding != null) {
          this.encoding = this.stringify.xmlEncoding(encoding);
        }

        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }

      XMLDeclaration.prototype.toString = function (options) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
      };

      return XMLDeclaration;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLDTDAttList = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLNode$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;

    module.exports = function (superClass) {
      extend(XMLDTDAttList, superClass);

      function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        XMLDTDAttList.__super__.constructor.call(this, parent);

        if (elementName == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }

        if (attributeName == null) {
          throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
        }

        if (!attributeType) {
          throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
        }

        if (!defaultValueType) {
          throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
        }

        if (defaultValueType.indexOf('#') !== 0) {
          defaultValueType = '#' + defaultValueType;
        }

        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }

        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }

        this.elementName = this.stringify.name(elementName);
        this.type = NodeType$1.AttributeDeclaration;
        this.attributeName = this.stringify.name(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);

        if (defaultValue) {
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        }

        this.defaultValueType = defaultValueType;
      }

      XMLDTDAttList.prototype.toString = function (options) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
      };

      return XMLDTDAttList;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLDTDEntity = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLNode$1,
        isObject,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    isObject = Utility.isObject;
    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;

    module.exports = function (superClass) {
      extend(XMLDTDEntity, superClass);

      function XMLDTDEntity(parent, pe, name, value) {
        XMLDTDEntity.__super__.constructor.call(this, parent);

        if (name == null) {
          throw new Error("Missing DTD entity name. " + this.debugInfo(name));
        }

        if (value == null) {
          throw new Error("Missing DTD entity value. " + this.debugInfo(name));
        }

        this.pe = !!pe;
        this.name = this.stringify.name(name);
        this.type = NodeType$1.EntityDeclaration;

        if (!isObject(value)) {
          this.value = this.stringify.dtdEntityValue(value);
          this.internal = true;
        } else {
          if (!value.pubID && !value.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
          }

          if (value.pubID && !value.sysID) {
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
          }

          this.internal = false;

          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }

          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }

          if (value.nData != null) {
            this.nData = this.stringify.dtdNData(value.nData);
          }

          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
          }
        }
      }

      Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
        get: function get() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
        get: function get() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
        get: function get() {
          return this.nData || null;
        }
      });
      Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
        get: function get() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
        get: function get() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
        get: function get() {
          return null;
        }
      });

      XMLDTDEntity.prototype.toString = function (options) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
      };

      return XMLDTDEntity;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLDTDElement = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLNode$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;

    module.exports = function (superClass) {
      extend(XMLDTDElement, superClass);

      function XMLDTDElement(parent, name, value) {
        XMLDTDElement.__super__.constructor.call(this, parent);

        if (name == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }

        if (!value) {
          value = '(#PCDATA)';
        }

        if (Array.isArray(value)) {
          value = '(' + value.join(',') + ')';
        }

        this.name = this.stringify.name(name);
        this.type = NodeType$1.ElementDeclaration;
        this.value = this.stringify.dtdElementValue(value);
      }

      XMLDTDElement.prototype.toString = function (options) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
      };

      return XMLDTDElement;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLDTDNotation = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLNode$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;

    module.exports = function (superClass) {
      extend(XMLDTDNotation, superClass);

      function XMLDTDNotation(parent, name, value) {
        XMLDTDNotation.__super__.constructor.call(this, parent);

        if (name == null) {
          throw new Error("Missing DTD notation name. " + this.debugInfo(name));
        }

        if (!value.pubID && !value.sysID) {
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
        }

        this.name = this.stringify.name(name);
        this.type = NodeType$1.NotationDeclaration;

        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }

        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
      }

      Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
        get: function get() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
        get: function get() {
          return this.sysID;
        }
      });

      XMLDTDNotation.prototype.toString = function (options) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
      };

      return XMLDTDNotation;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLDocType = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLDTDAttList$1,
        XMLDTDElement$1,
        XMLDTDEntity$1,
        XMLDTDNotation$1,
        XMLNamedNodeMap$1,
        XMLNode$1,
        isObject,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    isObject = Utility.isObject;
    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;
    XMLDTDAttList$1 = XMLDTDAttList;
    XMLDTDEntity$1 = XMLDTDEntity;
    XMLDTDElement$1 = XMLDTDElement;
    XMLDTDNotation$1 = XMLDTDNotation;
    XMLNamedNodeMap$1 = XMLNamedNodeMap;

    module.exports = function (superClass) {
      extend(XMLDocType, superClass);

      function XMLDocType(parent, pubID, sysID) {
        var child, i, len, ref, ref1, ref2;

        XMLDocType.__super__.constructor.call(this, parent);

        this.type = NodeType$1.DocType;

        if (parent.children) {
          ref = parent.children;

          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];

            if (child.type === NodeType$1.Element) {
              this.name = child.name;
              break;
            }
          }
        }

        this.documentObject = parent;

        if (isObject(pubID)) {
          ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
        }

        if (sysID == null) {
          ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
        }

        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }

        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }

      Object.defineProperty(XMLDocType.prototype, 'entities', {
        get: function get() {
          var child, i, len, nodes, ref;
          nodes = {};
          ref = this.children;

          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];

            if (child.type === NodeType$1.EntityDeclaration && !child.pe) {
              nodes[child.name] = child;
            }
          }

          return new XMLNamedNodeMap$1(nodes);
        }
      });
      Object.defineProperty(XMLDocType.prototype, 'notations', {
        get: function get() {
          var child, i, len, nodes, ref;
          nodes = {};
          ref = this.children;

          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];

            if (child.type === NodeType$1.NotationDeclaration) {
              nodes[child.name] = child;
            }
          }

          return new XMLNamedNodeMap$1(nodes);
        }
      });
      Object.defineProperty(XMLDocType.prototype, 'publicId', {
        get: function get() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDocType.prototype, 'systemId', {
        get: function get() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
        get: function get() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });

      XMLDocType.prototype.element = function (name, value) {
        var child;
        child = new XMLDTDElement$1(this, name, value);
        this.children.push(child);
        return this;
      };

      XMLDocType.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList$1(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      };

      XMLDocType.prototype.entity = function (name, value) {
        var child;
        child = new XMLDTDEntity$1(this, false, name, value);
        this.children.push(child);
        return this;
      };

      XMLDocType.prototype.pEntity = function (name, value) {
        var child;
        child = new XMLDTDEntity$1(this, true, name, value);
        this.children.push(child);
        return this;
      };

      XMLDocType.prototype.notation = function (name, value) {
        var child;
        child = new XMLDTDNotation$1(this, name, value);
        this.children.push(child);
        return this;
      };

      XMLDocType.prototype.toString = function (options) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(options));
      };

      XMLDocType.prototype.ele = function (name, value) {
        return this.element(name, value);
      };

      XMLDocType.prototype.att = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      };

      XMLDocType.prototype.ent = function (name, value) {
        return this.entity(name, value);
      };

      XMLDocType.prototype.pent = function (name, value) {
        return this.pEntity(name, value);
      };

      XMLDocType.prototype.not = function (name, value) {
        return this.notation(name, value);
      };

      XMLDocType.prototype.up = function () {
        return this.root() || this.documentObject;
      };

      XMLDocType.prototype.isEqualNode = function (node) {
        if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }

        if (node.name !== this.name) {
          return false;
        }

        if (node.publicId !== this.publicId) {
          return false;
        }

        if (node.systemId !== this.systemId) {
          return false;
        }

        return true;
      };

      return XMLDocType;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLRaw = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLNode$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    NodeType$1 = NodeType;
    XMLNode$1 = XMLNode;

    module.exports = function (superClass) {
      extend(XMLRaw, superClass);

      function XMLRaw(parent, text) {
        XMLRaw.__super__.constructor.call(this, parent);

        if (text == null) {
          throw new Error("Missing raw text. " + this.debugInfo());
        }

        this.type = NodeType$1.Raw;
        this.value = this.stringify.raw(text);
      }

      XMLRaw.prototype.clone = function () {
        return Object.create(this);
      };

      XMLRaw.prototype.toString = function (options) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(options));
      };

      return XMLRaw;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLText = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLCharacterData$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    NodeType$1 = NodeType;
    XMLCharacterData$1 = XMLCharacterData;

    module.exports = function (superClass) {
      extend(XMLText, superClass);

      function XMLText(parent, text) {
        XMLText.__super__.constructor.call(this, parent);

        if (text == null) {
          throw new Error("Missing element text. " + this.debugInfo());
        }

        this.name = "#text";
        this.type = NodeType$1.Text;
        this.value = this.stringify.text(text);
      }

      Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
        get: function get() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLText.prototype, 'wholeText', {
        get: function get() {
          var next, prev, str;
          str = '';
          prev = this.previousSibling;

          while (prev) {
            str = prev.data + str;
            prev = prev.previousSibling;
          }

          str += this.data;
          next = this.nextSibling;

          while (next) {
            str = str + next.data;
            next = next.nextSibling;
          }

          return str;
        }
      });

      XMLText.prototype.clone = function () {
        return Object.create(this);
      };

      XMLText.prototype.toString = function (options) {
        return this.options.writer.text(this, this.options.writer.filterOptions(options));
      };

      XMLText.prototype.splitText = function (offset) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLText.prototype.replaceWholeText = function (content) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      return XMLText;
    }(XMLCharacterData$1);
  }).call(commonjsGlobal);
});

var XMLProcessingInstruction = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLCharacterData$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    NodeType$1 = NodeType;
    XMLCharacterData$1 = XMLCharacterData;

    module.exports = function (superClass) {
      extend(XMLProcessingInstruction, superClass);

      function XMLProcessingInstruction(parent, target, value) {
        XMLProcessingInstruction.__super__.constructor.call(this, parent);

        if (target == null) {
          throw new Error("Missing instruction target. " + this.debugInfo());
        }

        this.type = NodeType$1.ProcessingInstruction;
        this.target = this.stringify.insTarget(target);
        this.name = this.target;

        if (value) {
          this.value = this.stringify.insValue(value);
        }
      }

      XMLProcessingInstruction.prototype.clone = function () {
        return Object.create(this);
      };

      XMLProcessingInstruction.prototype.toString = function (options) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
      };

      XMLProcessingInstruction.prototype.isEqualNode = function (node) {
        if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }

        if (node.target !== this.target) {
          return false;
        }

        return true;
      };

      return XMLProcessingInstruction;
    }(XMLCharacterData$1);
  }).call(commonjsGlobal);
});

var XMLDummy = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLNode$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;

    module.exports = function (superClass) {
      extend(XMLDummy, superClass);

      function XMLDummy(parent) {
        XMLDummy.__super__.constructor.call(this, parent);

        this.type = NodeType$1.Dummy;
      }

      XMLDummy.prototype.clone = function () {
        return Object.create(this);
      };

      XMLDummy.prototype.toString = function (options) {
        return '';
      };

      return XMLDummy;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLNodeList = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    module.exports = function () {
      function XMLNodeList(nodes) {
        this.nodes = nodes;
      }

      Object.defineProperty(XMLNodeList.prototype, 'length', {
        get: function get() {
          return this.nodes.length || 0;
        }
      });

      XMLNodeList.prototype.clone = function () {
        return this.nodes = null;
      };

      XMLNodeList.prototype.item = function (index) {
        return this.nodes[index] || null;
      };

      return XMLNodeList;
    }();
  }).call(commonjsGlobal);
});

var DocumentPosition = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    module.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }).call(commonjsGlobal);
});

var XMLNode = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var DocumentPosition$1,
        NodeType$1,
        XMLCData$1,
        XMLComment$1,
        XMLDeclaration$1,
        XMLDocType$1,
        XMLDummy$1,
        XMLElement$1,
        XMLNodeList$1,
        XMLProcessingInstruction$1,
        XMLRaw$1,
        XMLText$1,
        getValue,
        isEmpty,
        isFunction,
        isObject,
        ref1,
        hasProp = {}.hasOwnProperty;
    ref1 = Utility, isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
    XMLElement$1 = null;
    XMLCData$1 = null;
    XMLComment$1 = null;
    XMLDeclaration$1 = null;
    XMLDocType$1 = null;
    XMLRaw$1 = null;
    XMLText$1 = null;
    XMLProcessingInstruction$1 = null;
    XMLDummy$1 = null;
    NodeType$1 = null;
    XMLNodeList$1 = null;
    DocumentPosition$1 = null;

    module.exports = function () {
      function XMLNode(parent1) {
        this.parent = parent1;

        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }

        this.value = null;
        this.children = [];
        this.baseURI = null;

        if (!XMLElement$1) {
          XMLElement$1 = XMLElement;
          XMLCData$1 = XMLCData;
          XMLComment$1 = XMLComment;
          XMLDeclaration$1 = XMLDeclaration;
          XMLDocType$1 = XMLDocType;
          XMLRaw$1 = XMLRaw;
          XMLText$1 = XMLText;
          XMLProcessingInstruction$1 = XMLProcessingInstruction;
          XMLDummy$1 = XMLDummy;
          NodeType$1 = NodeType;
          XMLNodeList$1 = XMLNodeList;
          DocumentPosition$1 = DocumentPosition;
        }
      }

      Object.defineProperty(XMLNode.prototype, 'nodeName', {
        get: function get() {
          return this.name;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'nodeType', {
        get: function get() {
          return this.type;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'nodeValue', {
        get: function get() {
          return this.value;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'parentNode', {
        get: function get() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'childNodes', {
        get: function get() {
          if (!this.childNodeList || !this.childNodeList.nodes) {
            this.childNodeList = new XMLNodeList$1(this.children);
          }

          return this.childNodeList;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'firstChild', {
        get: function get() {
          return this.children[0] || null;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'lastChild', {
        get: function get() {
          return this.children[this.children.length - 1] || null;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'previousSibling', {
        get: function get() {
          var i;
          i = this.parent.children.indexOf(this);
          return this.parent.children[i - 1] || null;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'nextSibling', {
        get: function get() {
          var i;
          i = this.parent.children.indexOf(this);
          return this.parent.children[i + 1] || null;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
        get: function get() {
          return this.document() || null;
        }
      });
      Object.defineProperty(XMLNode.prototype, 'textContent', {
        get: function get() {
          var child, j, len, ref2, str;

          if (this.nodeType === NodeType$1.Element || this.nodeType === NodeType$1.DocumentFragment) {
            str = '';
            ref2 = this.children;

            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];

              if (child.textContent) {
                str += child.textContent;
              }
            }

            return str;
          } else {
            return null;
          }
        },
        set: function set(value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });

      XMLNode.prototype.setParent = function (parent) {
        var child, j, len, ref2, results;
        this.parent = parent;

        if (parent) {
          this.options = parent.options;
          this.stringify = parent.stringify;
        }

        ref2 = this.children;
        results = [];

        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          results.push(child.setParent(this));
        }

        return results;
      };

      XMLNode.prototype.element = function (name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
        lastChild = null;

        if (attributes === null && text == null) {
          ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
        }

        if (attributes == null) {
          attributes = {};
        }

        attributes = getValue(attributes);

        if (!isObject(attributes)) {
          ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
        }

        if (name != null) {
          name = getValue(name);
        }

        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        } else if (isFunction(name)) {
          lastChild = this.element(name.apply());
        } else if (isObject(name)) {
          for (key in name) {
            if (!hasProp.call(name, key)) continue;
            val = name[key];

            if (isFunction(val)) {
              val = val.apply();
            }

            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
              lastChild = this.dummy();
            } else if (isObject(val) && isEmpty(val)) {
              lastChild = this.element(key);
            } else if (!this.options.keepNullNodes && val == null) {
              lastChild = this.dummy();
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length; k < len1; k++) {
                item = val[k];
                childNode = {};
                childNode[key] = item;
                lastChild = this.element(childNode);
              }
            } else if (isObject(val)) {
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.element(val);
              } else {
                lastChild = this.element(key);
                lastChild.element(val);
              }
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else if (!this.options.keepNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
          } else {
            lastChild = this.node(name, attributes, text);
          }
        }

        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
        }

        return lastChild;
      };

      XMLNode.prototype.insertBefore = function (name, attributes, text) {
        var child, i, newChild, refChild, removed;

        if (name != null ? name.type : void 0) {
          newChild = name;
          refChild = attributes;
          newChild.setParent(this);

          if (refChild) {
            i = children.indexOf(refChild);
            removed = children.splice(i);
            children.push(newChild);
            Array.prototype.push.apply(children, removed);
          } else {
            children.push(newChild);
          }

          return newChild;
        } else {
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }

          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        }
      };

      XMLNode.prototype.insertAfter = function (name, attributes, text) {
        var child, i, removed;

        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }

        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };

      XMLNode.prototype.remove = function () {
        var i, ref2;

        if (this.isRoot) {
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        }

        i = this.parent.children.indexOf(this);
        [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
        return this.parent;
      };

      XMLNode.prototype.node = function (name, attributes, text) {
        var child, ref2;

        if (name != null) {
          name = getValue(name);
        }

        attributes || (attributes = {});
        attributes = getValue(attributes);

        if (!isObject(attributes)) {
          ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
        }

        child = new XMLElement$1(this, name, attributes);

        if (text != null) {
          child.text(text);
        }

        this.children.push(child);
        return child;
      };

      XMLNode.prototype.text = function (value) {
        var child;

        if (isObject(value)) {
          this.element(value);
        }

        child = new XMLText$1(this, value);
        this.children.push(child);
        return this;
      };

      XMLNode.prototype.cdata = function (value) {
        var child;
        child = new XMLCData$1(this, value);
        this.children.push(child);
        return this;
      };

      XMLNode.prototype.comment = function (value) {
        var child;
        child = new XMLComment$1(this, value);
        this.children.push(child);
        return this;
      };

      XMLNode.prototype.commentBefore = function (value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };

      XMLNode.prototype.commentAfter = function (value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };

      XMLNode.prototype.raw = function (value) {
        var child;
        child = new XMLRaw$1(this, value);
        this.children.push(child);
        return this;
      };

      XMLNode.prototype.dummy = function () {
        var child;
        child = new XMLDummy$1(this);
        return child;
      };

      XMLNode.prototype.instruction = function (target, value) {
        var insTarget, insValue, instruction, j, len;

        if (target != null) {
          target = getValue(target);
        }

        if (value != null) {
          value = getValue(value);
        }

        if (Array.isArray(target)) {
          for (j = 0, len = target.length; j < len; j++) {
            insTarget = target[j];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget)) continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }

          instruction = new XMLProcessingInstruction$1(this, target, value);
          this.children.push(instruction);
        }

        return this;
      };

      XMLNode.prototype.instructionBefore = function (target, value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };

      XMLNode.prototype.instructionAfter = function (target, value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };

      XMLNode.prototype.declaration = function (version, encoding, standalone) {
        var doc, xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration$1(doc, version, encoding, standalone);

        if (doc.children.length === 0) {
          doc.children.unshift(xmldec);
        } else if (doc.children[0].type === NodeType$1.Declaration) {
          doc.children[0] = xmldec;
        } else {
          doc.children.unshift(xmldec);
        }

        return doc.root() || doc;
      };

      XMLNode.prototype.dtd = function (pubID, sysID) {
        var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
        doc = this.document();
        doctype = new XMLDocType$1(doc, pubID, sysID);
        ref2 = doc.children;

        for (i = j = 0, len = ref2.length; j < len; i = ++j) {
          child = ref2[i];

          if (child.type === NodeType$1.DocType) {
            doc.children[i] = doctype;
            return doctype;
          }
        }

        ref3 = doc.children;

        for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
          child = ref3[i];

          if (child.isRoot) {
            doc.children.splice(i, 0, doctype);
            return doctype;
          }
        }

        doc.children.push(doctype);
        return doctype;
      };

      XMLNode.prototype.up = function () {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }

        return this.parent;
      };

      XMLNode.prototype.root = function () {
        var node;
        node = this;

        while (node) {
          if (node.type === NodeType$1.Document) {
            return node.rootObject;
          } else if (node.isRoot) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };

      XMLNode.prototype.document = function () {
        var node;
        node = this;

        while (node) {
          if (node.type === NodeType$1.Document) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };

      XMLNode.prototype.end = function (options) {
        return this.document().end(options);
      };

      XMLNode.prototype.prev = function () {
        var i;
        i = this.parent.children.indexOf(this);

        if (i < 1) {
          throw new Error("Already at the first node. " + this.debugInfo());
        }

        return this.parent.children[i - 1];
      };

      XMLNode.prototype.next = function () {
        var i;
        i = this.parent.children.indexOf(this);

        if (i === -1 || i === this.parent.children.length - 1) {
          throw new Error("Already at the last node. " + this.debugInfo());
        }

        return this.parent.children[i + 1];
      };

      XMLNode.prototype.importDocument = function (doc) {
        var clonedRoot;
        clonedRoot = doc.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };

      XMLNode.prototype.debugInfo = function (name) {
        var ref2, ref3;
        name = name || this.name;

        if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
          return "";
        } else if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
          return "node: <" + name + ">";
        } else {
          return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        }
      };

      XMLNode.prototype.ele = function (name, attributes, text) {
        return this.element(name, attributes, text);
      };

      XMLNode.prototype.nod = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };

      XMLNode.prototype.txt = function (value) {
        return this.text(value);
      };

      XMLNode.prototype.dat = function (value) {
        return this.cdata(value);
      };

      XMLNode.prototype.com = function (value) {
        return this.comment(value);
      };

      XMLNode.prototype.ins = function (target, value) {
        return this.instruction(target, value);
      };

      XMLNode.prototype.doc = function () {
        return this.document();
      };

      XMLNode.prototype.dec = function (version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };

      XMLNode.prototype.e = function (name, attributes, text) {
        return this.element(name, attributes, text);
      };

      XMLNode.prototype.n = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };

      XMLNode.prototype.t = function (value) {
        return this.text(value);
      };

      XMLNode.prototype.d = function (value) {
        return this.cdata(value);
      };

      XMLNode.prototype.c = function (value) {
        return this.comment(value);
      };

      XMLNode.prototype.r = function (value) {
        return this.raw(value);
      };

      XMLNode.prototype.i = function (target, value) {
        return this.instruction(target, value);
      };

      XMLNode.prototype.u = function () {
        return this.up();
      };

      XMLNode.prototype.importXMLBuilder = function (doc) {
        return this.importDocument(doc);
      };

      XMLNode.prototype.replaceChild = function (newChild, oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.removeChild = function (oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.appendChild = function (newChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.hasChildNodes = function () {
        return this.children.length !== 0;
      };

      XMLNode.prototype.cloneNode = function (deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.normalize = function () {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.isSupported = function (feature, version) {
        return true;
      };

      XMLNode.prototype.hasAttributes = function () {
        return this.attribs.length !== 0;
      };

      XMLNode.prototype.compareDocumentPosition = function (other) {
        var ref, res;
        ref = this;

        if (ref === other) {
          return 0;
        } else if (this.document() !== other.document()) {
          res = DocumentPosition$1.Disconnected | DocumentPosition$1.ImplementationSpecific;

          if (Math.random() < 0.5) {
            res |= DocumentPosition$1.Preceding;
          } else {
            res |= DocumentPosition$1.Following;
          }

          return res;
        } else if (ref.isAncestor(other)) {
          return DocumentPosition$1.Contains | DocumentPosition$1.Preceding;
        } else if (ref.isDescendant(other)) {
          return DocumentPosition$1.Contains | DocumentPosition$1.Following;
        } else if (ref.isPreceding(other)) {
          return DocumentPosition$1.Preceding;
        } else {
          return DocumentPosition$1.Following;
        }
      };

      XMLNode.prototype.isSameNode = function (other) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.lookupPrefix = function (namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.isDefaultNamespace = function (namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.lookupNamespaceURI = function (prefix) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.isEqualNode = function (node) {
        var i, j, ref2;

        if (node.nodeType !== this.nodeType) {
          return false;
        }

        if (node.children.length !== this.children.length) {
          return false;
        }

        for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
          if (!this.children[i].isEqualNode(node.children[i])) {
            return false;
          }
        }

        return true;
      };

      XMLNode.prototype.getFeature = function (feature, version) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.setUserData = function (key, data, handler) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.getUserData = function (key) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLNode.prototype.contains = function (other) {
        if (!other) {
          return false;
        }

        return other === this || this.isDescendant(other);
      };

      XMLNode.prototype.isDescendant = function (node) {
        var child, isDescendantChild, j, len, ref2;
        ref2 = this.children;

        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];

          if (node === child) {
            return true;
          }

          isDescendantChild = child.isDescendant(node);

          if (isDescendantChild) {
            return true;
          }
        }

        return false;
      };

      XMLNode.prototype.isAncestor = function (node) {
        return node.isDescendant(this);
      };

      XMLNode.prototype.isPreceding = function (node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);

        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos < thisPos;
        }
      };

      XMLNode.prototype.isFollowing = function (node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);

        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos > thisPos;
        }
      };

      XMLNode.prototype.treePosition = function (node) {
        var found, pos;
        pos = 0;
        found = false;
        this.foreachTreeNode(this.document(), function (childNode) {
          pos++;

          if (!found && childNode === node) {
            return found = true;
          }
        });

        if (found) {
          return pos;
        } else {
          return -1;
        }
      };

      XMLNode.prototype.foreachTreeNode = function (node, func) {
        var child, j, len, ref2, res;
        node || (node = this.document());
        ref2 = node.children;

        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];

          if (res = func(child)) {
            return res;
          } else {
            res = this.foreachTreeNode(child, func);

            if (res) {
              return res;
            }
          }
        }
      };

      return XMLNode;
    }();
  }).call(commonjsGlobal);
});

var XMLStringifier = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var bind = function bind(fn, me) {
      return function () {
        return fn.apply(me, arguments);
      };
    },
        hasProp = {}.hasOwnProperty;

    module.exports = function () {
      function XMLStringifier(options) {
        this.assertLegalName = bind(this.assertLegalName, this);
        this.assertLegalChar = bind(this.assertLegalChar, this);
        var key, ref, value;
        options || (options = {});
        this.options = options;

        if (!this.options.version) {
          this.options.version = '1.0';
        }

        ref = options.stringify || {};

        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this[key] = value;
        }
      }

      XMLStringifier.prototype.name = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalName('' + val || '');
      };

      XMLStringifier.prototype.text = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar(this.textEscape('' + val || ''));
      };

      XMLStringifier.prototype.cdata = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        val = '' + val || '';
        val = val.replace(']]>', ']]]]><![CDATA[>');
        return this.assertLegalChar(val);
      };

      XMLStringifier.prototype.comment = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        val = '' + val || '';

        if (val.match(/--/)) {
          throw new Error("Comment text cannot contain double-hypen: " + val);
        }

        return this.assertLegalChar(val);
      };

      XMLStringifier.prototype.raw = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return '' + val || '';
      };

      XMLStringifier.prototype.attValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar(this.attEscape(val = '' + val || ''));
      };

      XMLStringifier.prototype.insTarget = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.insValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        val = '' + val || '';

        if (val.match(/\?>/)) {
          throw new Error("Invalid processing instruction value: " + val);
        }

        return this.assertLegalChar(val);
      };

      XMLStringifier.prototype.xmlVersion = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        val = '' + val || '';

        if (!val.match(/1\.[0-9]+/)) {
          throw new Error("Invalid version number: " + val);
        }

        return val;
      };

      XMLStringifier.prototype.xmlEncoding = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        val = '' + val || '';

        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error("Invalid encoding: " + val);
        }

        return this.assertLegalChar(val);
      };

      XMLStringifier.prototype.xmlStandalone = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        if (val) {
          return "yes";
        } else {
          return "no";
        }
      };

      XMLStringifier.prototype.dtdPubID = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.dtdSysID = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.dtdElementValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.dtdAttType = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.dtdAttDefault = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.dtdEntityValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.dtdNData = function (val) {
        if (this.options.noValidation) {
          return val;
        }

        return this.assertLegalChar('' + val || '');
      };

      XMLStringifier.prototype.convertAttKey = '@';
      XMLStringifier.prototype.convertPIKey = '?';
      XMLStringifier.prototype.convertTextKey = '#text';
      XMLStringifier.prototype.convertCDataKey = '#cdata';
      XMLStringifier.prototype.convertCommentKey = '#comment';
      XMLStringifier.prototype.convertRawKey = '#raw';

      XMLStringifier.prototype.assertLegalChar = function (str) {
        var regex, res;

        if (this.options.noValidation) {
          return str;
        }

        regex = '';

        if (this.options.version === '1.0') {
          regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        } else if (this.options.version === '1.1') {
          regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        }

        return str;
      };

      XMLStringifier.prototype.assertLegalName = function (str) {
        var regex;

        if (this.options.noValidation) {
          return str;
        }

        this.assertLegalChar(str);
        regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;

        if (!str.match(regex)) {
          throw new Error("Invalid character in name");
        }

        return str;
      };

      XMLStringifier.prototype.textEscape = function (str) {
        var ampregex;

        if (this.options.noValidation) {
          return str;
        }

        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
      };

      XMLStringifier.prototype.attEscape = function (str) {
        var ampregex;

        if (this.options.noValidation) {
          return str;
        }

        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
      };

      return XMLStringifier;
    }();
  }).call(commonjsGlobal);
});

var WriterState = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    module.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }).call(commonjsGlobal);
});

var XMLWriterBase = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        WriterState$1,
        assign,
        hasProp = {}.hasOwnProperty;
    assign = Utility.assign;
    NodeType$1 = NodeType;
    WriterState$1 = WriterState;

    module.exports = function () {
      function XMLWriterBase(options) {
        var key, ref, value;
        options || (options = {});
        this.options = options;
        ref = options.writer || {};

        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this["_" + key] = this[key];
          this[key] = value;
        }
      }

      XMLWriterBase.prototype.filterOptions = function (options) {
        var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
        options || (options = {});
        options = assign({}, this.options, options);
        filteredOptions = {
          writer: this
        };
        filteredOptions.pretty = options.pretty || false;
        filteredOptions.allowEmpty = options.allowEmpty || false;
        filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
        filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
        filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
        filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
        filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';

        if (filteredOptions.spaceBeforeSlash === true) {
          filteredOptions.spaceBeforeSlash = ' ';
        }

        filteredOptions.suppressPrettyCount = 0;
        filteredOptions.user = {};
        filteredOptions.state = WriterState$1.None;
        return filteredOptions;
      };

      XMLWriterBase.prototype.indent = function (node, options, level) {
        var indentLevel;

        if (!options.pretty || options.suppressPrettyCount) {
          return '';
        } else if (options.pretty) {
          indentLevel = (level || 0) + options.offset + 1;

          if (indentLevel > 0) {
            return new Array(indentLevel).join(options.indent);
          }
        }

        return '';
      };

      XMLWriterBase.prototype.endline = function (node, options, level) {
        if (!options.pretty || options.suppressPrettyCount) {
          return '';
        } else {
          return options.newline;
        }
      };

      XMLWriterBase.prototype.attribute = function (att, options, level) {
        var r;
        this.openAttribute(att, options, level);
        r = ' ' + att.name + '="' + att.value + '"';
        this.closeAttribute(att, options, level);
        return r;
      };

      XMLWriterBase.prototype.cdata = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<![CDATA[';
        options.state = WriterState$1.InsideTag;
        r += node.value;
        options.state = WriterState$1.CloseTag;
        r += ']]>' + this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.comment = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<!-- ';
        options.state = WriterState$1.InsideTag;
        r += node.value;
        options.state = WriterState$1.CloseTag;
        r += ' -->' + this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.declaration = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<?xml';
        options.state = WriterState$1.InsideTag;
        r += ' version="' + node.version + '"';

        if (node.encoding != null) {
          r += ' encoding="' + node.encoding + '"';
        }

        if (node.standalone != null) {
          r += ' standalone="' + node.standalone + '"';
        }

        options.state = WriterState$1.CloseTag;
        r += options.spaceBeforeSlash + '?>';
        r += this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.docType = function (node, options, level) {
        var child, i, len, r, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level);
        r += '<!DOCTYPE ' + node.root().name;

        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }

        if (node.children.length > 0) {
          r += ' [';
          r += this.endline(node, options, level);
          options.state = WriterState$1.InsideTag;
          ref = node.children;

          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, level + 1);
          }

          options.state = WriterState$1.CloseTag;
          r += ']';
        }

        options.state = WriterState$1.CloseTag;
        r += options.spaceBeforeSlash + '>';
        r += this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.element = function (node, options, level) {
        var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
        level || (level = 0);
        prettySuppressed = false;
        r = '';
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r += this.indent(node, options, level) + '<' + node.name;
        ref = node.attribs;

        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          r += this.attribute(att, options, level);
        }

        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];

        if (childNodeCount === 0 || node.children.every(function (e) {
          return (e.type === NodeType$1.Text || e.type === NodeType$1.Raw) && e.value === '';
        })) {
          if (options.allowEmpty) {
            r += '>';
            options.state = WriterState$1.CloseTag;
            r += '</' + node.name + '>' + this.endline(node, options, level);
          } else {
            options.state = WriterState$1.CloseTag;
            r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType$1.Text || firstChildNode.type === NodeType$1.Raw) && firstChildNode.value != null) {
          r += '>';
          options.state = WriterState$1.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          r += this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState$1.CloseTag;
          r += '</' + node.name + '>' + this.endline(node, options, level);
        } else {
          if (options.dontPrettyTextNodes) {
            ref1 = node.children;

            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];

              if ((child.type === NodeType$1.Text || child.type === NodeType$1.Raw) && child.value != null) {
                options.suppressPrettyCount++;
                prettySuppressed = true;
                break;
              }
            }
          }

          r += '>' + this.endline(node, options, level);
          options.state = WriterState$1.InsideTag;
          ref2 = node.children;

          for (j = 0, len1 = ref2.length; j < len1; j++) {
            child = ref2[j];
            r += this.writeChildNode(child, options, level + 1);
          }

          options.state = WriterState$1.CloseTag;
          r += this.indent(node, options, level) + '</' + node.name + '>';

          if (prettySuppressed) {
            options.suppressPrettyCount--;
          }

          r += this.endline(node, options, level);
          options.state = WriterState$1.None;
        }

        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.writeChildNode = function (node, options, level) {
        switch (node.type) {
          case NodeType$1.CData:
            return this.cdata(node, options, level);

          case NodeType$1.Comment:
            return this.comment(node, options, level);

          case NodeType$1.Element:
            return this.element(node, options, level);

          case NodeType$1.Raw:
            return this.raw(node, options, level);

          case NodeType$1.Text:
            return this.text(node, options, level);

          case NodeType$1.ProcessingInstruction:
            return this.processingInstruction(node, options, level);

          case NodeType$1.Dummy:
            return '';

          case NodeType$1.Declaration:
            return this.declaration(node, options, level);

          case NodeType$1.DocType:
            return this.docType(node, options, level);

          case NodeType$1.AttributeDeclaration:
            return this.dtdAttList(node, options, level);

          case NodeType$1.ElementDeclaration:
            return this.dtdElement(node, options, level);

          case NodeType$1.EntityDeclaration:
            return this.dtdEntity(node, options, level);

          case NodeType$1.NotationDeclaration:
            return this.dtdNotation(node, options, level);

          default:
            throw new Error("Unknown XML node type: " + node.constructor.name);
        }
      };

      XMLWriterBase.prototype.processingInstruction = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<?';
        options.state = WriterState$1.InsideTag;
        r += node.target;

        if (node.value) {
          r += ' ' + node.value;
        }

        options.state = WriterState$1.CloseTag;
        r += options.spaceBeforeSlash + '?>';
        r += this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.raw = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState$1.InsideTag;
        r += node.value;
        options.state = WriterState$1.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.text = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState$1.InsideTag;
        r += node.value;
        options.state = WriterState$1.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.dtdAttList = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<!ATTLIST';
        options.state = WriterState$1.InsideTag;
        r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;

        if (node.defaultValueType !== '#DEFAULT') {
          r += ' ' + node.defaultValueType;
        }

        if (node.defaultValue) {
          r += ' "' + node.defaultValue + '"';
        }

        options.state = WriterState$1.CloseTag;
        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.dtdElement = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<!ELEMENT';
        options.state = WriterState$1.InsideTag;
        r += ' ' + node.name + ' ' + node.value;
        options.state = WriterState$1.CloseTag;
        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.dtdEntity = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<!ENTITY';
        options.state = WriterState$1.InsideTag;

        if (node.pe) {
          r += ' %';
        }

        r += ' ' + node.name;

        if (node.value) {
          r += ' "' + node.value + '"';
        } else {
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }

          if (node.nData) {
            r += ' NDATA ' + node.nData;
          }
        }

        options.state = WriterState$1.CloseTag;
        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.dtdNotation = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        r = this.indent(node, options, level) + '<!NOTATION';
        options.state = WriterState$1.InsideTag;
        r += ' ' + node.name;

        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.pubID) {
          r += ' PUBLIC "' + node.pubID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }

        options.state = WriterState$1.CloseTag;
        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState$1.None;
        this.closeNode(node, options, level);
        return r;
      };

      XMLWriterBase.prototype.openNode = function (node, options, level) {};

      XMLWriterBase.prototype.closeNode = function (node, options, level) {};

      XMLWriterBase.prototype.openAttribute = function (att, options, level) {};

      XMLWriterBase.prototype.closeAttribute = function (att, options, level) {};

      return XMLWriterBase;
    }();
  }).call(commonjsGlobal);
});

var XMLStringWriter = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var XMLWriterBase$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    XMLWriterBase$1 = XMLWriterBase;

    module.exports = function (superClass) {
      extend(XMLStringWriter, superClass);

      function XMLStringWriter(options) {
        XMLStringWriter.__super__.constructor.call(this, options);
      }

      XMLStringWriter.prototype.document = function (doc, options) {
        var child, i, len, r, ref;
        options = this.filterOptions(options);
        r = '';
        ref = doc.children;

        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += this.writeChildNode(child, options, 0);
        }

        if (options.pretty && r.slice(-options.newline.length) === options.newline) {
          r = r.slice(0, -options.newline.length);
        }

        return r;
      };

      return XMLStringWriter;
    }(XMLWriterBase$1);
  }).call(commonjsGlobal);
});

var XMLDocument = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        XMLDOMConfiguration$1,
        XMLDOMImplementation$1,
        XMLNode$1,
        XMLStringWriter$1,
        XMLStringifier$1,
        isPlainObject,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    isPlainObject = Utility.isPlainObject;
    XMLDOMImplementation$1 = XMLDOMImplementation;
    XMLDOMConfiguration$1 = XMLDOMConfiguration;
    XMLNode$1 = XMLNode;
    NodeType$1 = NodeType;
    XMLStringifier$1 = XMLStringifier;
    XMLStringWriter$1 = XMLStringWriter;

    module.exports = function (superClass) {
      extend(XMLDocument, superClass);

      function XMLDocument(options) {
        XMLDocument.__super__.constructor.call(this, null);

        this.name = "#document";
        this.type = NodeType$1.Document;
        this.documentURI = null;
        this.domConfig = new XMLDOMConfiguration$1();
        options || (options = {});

        if (!options.writer) {
          options.writer = new XMLStringWriter$1();
        }

        this.options = options;
        this.stringify = new XMLStringifier$1(options);
      }

      Object.defineProperty(XMLDocument.prototype, 'implementation', {
        value: new XMLDOMImplementation$1()
      });
      Object.defineProperty(XMLDocument.prototype, 'doctype', {
        get: function get() {
          var child, i, len, ref;
          ref = this.children;

          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];

            if (child.type === NodeType$1.DocType) {
              return child;
            }
          }

          return null;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'documentElement', {
        get: function get() {
          return this.rootObject || null;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
        get: function get() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
        get: function get() {
          return false;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
        get: function get() {
          if (this.children.length !== 0 && this.children[0].type === NodeType$1.Declaration) {
            return this.children[0].encoding;
          } else {
            return null;
          }
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
        get: function get() {
          if (this.children.length !== 0 && this.children[0].type === NodeType$1.Declaration) {
            return this.children[0].standalone === 'yes';
          } else {
            return false;
          }
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
        get: function get() {
          if (this.children.length !== 0 && this.children[0].type === NodeType$1.Declaration) {
            return this.children[0].version;
          } else {
            return "1.0";
          }
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'URL', {
        get: function get() {
          return this.documentURI;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'origin', {
        get: function get() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'compatMode', {
        get: function get() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'characterSet', {
        get: function get() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument.prototype, 'contentType', {
        get: function get() {
          return null;
        }
      });

      XMLDocument.prototype.end = function (writer) {
        var writerOptions;
        writerOptions = {};

        if (!writer) {
          writer = this.options.writer;
        } else if (isPlainObject(writer)) {
          writerOptions = writer;
          writer = this.options.writer;
        }

        return writer.document(this, writer.filterOptions(writerOptions));
      };

      XMLDocument.prototype.toString = function (options) {
        return this.options.writer.document(this, this.options.writer.filterOptions(options));
      };

      XMLDocument.prototype.createElement = function (tagName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createDocumentFragment = function () {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createTextNode = function (data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createComment = function (data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createCDATASection = function (data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createProcessingInstruction = function (target, data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createAttribute = function (name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createEntityReference = function (name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.getElementsByTagName = function (tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.importNode = function (importedNode, deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createElementNS = function (namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createAttributeNS = function (namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.getElementById = function (elementId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.adoptNode = function (source) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.normalizeDocument = function () {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.renameNode = function (node, namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.getElementsByClassName = function (classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createEvent = function (eventInterface) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createRange = function () {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createNodeIterator = function (root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      XMLDocument.prototype.createTreeWalker = function (root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };

      return XMLDocument;
    }(XMLNode$1);
  }).call(commonjsGlobal);
});

var XMLDocumentCB = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        WriterState$1,
        XMLAttribute$1,
        XMLCData$1,
        XMLComment$1,
        XMLDTDAttList$1,
        XMLDTDElement$1,
        XMLDTDEntity$1,
        XMLDTDNotation$1,
        XMLDeclaration$1,
        XMLDocType$1,
        XMLDocument$1,
        XMLElement$1,
        XMLProcessingInstruction$1,
        XMLRaw$1,
        XMLStringWriter$1,
        XMLStringifier$1,
        XMLText$1,
        getValue,
        isFunction,
        isObject,
        isPlainObject,
        ref,
        hasProp = {}.hasOwnProperty;
    ref = Utility, isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
    NodeType$1 = NodeType;
    XMLDocument$1 = XMLDocument;
    XMLElement$1 = XMLElement;
    XMLCData$1 = XMLCData;
    XMLComment$1 = XMLComment;
    XMLRaw$1 = XMLRaw;
    XMLText$1 = XMLText;
    XMLProcessingInstruction$1 = XMLProcessingInstruction;
    XMLDeclaration$1 = XMLDeclaration;
    XMLDocType$1 = XMLDocType;
    XMLDTDAttList$1 = XMLDTDAttList;
    XMLDTDEntity$1 = XMLDTDEntity;
    XMLDTDElement$1 = XMLDTDElement;
    XMLDTDNotation$1 = XMLDTDNotation;
    XMLAttribute$1 = XMLAttribute;
    XMLStringifier$1 = XMLStringifier;
    XMLStringWriter$1 = XMLStringWriter;
    WriterState$1 = WriterState;

    module.exports = function () {
      function XMLDocumentCB(options, onData, onEnd) {
        var writerOptions;
        this.name = "?xml";
        this.type = NodeType$1.Document;
        options || (options = {});
        writerOptions = {};

        if (!options.writer) {
          options.writer = new XMLStringWriter$1();
        } else if (isPlainObject(options.writer)) {
          writerOptions = options.writer;
          options.writer = new XMLStringWriter$1();
        }

        this.options = options;
        this.writer = options.writer;
        this.writerOptions = this.writer.filterOptions(writerOptions);
        this.stringify = new XMLStringifier$1(options);

        this.onDataCallback = onData || function () {};

        this.onEndCallback = onEnd || function () {};

        this.currentNode = null;
        this.currentLevel = -1;
        this.openTags = {};
        this.documentStarted = false;
        this.documentCompleted = false;
        this.root = null;
      }

      XMLDocumentCB.prototype.createChildNode = function (node) {
        var att, attName, attributes, child, i, len, ref1, ref2;

        switch (node.type) {
          case NodeType$1.CData:
            this.cdata(node.value);
            break;

          case NodeType$1.Comment:
            this.comment(node.value);
            break;

          case NodeType$1.Element:
            attributes = {};
            ref1 = node.attribs;

            for (attName in ref1) {
              if (!hasProp.call(ref1, attName)) continue;
              att = ref1[attName];
              attributes[attName] = att.value;
            }

            this.node(node.name, attributes);
            break;

          case NodeType$1.Dummy:
            this.dummy();
            break;

          case NodeType$1.Raw:
            this.raw(node.value);
            break;

          case NodeType$1.Text:
            this.text(node.value);
            break;

          case NodeType$1.ProcessingInstruction:
            this.instruction(node.target, node.value);
            break;

          default:
            throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
        }

        ref2 = node.children;

        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          this.createChildNode(child);

          if (child.type === NodeType$1.Element) {
            this.up();
          }
        }

        return this;
      };

      XMLDocumentCB.prototype.dummy = function () {
        return this;
      };

      XMLDocumentCB.prototype.node = function (name, attributes, text) {
        var ref1;

        if (name == null) {
          throw new Error("Missing node name.");
        }

        if (this.root && this.currentLevel === -1) {
          throw new Error("Document can only have one root node. " + this.debugInfo(name));
        }

        this.openCurrent();
        name = getValue(name);

        if (attributes == null) {
          attributes = {};
        }

        attributes = getValue(attributes);

        if (!isObject(attributes)) {
          ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
        }

        this.currentNode = new XMLElement$1(this, name, attributes);
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;

        if (text != null) {
          this.text(text);
        }

        return this;
      };

      XMLDocumentCB.prototype.element = function (name, attributes, text) {
        var child, i, len, oldValidationFlag, ref1, root;

        if (this.currentNode && this.currentNode.type === NodeType$1.DocType) {
          this.dtdElement.apply(this, arguments);
        } else {
          if (Array.isArray(name) || isObject(name) || isFunction(name)) {
            oldValidationFlag = this.options.noValidation;
            this.options.noValidation = true;
            root = new XMLDocument$1(this.options).element('TEMP_ROOT');
            root.element(name);
            this.options.noValidation = oldValidationFlag;
            ref1 = root.children;

            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              this.createChildNode(child);

              if (child.type === NodeType$1.Element) {
                this.up();
              }
            }
          } else {
            this.node(name, attributes, text);
          }
        }

        return this;
      };

      XMLDocumentCB.prototype.attribute = function (name, value) {
        var attName, attValue;

        if (!this.currentNode || this.currentNode.children) {
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
        }

        if (name != null) {
          name = getValue(name);
        }

        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }

          if (this.options.keepNullAttributes && value == null) {
            this.currentNode.attribs[name] = new XMLAttribute$1(this, name, "");
          } else if (value != null) {
            this.currentNode.attribs[name] = new XMLAttribute$1(this, name, value);
          }
        }

        return this;
      };

      XMLDocumentCB.prototype.text = function (value) {
        var node;
        this.openCurrent();
        node = new XMLText$1(this, value);
        this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.cdata = function (value) {
        var node;
        this.openCurrent();
        node = new XMLCData$1(this, value);
        this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.comment = function (value) {
        var node;
        this.openCurrent();
        node = new XMLComment$1(this, value);
        this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.raw = function (value) {
        var node;
        this.openCurrent();
        node = new XMLRaw$1(this, value);
        this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.instruction = function (target, value) {
        var i, insTarget, insValue, len, node;
        this.openCurrent();

        if (target != null) {
          target = getValue(target);
        }

        if (value != null) {
          value = getValue(value);
        }

        if (Array.isArray(target)) {
          for (i = 0, len = target.length; i < len; i++) {
            insTarget = target[i];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget)) continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }

          node = new XMLProcessingInstruction$1(this, target, value);
          this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        }

        return this;
      };

      XMLDocumentCB.prototype.declaration = function (version, encoding, standalone) {
        var node;
        this.openCurrent();

        if (this.documentStarted) {
          throw new Error("declaration() must be the first node.");
        }

        node = new XMLDeclaration$1(this, version, encoding, standalone);
        this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.doctype = function (root, pubID, sysID) {
        this.openCurrent();

        if (root == null) {
          throw new Error("Missing root node name.");
        }

        if (this.root) {
          throw new Error("dtd() must come before the root node.");
        }

        this.currentNode = new XMLDocType$1(this, pubID, sysID);
        this.currentNode.rootNodeName = root;
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        return this;
      };

      XMLDocumentCB.prototype.dtdElement = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDElement$1(this, name, value);
        this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var node;
        this.openCurrent();
        node = new XMLDTDAttList$1(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.entity = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity$1(this, false, name, value);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.pEntity = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity$1(this, true, name, value);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.notation = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDNotation$1(this, name, value);
        this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };

      XMLDocumentCB.prototype.up = function () {
        if (this.currentLevel < 0) {
          throw new Error("The document node has no parent.");
        }

        if (this.currentNode) {
          if (this.currentNode.children) {
            this.closeNode(this.currentNode);
          } else {
            this.openNode(this.currentNode);
          }

          this.currentNode = null;
        } else {
          this.closeNode(this.openTags[this.currentLevel]);
        }

        delete this.openTags[this.currentLevel];
        this.currentLevel--;
        return this;
      };

      XMLDocumentCB.prototype.end = function () {
        while (this.currentLevel >= 0) {
          this.up();
        }

        return this.onEnd();
      };

      XMLDocumentCB.prototype.openCurrent = function () {
        if (this.currentNode) {
          this.currentNode.children = true;
          return this.openNode(this.currentNode);
        }
      };

      XMLDocumentCB.prototype.openNode = function (node) {
        var att, chunk, name, ref1;

        if (!node.isOpen) {
          if (!this.root && this.currentLevel === 0 && node.type === NodeType$1.Element) {
            this.root = node;
          }

          chunk = '';

          if (node.type === NodeType$1.Element) {
            this.writerOptions.state = WriterState$1.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
            ref1 = node.attribs;

            for (name in ref1) {
              if (!hasProp.call(ref1, name)) continue;
              att = ref1[name];
              chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
            }

            chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
            this.writerOptions.state = WriterState$1.InsideTag;
          } else {
            this.writerOptions.state = WriterState$1.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;

            if (node.pubID && node.sysID) {
              chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              chunk += ' SYSTEM "' + node.sysID + '"';
            }

            if (node.children) {
              chunk += ' [';
              this.writerOptions.state = WriterState$1.InsideTag;
            } else {
              this.writerOptions.state = WriterState$1.CloseTag;
              chunk += '>';
            }

            chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
          }

          this.onData(chunk, this.currentLevel);
          return node.isOpen = true;
        }
      };

      XMLDocumentCB.prototype.closeNode = function (node) {
        var chunk;

        if (!node.isClosed) {
          chunk = '';
          this.writerOptions.state = WriterState$1.CloseTag;

          if (node.type === NodeType$1.Element) {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
          } else {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
          }

          this.writerOptions.state = WriterState$1.None;
          this.onData(chunk, this.currentLevel);
          return node.isClosed = true;
        }
      };

      XMLDocumentCB.prototype.onData = function (chunk, level) {
        this.documentStarted = true;
        return this.onDataCallback(chunk, level + 1);
      };

      XMLDocumentCB.prototype.onEnd = function () {
        this.documentCompleted = true;
        return this.onEndCallback();
      };

      XMLDocumentCB.prototype.debugInfo = function (name) {
        if (name == null) {
          return "";
        } else {
          return "node: <" + name + ">";
        }
      };

      XMLDocumentCB.prototype.ele = function () {
        return this.element.apply(this, arguments);
      };

      XMLDocumentCB.prototype.nod = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };

      XMLDocumentCB.prototype.txt = function (value) {
        return this.text(value);
      };

      XMLDocumentCB.prototype.dat = function (value) {
        return this.cdata(value);
      };

      XMLDocumentCB.prototype.com = function (value) {
        return this.comment(value);
      };

      XMLDocumentCB.prototype.ins = function (target, value) {
        return this.instruction(target, value);
      };

      XMLDocumentCB.prototype.dec = function (version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };

      XMLDocumentCB.prototype.dtd = function (root, pubID, sysID) {
        return this.doctype(root, pubID, sysID);
      };

      XMLDocumentCB.prototype.e = function (name, attributes, text) {
        return this.element(name, attributes, text);
      };

      XMLDocumentCB.prototype.n = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };

      XMLDocumentCB.prototype.t = function (value) {
        return this.text(value);
      };

      XMLDocumentCB.prototype.d = function (value) {
        return this.cdata(value);
      };

      XMLDocumentCB.prototype.c = function (value) {
        return this.comment(value);
      };

      XMLDocumentCB.prototype.r = function (value) {
        return this.raw(value);
      };

      XMLDocumentCB.prototype.i = function (target, value) {
        return this.instruction(target, value);
      };

      XMLDocumentCB.prototype.att = function () {
        if (this.currentNode && this.currentNode.type === NodeType$1.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };

      XMLDocumentCB.prototype.a = function () {
        if (this.currentNode && this.currentNode.type === NodeType$1.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };

      XMLDocumentCB.prototype.ent = function (name, value) {
        return this.entity(name, value);
      };

      XMLDocumentCB.prototype.pent = function (name, value) {
        return this.pEntity(name, value);
      };

      XMLDocumentCB.prototype.not = function (name, value) {
        return this.notation(name, value);
      };

      return XMLDocumentCB;
    }();
  }).call(commonjsGlobal);
});

var XMLStreamWriter = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1,
        WriterState$1,
        XMLWriterBase$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    NodeType$1 = NodeType;
    XMLWriterBase$1 = XMLWriterBase;
    WriterState$1 = WriterState;

    module.exports = function (superClass) {
      extend(XMLStreamWriter, superClass);

      function XMLStreamWriter(stream, options) {
        this.stream = stream;

        XMLStreamWriter.__super__.constructor.call(this, options);
      }

      XMLStreamWriter.prototype.endline = function (node, options, level) {
        if (node.isLastRootNode && options.state === WriterState$1.CloseTag) {
          return '';
        } else {
          return XMLStreamWriter.__super__.endline.call(this, node, options, level);
        }
      };

      XMLStreamWriter.prototype.document = function (doc, options) {
        var child, i, j, k, len, len1, ref, ref1, results;
        ref = doc.children;

        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          child = ref[i];
          child.isLastRootNode = i === doc.children.length - 1;
        }

        options = this.filterOptions(options);
        ref1 = doc.children;
        results = [];

        for (k = 0, len1 = ref1.length; k < len1; k++) {
          child = ref1[k];
          results.push(this.writeChildNode(child, options, 0));
        }

        return results;
      };

      XMLStreamWriter.prototype.attribute = function (att, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
      };

      XMLStreamWriter.prototype.cdata = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.comment = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.declaration = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.docType = function (node, options, level) {
        var child, j, len, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        this.stream.write(this.indent(node, options, level));
        this.stream.write('<!DOCTYPE ' + node.root().name);

        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }

        if (node.children.length > 0) {
          this.stream.write(' [');
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState$1.InsideTag;
          ref = node.children;

          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            this.writeChildNode(child, options, level + 1);
          }

          options.state = WriterState$1.CloseTag;
          this.stream.write(']');
        }

        options.state = WriterState$1.CloseTag;
        this.stream.write(options.spaceBeforeSlash + '>');
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState$1.None;
        return this.closeNode(node, options, level);
      };

      XMLStreamWriter.prototype.element = function (node, options, level) {
        var att, child, childNodeCount, firstChildNode, j, len, name, ref, ref1;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState$1.OpenTag;
        this.stream.write(this.indent(node, options, level) + '<' + node.name);
        ref = node.attribs;

        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          this.attribute(att, options, level);
        }

        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];

        if (childNodeCount === 0 || node.children.every(function (e) {
          return (e.type === NodeType$1.Text || e.type === NodeType$1.Raw) && e.value === '';
        })) {
          if (options.allowEmpty) {
            this.stream.write('>');
            options.state = WriterState$1.CloseTag;
            this.stream.write('</' + node.name + '>');
          } else {
            options.state = WriterState$1.CloseTag;
            this.stream.write(options.spaceBeforeSlash + '/>');
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType$1.Text || firstChildNode.type === NodeType$1.Raw) && firstChildNode.value != null) {
          this.stream.write('>');
          options.state = WriterState$1.InsideTag;
          options.suppressPrettyCount++;
          this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          options.state = WriterState$1.CloseTag;
          this.stream.write('</' + node.name + '>');
        } else {
          this.stream.write('>' + this.endline(node, options, level));
          options.state = WriterState$1.InsideTag;
          ref1 = node.children;

          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            this.writeChildNode(child, options, level + 1);
          }

          options.state = WriterState$1.CloseTag;
          this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
        }

        this.stream.write(this.endline(node, options, level));
        options.state = WriterState$1.None;
        return this.closeNode(node, options, level);
      };

      XMLStreamWriter.prototype.processingInstruction = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.raw = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.text = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.dtdAttList = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.dtdElement = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.dtdEntity = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
      };

      XMLStreamWriter.prototype.dtdNotation = function (node, options, level) {
        return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
      };

      return XMLStreamWriter;
    }(XMLWriterBase$1);
  }).call(commonjsGlobal);
});

var lib = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.7
  (function () {
    var NodeType$1, WriterState$1, XMLDOMImplementation$1, XMLDocument$1, XMLDocumentCB$1, XMLStreamWriter$1, XMLStringWriter$1, assign, isFunction, ref;
    ref = Utility, assign = ref.assign, isFunction = ref.isFunction;
    XMLDOMImplementation$1 = XMLDOMImplementation;
    XMLDocument$1 = XMLDocument;
    XMLDocumentCB$1 = XMLDocumentCB;
    XMLStringWriter$1 = XMLStringWriter;
    XMLStreamWriter$1 = XMLStreamWriter;
    NodeType$1 = NodeType;
    WriterState$1 = WriterState;

    module.exports.create = function (name, xmldec, doctype, options) {
      var doc, root;

      if (name == null) {
        throw new Error("Root element needs a name.");
      }

      options = assign({}, xmldec, doctype, options);
      doc = new XMLDocument$1(options);
      root = doc.element(name);

      if (!options.headless) {
        doc.declaration(options);

        if (options.pubID != null || options.sysID != null) {
          doc.dtd(options);
        }
      }

      return root;
    };

    module.exports.begin = function (options, onData, onEnd) {
      var ref1;

      if (isFunction(options)) {
        ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
        options = {};
      }

      if (onData) {
        return new XMLDocumentCB$1(options, onData, onEnd);
      } else {
        return new XMLDocument$1(options);
      }
    };

    module.exports.stringWriter = function (options) {
      return new XMLStringWriter$1(options);
    };

    module.exports.streamWriter = function (stream, options) {
      return new XMLStreamWriter$1(stream, options);
    };

    module.exports.implementation = new XMLDOMImplementation$1();
    module.exports.nodeType = NodeType$1;
    module.exports.writerState = WriterState$1;
  }).call(commonjsGlobal);
});

var builder = createCommonjsModule(function (module, exports) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    var builder,
        defaults$1,
        escapeCDATA,
        requiresCDATA,
        wrapCDATA,
        hasProp = {}.hasOwnProperty;
    builder = lib;
    defaults$1 = defaults.defaults;

    requiresCDATA = function requiresCDATA(entry) {
      return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
    };

    wrapCDATA = function wrapCDATA(entry) {
      return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };

    escapeCDATA = function escapeCDATA(entry) {
      return entry.replace(']]>', ']]]]><![CDATA[>');
    };

    exports.Builder = function () {
      function Builder(opts) {
        var key, ref, value;
        this.options = {};
        ref = defaults$1["0.2"];

        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this.options[key] = value;
        }

        for (key in opts) {
          if (!hasProp.call(opts, key)) continue;
          value = opts[key];
          this.options[key] = value;
        }
      }

      Builder.prototype.buildObject = function (rootObj) {
        var attrkey, charkey, render, rootElement, rootName;
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;

        if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults$1['0.2'].rootName) {
          rootName = Object.keys(rootObj)[0];
          rootObj = rootObj[rootName];
        } else {
          rootName = this.options.rootName;
        }

        render = function (_this) {
          return function (element, obj) {
            var attr, child, entry, index, key, value;

            if (_typeof(obj) !== 'object') {
              if (_this.options.cdata && requiresCDATA(obj)) {
                element.raw(wrapCDATA(obj));
              } else {
                element.txt(obj);
              }
            } else if (Array.isArray(obj)) {
              for (index in obj) {
                if (!hasProp.call(obj, index)) continue;
                child = obj[index];

                for (key in child) {
                  entry = child[key];
                  element = render(element.ele(key), entry).up();
                }
              }
            } else {
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                child = obj[key];

                if (key === attrkey) {
                  if (_typeof(child) === "object") {
                    for (attr in child) {
                      value = child[attr];
                      element = element.att(attr, value);
                    }
                  }
                } else if (key === charkey) {
                  if (_this.options.cdata && requiresCDATA(child)) {
                    element = element.raw(wrapCDATA(child));
                  } else {
                    element = element.txt(child);
                  }
                } else if (Array.isArray(child)) {
                  for (index in child) {
                    if (!hasProp.call(child, index)) continue;
                    entry = child[index];

                    if (typeof entry === 'string') {
                      if (_this.options.cdata && requiresCDATA(entry)) {
                        element = element.ele(key).raw(wrapCDATA(entry)).up();
                      } else {
                        element = element.ele(key, entry).up();
                      }
                    } else {
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else if (_typeof(child) === "object") {
                  element = render(element.ele(key), child).up();
                } else {
                  if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                    element = element.ele(key).raw(wrapCDATA(child)).up();
                  } else {
                    if (child == null) {
                      child = '';
                    }

                    element = element.ele(key, child.toString()).up();
                  }
                }
              }
            }

            return element;
          };
        }(this);

        rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        });
        return render(rootElement, rootObj).end(this.options.renderOpts);
      };

      return Builder;
    }();
  }).call(commonjsGlobal);
});

var sax = createCommonjsModule(function (module, exports) {

  (function (sax) {
    // wrapper for non-node envs
    sax.parser = function (strict, opt) {
      return new SAXParser(strict, opt);
    };

    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream; // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.

    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];
    sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];

    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }

      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = '';
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
      parser.attribList = []; // namespaces form a prototype chain.
      // it always points at the current tag,
      // which protos to its parent tag.

      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      } // mostly just for error reporting


      parser.trackPosition = parser.opt.position !== false;

      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }

      emit(parser, 'onready');
    }

    if (!Object.create) {
      Object.create = function (o) {
        function F() {}

        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }

    if (!Object.keys) {
      Object.keys = function (o) {
        var a = [];

        for (var i in o) {
          if (o.hasOwnProperty(i)) a.push(i);
        }

        return a;
      };
    }

    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;

      for (var i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;

        if (len > maxAllowed) {
          // Text/cdata nodes can get big, and since they're buffered,
          // we can get here under normal conditions.
          // Avoid issues by emitting the text node now,
          // so at least it won't get any bigger.
          switch (buffers[i]) {
            case 'textNode':
              closeText(parser);
              break;

            case 'cdata':
              emitNode(parser, 'oncdata', parser.cdata);
              parser.cdata = '';
              break;

            case 'script':
              emitNode(parser, 'onscript', parser.script);
              parser.script = '';
              break;

            default:
              error(parser, 'Max buffer length exceeded: ' + buffers[i]);
          }
        }

        maxActual = Math.max(maxActual, len);
      } // schedule the next check for the earliest possible buffer overrun.


      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }

    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++) {
        parser[buffers[i]] = '';
      }
    }

    function flushBuffers(parser) {
      closeText(parser);

      if (parser.cdata !== '') {
        emitNode(parser, 'oncdata', parser.cdata);
        parser.cdata = '';
      }

      if (parser.script !== '') {
        emitNode(parser, 'onscript', parser.script);
        parser.script = '';
      }
    }

    SAXParser.prototype = {
      end: function end() {
        _end(this);
      },
      write: write,
      resume: function resume() {
        this.error = null;
        return this;
      },
      close: function close() {
        return this.write(null);
      },
      flush: function flush() {
        flushBuffers(this);
      }
    };
    var Stream;

    try {
      Stream = require$$0$4.Stream;
    } catch (ex) {
      Stream = function Stream() {};
    }

    var streamWraps = sax.EVENTS.filter(function (ev) {
      return ev !== 'error' && ev !== 'end';
    });

    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }

    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }

      Stream.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;

      this._parser.onend = function () {
        me.emit('end');
      };

      this._parser.onerror = function (er) {
        me.emit('error', er); // if didn't throw, then means error was handled.
        // go ahead and clear error, so we can write again.

        me._parser.error = null;
      };

      this._decoder = null;
      streamWraps.forEach(function (ev) {
        Object.defineProperty(me, 'on' + ev, {
          get: function get() {
            return me._parser['on' + ev];
          },
          set: function set(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser['on' + ev] = h;
              return h;
            }

            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }

    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream
      }
    });

    SAXStream.prototype.write = function (data) {
      if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1$3.StringDecoder;
          this._decoder = new SD('utf8');
        }

        data = this._decoder.write(data);
      }

      this._parser.write(data.toString());

      this.emit('data', data);
      return true;
    };

    SAXStream.prototype.end = function (chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }

      this._parser.end();

      return true;
    };

    SAXStream.prototype.on = function (ev, handler) {
      var me = this;

      if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser['on' + ev] = function () {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }

      return Stream.prototype.on.call(me, ev, handler);
    }; // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.


    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = {
      xml: XML_NAMESPACE,
      xmlns: XMLNS_NAMESPACE
    }; // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.

    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

    function isWhitespace(c) {
      return c === ' ' || c === '\n' || c === '\r' || c === '\t';
    }

    function isQuote(c) {
      return c === '"' || c === '\'';
    }

    function isAttribEnd(c) {
      return c === '>' || isWhitespace(c);
    }

    function isMatch(regex, c) {
      return regex.test(c);
    }

    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }

    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S++,
      // leading whitespace
      TEXT: S++,
      // general stuff
      TEXT_ENTITY: S++,
      // &amp and such.
      OPEN_WAKA: S++,
      // <
      SGML_DECL: S++,
      // <!BLARG
      SGML_DECL_QUOTED: S++,
      // <!BLARG foo "bar
      DOCTYPE: S++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S++,
      // <!-
      COMMENT: S++,
      // <!--
      COMMENT_ENDING: S++,
      // <!-- blah -
      COMMENT_ENDED: S++,
      // <!-- blah --
      CDATA: S++,
      // <![CDATA[ something
      CDATA_ENDING: S++,
      // ]
      CDATA_ENDING_2: S++,
      // ]]
      PROC_INST: S++,
      // <?hi
      PROC_INST_BODY: S++,
      // <?hi there
      PROC_INST_ENDING: S++,
      // <?hi "there" ?
      OPEN_TAG: S++,
      // <strong
      OPEN_TAG_SLASH: S++,
      // <strong /
      ATTRIB: S++,
      // <a
      ATTRIB_NAME: S++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S++,
      // <a foo _
      ATTRIB_VALUE: S++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S++,
      // <foo bar=&quot
      CLOSE_TAG: S++,
      // </a
      CLOSE_TAG_SAW_WHITE: S++,
      // </a   >
      SCRIPT: S++,
      // <script> ...
      SCRIPT_ENDING: S++ // <script> ... <

    };
    sax.XML_ENTITIES = {
      'amp': '&',
      'gt': '>',
      'lt': '<',
      'quot': '"',
      'apos': "'"
    };
    sax.ENTITIES = {
      'amp': '&',
      'gt': '>',
      'lt': '<',
      'quot': '"',
      'apos': "'",
      'AElig': 198,
      'Aacute': 193,
      'Acirc': 194,
      'Agrave': 192,
      'Aring': 197,
      'Atilde': 195,
      'Auml': 196,
      'Ccedil': 199,
      'ETH': 208,
      'Eacute': 201,
      'Ecirc': 202,
      'Egrave': 200,
      'Euml': 203,
      'Iacute': 205,
      'Icirc': 206,
      'Igrave': 204,
      'Iuml': 207,
      'Ntilde': 209,
      'Oacute': 211,
      'Ocirc': 212,
      'Ograve': 210,
      'Oslash': 216,
      'Otilde': 213,
      'Ouml': 214,
      'THORN': 222,
      'Uacute': 218,
      'Ucirc': 219,
      'Ugrave': 217,
      'Uuml': 220,
      'Yacute': 221,
      'aacute': 225,
      'acirc': 226,
      'aelig': 230,
      'agrave': 224,
      'aring': 229,
      'atilde': 227,
      'auml': 228,
      'ccedil': 231,
      'eacute': 233,
      'ecirc': 234,
      'egrave': 232,
      'eth': 240,
      'euml': 235,
      'iacute': 237,
      'icirc': 238,
      'igrave': 236,
      'iuml': 239,
      'ntilde': 241,
      'oacute': 243,
      'ocirc': 244,
      'ograve': 242,
      'oslash': 248,
      'otilde': 245,
      'ouml': 246,
      'szlig': 223,
      'thorn': 254,
      'uacute': 250,
      'ucirc': 251,
      'ugrave': 249,
      'uuml': 252,
      'yacute': 253,
      'yuml': 255,
      'copy': 169,
      'reg': 174,
      'nbsp': 160,
      'iexcl': 161,
      'cent': 162,
      'pound': 163,
      'curren': 164,
      'yen': 165,
      'brvbar': 166,
      'sect': 167,
      'uml': 168,
      'ordf': 170,
      'laquo': 171,
      'not': 172,
      'shy': 173,
      'macr': 175,
      'deg': 176,
      'plusmn': 177,
      'sup1': 185,
      'sup2': 178,
      'sup3': 179,
      'acute': 180,
      'micro': 181,
      'para': 182,
      'middot': 183,
      'cedil': 184,
      'ordm': 186,
      'raquo': 187,
      'frac14': 188,
      'frac12': 189,
      'frac34': 190,
      'iquest': 191,
      'times': 215,
      'divide': 247,
      'OElig': 338,
      'oelig': 339,
      'Scaron': 352,
      'scaron': 353,
      'Yuml': 376,
      'fnof': 402,
      'circ': 710,
      'tilde': 732,
      'Alpha': 913,
      'Beta': 914,
      'Gamma': 915,
      'Delta': 916,
      'Epsilon': 917,
      'Zeta': 918,
      'Eta': 919,
      'Theta': 920,
      'Iota': 921,
      'Kappa': 922,
      'Lambda': 923,
      'Mu': 924,
      'Nu': 925,
      'Xi': 926,
      'Omicron': 927,
      'Pi': 928,
      'Rho': 929,
      'Sigma': 931,
      'Tau': 932,
      'Upsilon': 933,
      'Phi': 934,
      'Chi': 935,
      'Psi': 936,
      'Omega': 937,
      'alpha': 945,
      'beta': 946,
      'gamma': 947,
      'delta': 948,
      'epsilon': 949,
      'zeta': 950,
      'eta': 951,
      'theta': 952,
      'iota': 953,
      'kappa': 954,
      'lambda': 955,
      'mu': 956,
      'nu': 957,
      'xi': 958,
      'omicron': 959,
      'pi': 960,
      'rho': 961,
      'sigmaf': 962,
      'sigma': 963,
      'tau': 964,
      'upsilon': 965,
      'phi': 966,
      'chi': 967,
      'psi': 968,
      'omega': 969,
      'thetasym': 977,
      'upsih': 978,
      'piv': 982,
      'ensp': 8194,
      'emsp': 8195,
      'thinsp': 8201,
      'zwnj': 8204,
      'zwj': 8205,
      'lrm': 8206,
      'rlm': 8207,
      'ndash': 8211,
      'mdash': 8212,
      'lsquo': 8216,
      'rsquo': 8217,
      'sbquo': 8218,
      'ldquo': 8220,
      'rdquo': 8221,
      'bdquo': 8222,
      'dagger': 8224,
      'Dagger': 8225,
      'bull': 8226,
      'hellip': 8230,
      'permil': 8240,
      'prime': 8242,
      'Prime': 8243,
      'lsaquo': 8249,
      'rsaquo': 8250,
      'oline': 8254,
      'frasl': 8260,
      'euro': 8364,
      'image': 8465,
      'weierp': 8472,
      'real': 8476,
      'trade': 8482,
      'alefsym': 8501,
      'larr': 8592,
      'uarr': 8593,
      'rarr': 8594,
      'darr': 8595,
      'harr': 8596,
      'crarr': 8629,
      'lArr': 8656,
      'uArr': 8657,
      'rArr': 8658,
      'dArr': 8659,
      'hArr': 8660,
      'forall': 8704,
      'part': 8706,
      'exist': 8707,
      'empty': 8709,
      'nabla': 8711,
      'isin': 8712,
      'notin': 8713,
      'ni': 8715,
      'prod': 8719,
      'sum': 8721,
      'minus': 8722,
      'lowast': 8727,
      'radic': 8730,
      'prop': 8733,
      'infin': 8734,
      'ang': 8736,
      'and': 8743,
      'or': 8744,
      'cap': 8745,
      'cup': 8746,
      'int': 8747,
      'there4': 8756,
      'sim': 8764,
      'cong': 8773,
      'asymp': 8776,
      'ne': 8800,
      'equiv': 8801,
      'le': 8804,
      'ge': 8805,
      'sub': 8834,
      'sup': 8835,
      'nsub': 8836,
      'sube': 8838,
      'supe': 8839,
      'oplus': 8853,
      'otimes': 8855,
      'perp': 8869,
      'sdot': 8901,
      'lceil': 8968,
      'rceil': 8969,
      'lfloor': 8970,
      'rfloor': 8971,
      'lang': 9001,
      'rang': 9002,
      'loz': 9674,
      'spades': 9824,
      'clubs': 9827,
      'hearts': 9829,
      'diams': 9830
    };
    Object.keys(sax.ENTITIES).forEach(function (key) {
      var e = sax.ENTITIES[key];
      var s = typeof e === 'number' ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s;
    });

    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    } // shorthand


    S = sax.STATE;

    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }

    function emitNode(parser, nodeType, data) {
      if (parser.textNode) closeText(parser);
      emit(parser, nodeType, data);
    }

    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode) emit(parser, 'ontext', parser.textNode);
      parser.textNode = '';
    }

    function textopts(opt, text) {
      if (opt.trim) text = text.trim();
      if (opt.normalize) text = text.replace(/\s+/g, ' ');
      return text;
    }

    function error(parser, er) {
      closeText(parser);

      if (parser.trackPosition) {
        er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
      }

      er = new Error(er);
      parser.error = er;
      emit(parser, 'onerror', er);
      return parser;
    }

    function _end(parser) {
      if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');

      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, 'Unexpected end');
      }

      closeText(parser);
      parser.c = '';
      parser.closed = true;
      emit(parser, 'onend');
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }

    function strictFail(parser, message) {
      if (_typeof(parser) !== 'object' || !(parser instanceof SAXParser)) {
        throw new Error('bad call to strictFail');
      }

      if (parser.strict) {
        error(parser, message);
      }
    }

    function newTag(parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = {
        name: parser.tagName,
        attributes: {}
      }; // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"

      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }

      parser.attribList.length = 0;
      emitNode(parser, 'onopentagstart', tag);
    }

    function qname(name, attribute) {
      var i = name.indexOf(':');
      var qualName = i < 0 ? ['', name] : name.split(':');
      var prefix = qualName[0];
      var local = qualName[1]; // <x "xmlns"="http://foo">

      if (attribute && name === 'xmlns') {
        prefix = 'xmlns';
        local = '';
      }

      return {
        prefix: prefix,
        local: local
      };
    }

    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }

      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = '';
        return;
      }

      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;

        if (prefix === 'xmlns') {
          // namespace binding attribute. push the binding into scope
          if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
          } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;

            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }

            tag.ns[local] = parser.attribValue;
          }
        } // defer onattribute events until all attributes have been seen
        // so any new bindings can take effect. preserve attribute order
        // so deferred events can be emitted in document order


        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        // in non-xmlns mode, we can emit the event right away
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, 'onattribute', {
          name: parser.attribName,
          value: parser.attribValue
        });
      }

      parser.attribName = parser.attribValue = '';
    }

    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        // emit namespace binding events
        var tag = parser.tag; // add namespace info to tag

        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || '';

        if (tag.prefix && !tag.uri) {
          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }

        var parent = parser.tags[parser.tags.length - 1] || parser;

        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function (p) {
            emitNode(parser, 'onopennamespace', {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        } // handle deferred onattribute events
        // Note: do not apply default ns to attributes:
        //   http://www.w3.org/TR/REC-xml-names/#defaulting


        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === '' ? '' : tag.ns[prefix] || '';
          var a = {
            name: name,
            value: value,
            prefix: prefix,
            local: local,
            uri: uri
          }; // if there's any attributes with an undefined namespace,
          // then fail on them now.

          if (prefix && prefix !== 'xmlns' && !uri) {
            strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
            a.uri = prefix;
          }

          parser.tag.attributes[name] = a;
          emitNode(parser, 'onattribute', a);
        }

        parser.attribList.length = 0;
      }

      parser.tag.isSelfClosing = !!selfClosing; // process the tag

      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, 'onopentag', parser.tag);

      if (!selfClosing) {
        // special case for <script> in non-strict mode.
        if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }

        parser.tag = null;
        parser.tagName = '';
      }

      parser.attribName = parser.attribValue = '';
      parser.attribList.length = 0;
    }

    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, 'Weird empty close tag.');
        parser.textNode += '</>';
        parser.state = S.TEXT;
        return;
      }

      if (parser.script) {
        if (parser.tagName !== 'script') {
          parser.script += '</' + parser.tagName + '>';
          parser.tagName = '';
          parser.state = S.SCRIPT;
          return;
        }

        emitNode(parser, 'onscript', parser.script);
        parser.script = '';
      } // first make sure that the closing tag actually exists.
      // <a><b></c></b></a> will close everything, otherwise.


      var t = parser.tags.length;
      var tagName = parser.tagName;

      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }

      var closeTo = tagName;

      while (t--) {
        var close = parser.tags[t];

        if (close.name !== closeTo) {
          // fail the first time in strict mode
          strictFail(parser, 'Unexpected close tag');
        } else {
          break;
        }
      } // didn't find it.  we already failed for strict, so just abort.


      if (t < 0) {
        strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
        parser.textNode += '</' + parser.tagName + '>';
        parser.state = S.TEXT;
        return;
      }

      parser.tagName = tagName;
      var s = parser.tags.length;

      while (s-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, 'onclosetag', parser.tagName);
        var x = {};

        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }

        var parent = parser.tags[parser.tags.length - 1] || parser;

        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          // remove namespace bindings introduced by tag
          Object.keys(tag.ns).forEach(function (p) {
            var n = tag.ns[p];
            emitNode(parser, 'onclosenamespace', {
              prefix: p,
              uri: n
            });
          });
        }
      }

      if (t === 0) parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = '';
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }

    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = '';

      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }

      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }

      entity = entityLC;

      if (entity.charAt(0) === '#') {
        if (entity.charAt(1) === 'x') {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }

      entity = entity.replace(/^0+/, '');

      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, 'Invalid character entity');
        return '&' + parser.entity + ';';
      }

      return String.fromCodePoint(num);
    }

    function beginWhiteSpace(parser, c) {
      if (c === '<') {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        // have to process this as a text node.
        // weird, but happens.
        strictFail(parser, 'Non-whitespace before first tag.');
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }

    function charAt(chunk, i) {
      var result = '';

      if (i < chunk.length) {
        result = chunk.charAt(i);
      }

      return result;
    }

    function write(chunk) {
      var parser = this;

      if (this.error) {
        throw this.error;
      }

      if (parser.closed) {
        return error(parser, 'Cannot write after close. Assign an onready handler.');
      }

      if (chunk === null) {
        return _end(parser);
      }

      if (_typeof(chunk) === 'object') {
        chunk = chunk.toString();
      }

      var i = 0;
      var c = '';

      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;

        if (!c) {
          break;
        }

        if (parser.trackPosition) {
          parser.position++;

          if (c === '\n') {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }

        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;

            if (c === "\uFEFF") {
              continue;
            }

            beginWhiteSpace(parser, c);
            continue;

          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;

          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;

              while (c && c !== '<' && c !== '&') {
                c = charAt(chunk, i++);

                if (c && parser.trackPosition) {
                  parser.position++;

                  if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }

              parser.textNode += chunk.substring(starti, i - 1);
            }

            if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, 'Text data outside of root node.');
              }

              if (c === '&') {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }

            continue;

          case S.SCRIPT:
            // only non-strict
            if (c === '<') {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }

            continue;

          case S.SCRIPT_ENDING:
            if (c === '/') {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += '<' + c;
              parser.state = S.SCRIPT;
            }

            continue;

          case S.OPEN_WAKA:
            // either a /, ?, !, or text is coming next.
            if (c === '!') {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = '';
            } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === '/') {
              parser.state = S.CLOSE_TAG;
              parser.tagName = '';
            } else if (c === '?') {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = '';
            } else {
              strictFail(parser, 'Unencoded <'); // if there was some whitespace, then add that in.

              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(' ') + c;
              }

              parser.textNode += '<' + c;
              parser.state = S.TEXT;
            }

            continue;

          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, 'onopencdata');
              parser.state = S.CDATA;
              parser.sgmlDecl = '';
              parser.cdata = '';
            } else if (parser.sgmlDecl + c === '--') {
              parser.state = S.COMMENT;
              parser.comment = '';
              parser.sgmlDecl = '';
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;

              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, 'Inappropriately located doctype declaration');
              }

              parser.doctype = '';
              parser.sgmlDecl = '';
            } else if (c === '>') {
              emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
              parser.sgmlDecl = '';
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }

            continue;

          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = '';
            }

            parser.sgmlDecl += c;
            continue;

          case S.DOCTYPE:
            if (c === '>') {
              parser.state = S.TEXT;
              emitNode(parser, 'ondoctype', parser.doctype);
              parser.doctype = true; // just remember that we saw it.
            } else {
              parser.doctype += c;

              if (c === '[') {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }

            continue;

          case S.DOCTYPE_QUOTED:
            parser.doctype += c;

            if (c === parser.q) {
              parser.q = '';
              parser.state = S.DOCTYPE;
            }

            continue;

          case S.DOCTYPE_DTD:
            parser.doctype += c;

            if (c === ']') {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }

            continue;

          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;

            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = '';
            }

            continue;

          case S.COMMENT:
            if (c === '-') {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }

            continue;

          case S.COMMENT_ENDING:
            if (c === '-') {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);

              if (parser.comment) {
                emitNode(parser, 'oncomment', parser.comment);
              }

              parser.comment = '';
            } else {
              parser.comment += '-' + c;
              parser.state = S.COMMENT;
            }

            continue;

          case S.COMMENT_ENDED:
            if (c !== '>') {
              strictFail(parser, 'Malformed comment'); // allow <!-- blah -- bloo --> in non-strict mode,
              // which is a comment of " blah -- bloo "

              parser.comment += '--' + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }

            continue;

          case S.CDATA:
            if (c === ']') {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }

            continue;

          case S.CDATA_ENDING:
            if (c === ']') {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += ']' + c;
              parser.state = S.CDATA;
            }

            continue;

          case S.CDATA_ENDING_2:
            if (c === '>') {
              if (parser.cdata) {
                emitNode(parser, 'oncdata', parser.cdata);
              }

              emitNode(parser, 'onclosecdata');
              parser.cdata = '';
              parser.state = S.TEXT;
            } else if (c === ']') {
              parser.cdata += ']';
            } else {
              parser.cdata += ']]' + c;
              parser.state = S.CDATA;
            }

            continue;

          case S.PROC_INST:
            if (c === '?') {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }

            continue;

          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === '?') {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }

            continue;

          case S.PROC_INST_ENDING:
            if (c === '>') {
              emitNode(parser, 'onprocessinginstruction', {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = '';
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += '?' + c;
              parser.state = S.PROC_INST_BODY;
            }

            continue;

          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);

              if (c === '>') {
                openTag(parser);
              } else if (c === '/') {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, 'Invalid character in tag name');
                }

                parser.state = S.ATTRIB;
              }
            }

            continue;

          case S.OPEN_TAG_SLASH:
            if (c === '>') {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, 'Forward-slash in opening tag not followed by >');
              parser.state = S.ATTRIB;
            }

            continue;

          case S.ATTRIB:
            // haven't read the attribute name yet.
            if (isWhitespace(c)) {
              continue;
            } else if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = '';
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
            }

            continue;

          case S.ATTRIB_NAME:
            if (c === '=') {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === '>') {
              strictFail(parser, 'Attribute without value');
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, 'Invalid attribute name');
            }

            continue;

          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === '=') {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, 'Attribute without value');
              parser.tag.attributes[parser.attribName] = '';
              parser.attribValue = '';
              emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: ''
              });
              parser.attribName = '';

              if (c === '>') {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, 'Invalid attribute name');
                parser.state = S.ATTRIB;
              }
            }

            continue;

          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, 'Unquoted attribute value');
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }

            continue;

          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === '&') {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }

              continue;
            }

            attrib(parser);
            parser.q = '';
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;

          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, 'No whitespace between attributes');
              parser.attribName = c;
              parser.attribValue = '';
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
            }

            continue;

          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === '&') {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }

              continue;
            }

            attrib(parser);

            if (c === '>') {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }

            continue;

          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += '</' + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, 'Invalid tagname in closing tag.');
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === '>') {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += '</' + parser.tagName;
              parser.tagName = '';
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid tagname in closing tag');
              }

              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }

            continue;

          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }

            if (c === '>') {
              closeTag(parser);
            } else {
              strictFail(parser, 'Invalid characters in closing tag');
            }

            continue;

          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;

            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = 'textNode';
                break;

              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = 'attribValue';
                break;

              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = 'attribValue';
                break;
            }

            if (c === ';') {
              parser[buffer] += parseEntity(parser);
              parser.entity = '';
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, 'Invalid character in entity name');
              parser[buffer] += '&' + parser.entity + c;
              parser.entity = '';
              parser.state = returnState;
            }

            continue;

          default:
            throw new Error(parser, 'Unknown state: ' + parser.state);
        }
      } // while


      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }

      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */

    /* istanbul ignore next */


    if (!String.fromCodePoint) {
      (function () {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;

        var fromCodePoint = function fromCodePoint() {
          var MAX_SIZE = 0x4000;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;

          if (!length) {
            return '';
          }

          var result = '';

          while (++index < length) {
            var codePoint = Number(arguments[index]);

            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
            ) {
                throw RangeError('Invalid code point: ' + codePoint);
              }

            if (codePoint <= 0xFFFF) {
              // BMP code point
              codeUnits.push(codePoint);
            } else {
              // Astral code point; split in surrogate halves
              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              codePoint -= 0x10000;
              highSurrogate = (codePoint >> 10) + 0xD800;
              lowSurrogate = codePoint % 0x400 + 0xDC00;
              codeUnits.push(highSurrogate, lowSurrogate);
            }

            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }

          return result;
        };
        /* istanbul ignore next */


        if (Object.defineProperty) {
          Object.defineProperty(String, 'fromCodePoint', {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
});

var bom = createCommonjsModule(function (module, exports) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    exports.stripBOM = function (str) {
      if (str[0] === "\uFEFF") {
        return str.substring(1);
      } else {
        return str;
      }
    };
  }).call(commonjsGlobal);
});

var processors = createCommonjsModule(function (module, exports) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);

    exports.normalize = function (str) {
      return str.toLowerCase();
    };

    exports.firstCharLowerCase = function (str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    };

    exports.stripPrefix = function (str) {
      return str.replace(prefixMatch, '');
    };

    exports.parseNumbers = function (str) {
      if (!isNaN(str)) {
        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
      }

      return str;
    };

    exports.parseBooleans = function (str) {
      if (/^(?:true|false)$/i.test(str)) {
        str = str.toLowerCase() === 'true';
      }

      return str;
    };
  }).call(commonjsGlobal);
});

var parser = createCommonjsModule(function (module, exports) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    var bom$1,
        defaults$1,
        events,
        isEmpty,
        processItem,
        processors$1,
        sax$1,
        setImmediate,
        bind = function bind(fn, me) {
      return function () {
        return fn.apply(me, arguments);
      };
    },
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    sax$1 = sax;
    events = EventEmitter;
    bom$1 = bom;
    processors$1 = processors;
    setImmediate = require$$4.setImmediate;
    defaults$1 = defaults.defaults;

    isEmpty = function isEmpty(thing) {
      return _typeof(thing) === "object" && thing != null && Object.keys(thing).length === 0;
    };

    processItem = function processItem(processors, item, key) {
      var i, len, process;

      for (i = 0, len = processors.length; i < len; i++) {
        process = processors[i];
        item = process(item, key);
      }

      return item;
    };

    exports.Parser = function (superClass) {
      extend(Parser, superClass);

      function Parser(opts) {
        this.parseStringPromise = bind(this.parseStringPromise, this);
        this.parseString = bind(this.parseString, this);
        this.reset = bind(this.reset, this);
        this.assignOrPush = bind(this.assignOrPush, this);
        this.processAsync = bind(this.processAsync, this);
        var key, ref, value;

        if (!(this instanceof exports.Parser)) {
          return new exports.Parser(opts);
        }

        this.options = {};
        ref = defaults$1["0.2"];

        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this.options[key] = value;
        }

        for (key in opts) {
          if (!hasProp.call(opts, key)) continue;
          value = opts[key];
          this.options[key] = value;
        }

        if (this.options.xmlns) {
          this.options.xmlnskey = this.options.attrkey + "ns";
        }

        if (this.options.normalizeTags) {
          if (!this.options.tagNameProcessors) {
            this.options.tagNameProcessors = [];
          }

          this.options.tagNameProcessors.unshift(processors$1.normalize);
        }

        this.reset();
      }

      Parser.prototype.processAsync = function () {
        var chunk, err;

        try {
          if (this.remaining.length <= this.options.chunkSize) {
            chunk = this.remaining;
            this.remaining = '';
            this.saxParser = this.saxParser.write(chunk);
            return this.saxParser.close();
          } else {
            chunk = this.remaining.substr(0, this.options.chunkSize);
            this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
            this.saxParser = this.saxParser.write(chunk);
            return setImmediate(this.processAsync);
          }
        } catch (error1) {
          err = error1;

          if (!this.saxParser.errThrown) {
            this.saxParser.errThrown = true;
            return this.emit(err);
          }
        }
      };

      Parser.prototype.assignOrPush = function (obj, key, newValue) {
        if (!(key in obj)) {
          if (!this.options.explicitArray) {
            return obj[key] = newValue;
          } else {
            return obj[key] = [newValue];
          }
        } else {
          if (!(obj[key] instanceof Array)) {
            obj[key] = [obj[key]];
          }

          return obj[key].push(newValue);
        }
      };

      Parser.prototype.reset = function () {
        var attrkey, charkey, ontext, stack;
        this.removeAllListeners();
        this.saxParser = sax$1.parser(this.options.strict, {
          trim: false,
          normalize: false,
          xmlns: this.options.xmlns
        });
        this.saxParser.errThrown = false;

        this.saxParser.onerror = function (_this) {
          return function (error) {
            _this.saxParser.resume();

            if (!_this.saxParser.errThrown) {
              _this.saxParser.errThrown = true;
              return _this.emit("error", error);
            }
          };
        }(this);

        this.saxParser.onend = function (_this) {
          return function () {
            if (!_this.saxParser.ended) {
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);

        this.saxParser.ended = false;
        this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
        this.resultObject = null;
        stack = [];
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;

        this.saxParser.onopentag = function (_this) {
          return function (node) {
            var key, newValue, obj, processedKey, ref;
            obj = {};
            obj[charkey] = "";

            if (!_this.options.ignoreAttrs) {
              ref = node.attributes;

              for (key in ref) {
                if (!hasProp.call(ref, key)) continue;

                if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                  obj[attrkey] = {};
                }

                newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;

                if (_this.options.mergeAttrs) {
                  _this.assignOrPush(obj, processedKey, newValue);
                } else {
                  obj[attrkey][processedKey] = newValue;
                }
              }
            }

            obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;

            if (_this.options.xmlns) {
              obj[_this.options.xmlnskey] = {
                uri: node.uri,
                local: node.local
              };
            }

            return stack.push(obj);
          };
        }(this);

        this.saxParser.onclosetag = function (_this) {
          return function () {
            var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
            obj = stack.pop();
            nodeName = obj["#name"];

            if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
              delete obj["#name"];
            }

            if (obj.cdata === true) {
              cdata = obj.cdata;
              delete obj.cdata;
            }

            s = stack[stack.length - 1];

            if (obj[charkey].match(/^\s*$/) && !cdata) {
              emptyStr = obj[charkey];
              delete obj[charkey];
            } else {
              if (_this.options.trim) {
                obj[charkey] = obj[charkey].trim();
              }

              if (_this.options.normalize) {
                obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
              }

              obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];

              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }

            if (isEmpty(obj)) {
              obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
            }

            if (_this.options.validator != null) {
              xpath = "/" + function () {
                var i, len, results;
                results = [];

                for (i = 0, len = stack.length; i < len; i++) {
                  node = stack[i];
                  results.push(node["#name"]);
                }

                return results;
              }().concat(nodeName).join("/");

              (function () {
                var err;

                try {
                  return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                } catch (error1) {
                  err = error1;
                  return _this.emit("error", err);
                }
              })();
            }

            if (_this.options.explicitChildren && !_this.options.mergeAttrs && _typeof(obj) === 'object') {
              if (!_this.options.preserveChildrenOrder) {
                node = {};

                if (_this.options.attrkey in obj) {
                  node[_this.options.attrkey] = obj[_this.options.attrkey];
                  delete obj[_this.options.attrkey];
                }

                if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                  node[_this.options.charkey] = obj[_this.options.charkey];
                  delete obj[_this.options.charkey];
                }

                if (Object.getOwnPropertyNames(obj).length > 0) {
                  node[_this.options.childkey] = obj;
                }

                obj = node;
              } else if (s) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                objClone = {};

                for (key in obj) {
                  if (!hasProp.call(obj, key)) continue;
                  objClone[key] = obj[key];
                }

                s[_this.options.childkey].push(objClone);

                delete obj["#name"];

                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
            }

            if (stack.length > 0) {
              return _this.assignOrPush(s, nodeName, obj);
            } else {
              if (_this.options.explicitRoot) {
                old = obj;
                obj = {};
                obj[nodeName] = old;
              }

              _this.resultObject = obj;
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);

        ontext = function (_this) {
          return function (text) {
            var charChild, s;
            s = stack[stack.length - 1];

            if (s) {
              s[charkey] += text;

              if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                charChild = {
                  '#name': '__text__'
                };
                charChild[charkey] = text;

                if (_this.options.normalize) {
                  charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                }

                s[_this.options.childkey].push(charChild);
              }

              return s;
            }
          };
        }(this);

        this.saxParser.ontext = ontext;
        return this.saxParser.oncdata = function (_this) {
          return function (text) {
            var s;
            s = ontext(text);

            if (s) {
              return s.cdata = true;
            }
          };
        }();
      };

      Parser.prototype.parseString = function (str, cb) {
        var err;

        if (cb != null && typeof cb === "function") {
          this.on("end", function (result) {
            this.reset();
            return cb(null, result);
          });
          this.on("error", function (err) {
            this.reset();
            return cb(err);
          });
        }

        try {
          str = str.toString();

          if (str.trim() === '') {
            this.emit("end", null);
            return true;
          }

          str = bom$1.stripBOM(str);

          if (this.options.async) {
            this.remaining = str;
            setImmediate(this.processAsync);
            return this.saxParser;
          }

          return this.saxParser.write(str).close();
        } catch (error1) {
          err = error1;

          if (!(this.saxParser.errThrown || this.saxParser.ended)) {
            this.emit('error', err);
            return this.saxParser.errThrown = true;
          } else if (this.saxParser.ended) {
            throw err;
          }
        }
      };

      Parser.prototype.parseStringPromise = function (str) {
        return new Promise(function (_this) {
          return function (resolve, reject) {
            return _this.parseString(str, function (err, value) {
              if (err) {
                return reject(err);
              } else {
                return resolve(value);
              }
            });
          };
        }(this));
      };

      return Parser;
    }(events);

    exports.parseString = function (str, a, b) {
      var cb, options, parser;

      if (b != null) {
        if (typeof b === 'function') {
          cb = b;
        }

        if (_typeof(a) === 'object') {
          options = a;
        }
      } else {
        if (typeof a === 'function') {
          cb = a;
        }

        options = {};
      }

      parser = new exports.Parser(options);
      return parser.parseString(str, cb);
    };

    exports.parseStringPromise = function (str, a) {
      var options, parser;

      if (_typeof(a) === 'object') {
        options = a;
      }

      parser = new exports.Parser(options);
      return parser.parseStringPromise(str);
    };
  }).call(commonjsGlobal);
});

var xml2js = createCommonjsModule(function (module, exports) {
  // Generated by CoffeeScript 1.12.7
  (function () {

    var builder$1,
        defaults$1,
        parser$1,
        processors$1,
        extend = function extend(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }

      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
        hasProp = {}.hasOwnProperty;

    defaults$1 = defaults;
    builder$1 = builder;
    parser$1 = parser;
    processors$1 = processors;
    exports.defaults = defaults$1.defaults;
    exports.processors = processors$1;

    exports.ValidationError = function (superClass) {
      extend(ValidationError, superClass);

      function ValidationError(message) {
        this.message = message;
      }

      return ValidationError;
    }(Error);

    exports.Builder = builder$1.Builder;
    exports.Parser = parser$1.Parser;
    exports.parseString = parser$1.parseString;
    exports.parseStringPromise = parser$1.parseStringPromise;
  }).call(commonjsGlobal);
});

var normalize = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.removePrefix = void 0;

  function removePrefix(prefix) {
    var prefixLength = prefix.length;
    return function (param) {
      return param.startsWith(prefix) ? param.slice(prefixLength) : param;
    };
  }

  exports.removePrefix = removePrefix;
});

var xmlParser = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.xml2json = void 0;
  var options = {
    trim: true,
    explicitArray: false,
    emptyTag: null,
    tagNameProcessors: [normalize.removePrefix('praw_'), processors.firstCharLowerCase]
  };
  var parser = new xml2js.Parser(options);

  function xml2json(_x) {
    return _xml2json.apply(this, arguments);
  }

  function _xml2json() {
    _xml2json = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(xml) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parser.parseStringPromise(lib$1.decodeXML(xml)));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _xml2json.apply(this, arguments);
  }

  exports.xml2json = xml2json;
});

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BirError = /*#__PURE__*/function (_Error) {
  _inherits(BirError, _Error);

  var _super = _createSuper(BirError);

  function BirError(message) {
    var _this;

    _classCallCheck(this, BirError);

    _this = _super.call(this, message); // restore prototype chain
    // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget

    Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof BirError ? this.constructor : void 0).prototype);
    Error.captureStackTrace(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(BirError, null, [{
    key: "fromResponse",
    value: function fromResponse(response) {
      var message = response.errorMessageEn || response.errorMessagePl || "BIR error code ".concat(response.errorCode);
      var error = new BirError(message);
      error.response = response;
      return error;
    }
  }, {
    key: "looksLike",
    value: function looksLike(response) {
      if (response.errorCode || response.errorMessageEn || response.errorMessagePl) {
        return true;
      }

      return false;
    }
  }]);

  return BirError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default$1 = BirError;
var birError = /*#__PURE__*/Object.defineProperty({
  default: _default$1
}, '__esModule', {
  value: true
});

var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var assert_1 = __importDefault$1(require$$0$6);

var got_1 = __importDefault$1(source);

var bir_error_js_1 = __importDefault$1(birError);

var url = {
  prod: 'https://wyszukiwarkaregon.stat.gov.pl/wsBIR/UslugaBIRzewnPubl.svc',
  test: 'https://wyszukiwarkaregontest.stat.gov.pl/wsBIR/UslugaBIRzewnPubl.svc'
};

function soapResult(string) {
  var match = /<[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uFEFE\uFF00-\uFFFF]+Result>([\s\S]+)<\/[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uFEFE\uFF00-\uFFFF]+Result>/.exec(string);
  assert_1.default(match && match[1], new Error('SOAP Result empty or not found in response'));
  return match[1];
}

function extractData(object) {
  return object['root']['dane'];
}

function validate(data) {
  if (bir_error_js_1.default.looksLike(data)) {
    throw bir_error_js_1.default.fromResponse(data);
  }

  return data;
}

var Bir = /*#__PURE__*/function () {
  function Bir() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Bir);

    this.key = options.key || 'abcde12345abcde12345';
    this.prod = options.key ? true : false;
    this.api = got_1.default.extend({
      method: 'POST',
      prefixUrl: this.prod ? url.prod : url.test,
      headers: {
        'Content-Type': 'application/soap+xml'
      }
    });
  }

  _createClass(Bir, [{
    key: "login",
    value: function () {
      var _login = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var body, response, sid;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                assert_1.default(this.key, new Error('no api key provided'));
                _context.next = 3;
                return template_1.template('Zaloguj', {
                  key: this.key
                });

              case 3:
                body = _context.sent;
                _context.next = 6;
                return this.api({
                  body: body
                });

              case 6:
                response = _context.sent;
                sid = soapResult(response.body);
                assert_1.default(sid, new Error('login failed, no session foun in response'));
                this.sid = sid;

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function login() {
        return _login.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "value",
    value: function () {
      var _value2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(_value) {
        var body, response;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return template_1.template('GetValue', {
                  value: _value
                });

              case 2:
                body = _context2.sent;
                _context2.next = 5;
                return this.api({
                  body: body
                });

              case 5:
                response = _context2.sent;
                return _context2.abrupt("return", soapResult(response.body));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function value(_x) {
        return _value2.apply(this, arguments);
      }

      return value;
    }()
  }, {
    key: "report",
    value: function () {
      var _report = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(query) {
        var body, response, result;
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return template_1.template('DanePobierzPelnyRaport', query);

              case 2:
                body = _context3.sent;
                _context3.next = 5;
                return this.api({
                  headers: {
                    sid: this.sid
                  },
                  body: body
                });

              case 5:
                response = _context3.sent;
                _context3.next = 8;
                return xmlParser.xml2json(soapResult(response.body));

              case 8:
                result = _context3.sent;
                return _context3.abrupt("return", validate(extractData(result)));

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function report(_x2) {
        return _report.apply(this, arguments);
      }

      return report;
    }()
  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(query) {
        var body, response, result;
        return regenerator.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return template_1.template('DaneSzukajPodmioty', query);

              case 2:
                body = _context4.sent;
                _context4.next = 5;
                return this.api({
                  headers: {
                    sid: this.sid
                  },
                  body: body
                });

              case 5:
                response = _context4.sent;
                _context4.next = 8;
                return xmlParser.xml2json(soapResult(response.body));

              case 8:
                result = _context4.sent;
                return _context4.abrupt("return", validate(extractData(result)));

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function search(_x3) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
  }]);

  return Bir;
}();

var _default = Bir;
var bir$1 = /*#__PURE__*/Object.defineProperty({
  default: _default
}, '__esModule', {
  value: true
});

var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var bir_1 = __importDefault(bir$1);

var dist = bir_1.default;

var bir = new dist();
await bir.login();
console.log(await bir.search({
  nip: '5261040567'
}));
var regonTestSrc = {};

export default regonTestSrc;
//# sourceMappingURL=regon-test.js.map
